#if defined(_MSC_VER)
  #pragma warning (disable:4946) // reinterpret_cast used between related classes: 'class1' and 'class2'
#endif
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: authzed/api/v1/core.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_authzed_2fapi_2fv1_2fcore_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_authzed_2fapi_2fv1_2fcore_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/struct.pb.h>
#include "pb/validate/validate.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_authzed_2fapi_2fv1_2fcore_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_authzed_2fapi_2fv1_2fcore_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_authzed_2fapi_2fv1_2fcore_2eproto;
namespace authzed {
namespace api {
namespace v1 {
class AlgebraicSubjectSet;
struct AlgebraicSubjectSetDefaultTypeInternal;
extern AlgebraicSubjectSetDefaultTypeInternal _AlgebraicSubjectSet_default_instance_;
class ContextualizedCaveat;
struct ContextualizedCaveatDefaultTypeInternal;
extern ContextualizedCaveatDefaultTypeInternal _ContextualizedCaveat_default_instance_;
class DirectSubjectSet;
struct DirectSubjectSetDefaultTypeInternal;
extern DirectSubjectSetDefaultTypeInternal _DirectSubjectSet_default_instance_;
class ObjectReference;
struct ObjectReferenceDefaultTypeInternal;
extern ObjectReferenceDefaultTypeInternal _ObjectReference_default_instance_;
class PartialCaveatInfo;
struct PartialCaveatInfoDefaultTypeInternal;
extern PartialCaveatInfoDefaultTypeInternal _PartialCaveatInfo_default_instance_;
class PermissionRelationshipTree;
struct PermissionRelationshipTreeDefaultTypeInternal;
extern PermissionRelationshipTreeDefaultTypeInternal _PermissionRelationshipTree_default_instance_;
class Relationship;
struct RelationshipDefaultTypeInternal;
extern RelationshipDefaultTypeInternal _Relationship_default_instance_;
class RelationshipUpdate;
struct RelationshipUpdateDefaultTypeInternal;
extern RelationshipUpdateDefaultTypeInternal _RelationshipUpdate_default_instance_;
class SubjectReference;
struct SubjectReferenceDefaultTypeInternal;
extern SubjectReferenceDefaultTypeInternal _SubjectReference_default_instance_;
class ZedToken;
struct ZedTokenDefaultTypeInternal;
extern ZedTokenDefaultTypeInternal _ZedToken_default_instance_;
}  // namespace v1
}  // namespace api
}  // namespace authzed
PROTOBUF_NAMESPACE_OPEN
template<> ::authzed::api::v1::AlgebraicSubjectSet* Arena::CreateMaybeMessage<::authzed::api::v1::AlgebraicSubjectSet>(Arena*);
template<> ::authzed::api::v1::ContextualizedCaveat* Arena::CreateMaybeMessage<::authzed::api::v1::ContextualizedCaveat>(Arena*);
template<> ::authzed::api::v1::DirectSubjectSet* Arena::CreateMaybeMessage<::authzed::api::v1::DirectSubjectSet>(Arena*);
template<> ::authzed::api::v1::ObjectReference* Arena::CreateMaybeMessage<::authzed::api::v1::ObjectReference>(Arena*);
template<> ::authzed::api::v1::PartialCaveatInfo* Arena::CreateMaybeMessage<::authzed::api::v1::PartialCaveatInfo>(Arena*);
template<> ::authzed::api::v1::PermissionRelationshipTree* Arena::CreateMaybeMessage<::authzed::api::v1::PermissionRelationshipTree>(Arena*);
template<> ::authzed::api::v1::Relationship* Arena::CreateMaybeMessage<::authzed::api::v1::Relationship>(Arena*);
template<> ::authzed::api::v1::RelationshipUpdate* Arena::CreateMaybeMessage<::authzed::api::v1::RelationshipUpdate>(Arena*);
template<> ::authzed::api::v1::SubjectReference* Arena::CreateMaybeMessage<::authzed::api::v1::SubjectReference>(Arena*);
template<> ::authzed::api::v1::ZedToken* Arena::CreateMaybeMessage<::authzed::api::v1::ZedToken>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace authzed {
namespace api {
namespace v1 {

enum RelationshipUpdate_Operation : int {
  RelationshipUpdate_Operation_OPERATION_UNSPECIFIED = 0,
  RelationshipUpdate_Operation_OPERATION_CREATE = 1,
  RelationshipUpdate_Operation_OPERATION_TOUCH = 2,
  RelationshipUpdate_Operation_OPERATION_DELETE = 3,
  RelationshipUpdate_Operation_RelationshipUpdate_Operation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RelationshipUpdate_Operation_RelationshipUpdate_Operation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RelationshipUpdate_Operation_IsValid(int value);
constexpr RelationshipUpdate_Operation RelationshipUpdate_Operation_Operation_MIN = RelationshipUpdate_Operation_OPERATION_UNSPECIFIED;
constexpr RelationshipUpdate_Operation RelationshipUpdate_Operation_Operation_MAX = RelationshipUpdate_Operation_OPERATION_DELETE;
constexpr int RelationshipUpdate_Operation_Operation_ARRAYSIZE = RelationshipUpdate_Operation_Operation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RelationshipUpdate_Operation_descriptor();
template<typename T>
inline const std::string& RelationshipUpdate_Operation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RelationshipUpdate_Operation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RelationshipUpdate_Operation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RelationshipUpdate_Operation_descriptor(), enum_t_value);
}
inline bool RelationshipUpdate_Operation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RelationshipUpdate_Operation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RelationshipUpdate_Operation>(
    RelationshipUpdate_Operation_descriptor(), name, value);
}
enum AlgebraicSubjectSet_Operation : int {
  AlgebraicSubjectSet_Operation_OPERATION_UNSPECIFIED = 0,
  AlgebraicSubjectSet_Operation_OPERATION_UNION = 1,
  AlgebraicSubjectSet_Operation_OPERATION_INTERSECTION = 2,
  AlgebraicSubjectSet_Operation_OPERATION_EXCLUSION = 3,
  AlgebraicSubjectSet_Operation_AlgebraicSubjectSet_Operation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AlgebraicSubjectSet_Operation_AlgebraicSubjectSet_Operation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AlgebraicSubjectSet_Operation_IsValid(int value);
constexpr AlgebraicSubjectSet_Operation AlgebraicSubjectSet_Operation_Operation_MIN = AlgebraicSubjectSet_Operation_OPERATION_UNSPECIFIED;
constexpr AlgebraicSubjectSet_Operation AlgebraicSubjectSet_Operation_Operation_MAX = AlgebraicSubjectSet_Operation_OPERATION_EXCLUSION;
constexpr int AlgebraicSubjectSet_Operation_Operation_ARRAYSIZE = AlgebraicSubjectSet_Operation_Operation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AlgebraicSubjectSet_Operation_descriptor();
template<typename T>
inline const std::string& AlgebraicSubjectSet_Operation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AlgebraicSubjectSet_Operation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AlgebraicSubjectSet_Operation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AlgebraicSubjectSet_Operation_descriptor(), enum_t_value);
}
inline bool AlgebraicSubjectSet_Operation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AlgebraicSubjectSet_Operation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AlgebraicSubjectSet_Operation>(
    AlgebraicSubjectSet_Operation_descriptor(), name, value);
}
// ===================================================================

class Relationship final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.Relationship) */ {
 public:
  inline Relationship() : Relationship(nullptr) {}
  ~Relationship() override;
  explicit PROTOBUF_CONSTEXPR Relationship(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Relationship(const Relationship& from);
  Relationship(Relationship&& from) noexcept
    : Relationship() {
    *this = ::std::move(from);
  }

  inline Relationship& operator=(const Relationship& from) {
    CopyFrom(from);
    return *this;
  }
  inline Relationship& operator=(Relationship&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Relationship& default_instance() {
    return *internal_default_instance();
  }
  static inline const Relationship* internal_default_instance() {
    return reinterpret_cast<const Relationship*>(
               &_Relationship_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Relationship& a, Relationship& b) {
    a.Swap(&b);
  }
  inline void Swap(Relationship* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Relationship* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Relationship* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Relationship>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Relationship& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Relationship& from) {
    Relationship::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Relationship* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.Relationship";
  }
  protected:
  explicit Relationship(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRelationFieldNumber = 2,
    kResourceFieldNumber = 1,
    kSubjectFieldNumber = 3,
    kOptionalCaveatFieldNumber = 4,
  };
  // string relation = 2 [json_name = "relation", (.validate.rules) = {
  void clear_relation();
  const std::string& relation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_relation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_relation();
  PROTOBUF_NODISCARD std::string* release_relation();
  void set_allocated_relation(std::string* relation);
  private:
  const std::string& _internal_relation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relation(const std::string& value);
  std::string* _internal_mutable_relation();
  public:

  // .authzed.api.v1.ObjectReference resource = 1 [json_name = "resource", (.validate.rules) = {
  bool has_resource() const;
  private:
  bool _internal_has_resource() const;
  public:
  void clear_resource();
  const ::authzed::api::v1::ObjectReference& resource() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::ObjectReference* release_resource();
  ::authzed::api::v1::ObjectReference* mutable_resource();
  void set_allocated_resource(::authzed::api::v1::ObjectReference* resource);
  private:
  const ::authzed::api::v1::ObjectReference& _internal_resource() const;
  ::authzed::api::v1::ObjectReference* _internal_mutable_resource();
  public:
  void unsafe_arena_set_allocated_resource(
      ::authzed::api::v1::ObjectReference* resource);
  ::authzed::api::v1::ObjectReference* unsafe_arena_release_resource();

  // .authzed.api.v1.SubjectReference subject = 3 [json_name = "subject", (.validate.rules) = {
  bool has_subject() const;
  private:
  bool _internal_has_subject() const;
  public:
  void clear_subject();
  const ::authzed::api::v1::SubjectReference& subject() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::SubjectReference* release_subject();
  ::authzed::api::v1::SubjectReference* mutable_subject();
  void set_allocated_subject(::authzed::api::v1::SubjectReference* subject);
  private:
  const ::authzed::api::v1::SubjectReference& _internal_subject() const;
  ::authzed::api::v1::SubjectReference* _internal_mutable_subject();
  public:
  void unsafe_arena_set_allocated_subject(
      ::authzed::api::v1::SubjectReference* subject);
  ::authzed::api::v1::SubjectReference* unsafe_arena_release_subject();

  // .authzed.api.v1.ContextualizedCaveat optional_caveat = 4 [json_name = "optionalCaveat", (.validate.rules) = {
  bool has_optional_caveat() const;
  private:
  bool _internal_has_optional_caveat() const;
  public:
  void clear_optional_caveat();
  const ::authzed::api::v1::ContextualizedCaveat& optional_caveat() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::ContextualizedCaveat* release_optional_caveat();
  ::authzed::api::v1::ContextualizedCaveat* mutable_optional_caveat();
  void set_allocated_optional_caveat(::authzed::api::v1::ContextualizedCaveat* optional_caveat);
  private:
  const ::authzed::api::v1::ContextualizedCaveat& _internal_optional_caveat() const;
  ::authzed::api::v1::ContextualizedCaveat* _internal_mutable_optional_caveat();
  public:
  void unsafe_arena_set_allocated_optional_caveat(
      ::authzed::api::v1::ContextualizedCaveat* optional_caveat);
  ::authzed::api::v1::ContextualizedCaveat* unsafe_arena_release_optional_caveat();

  // @@protoc_insertion_point(class_scope:authzed.api.v1.Relationship)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relation_;
    ::authzed::api::v1::ObjectReference* resource_;
    ::authzed::api::v1::SubjectReference* subject_;
    ::authzed::api::v1::ContextualizedCaveat* optional_caveat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fcore_2eproto;
};
// -------------------------------------------------------------------

class ContextualizedCaveat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.ContextualizedCaveat) */ {
 public:
  inline ContextualizedCaveat() : ContextualizedCaveat(nullptr) {}
  ~ContextualizedCaveat() override;
  explicit PROTOBUF_CONSTEXPR ContextualizedCaveat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContextualizedCaveat(const ContextualizedCaveat& from);
  ContextualizedCaveat(ContextualizedCaveat&& from) noexcept
    : ContextualizedCaveat() {
    *this = ::std::move(from);
  }

  inline ContextualizedCaveat& operator=(const ContextualizedCaveat& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContextualizedCaveat& operator=(ContextualizedCaveat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContextualizedCaveat& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContextualizedCaveat* internal_default_instance() {
    return reinterpret_cast<const ContextualizedCaveat*>(
               &_ContextualizedCaveat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ContextualizedCaveat& a, ContextualizedCaveat& b) {
    a.Swap(&b);
  }
  inline void Swap(ContextualizedCaveat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContextualizedCaveat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContextualizedCaveat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContextualizedCaveat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContextualizedCaveat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContextualizedCaveat& from) {
    ContextualizedCaveat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContextualizedCaveat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.ContextualizedCaveat";
  }
  protected:
  explicit ContextualizedCaveat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCaveatNameFieldNumber = 1,
    kContextFieldNumber = 2,
  };
  // string caveat_name = 1 [json_name = "caveatName", (.validate.rules) = {
  void clear_caveat_name();
  const std::string& caveat_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_caveat_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_caveat_name();
  PROTOBUF_NODISCARD std::string* release_caveat_name();
  void set_allocated_caveat_name(std::string* caveat_name);
  private:
  const std::string& _internal_caveat_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_caveat_name(const std::string& value);
  std::string* _internal_mutable_caveat_name();
  public:

  // .google.protobuf.Struct context = 2 [json_name = "context", (.validate.rules) = {
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::PROTOBUF_NAMESPACE_ID::Struct& context() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_context();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_context();
  void set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_context() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::PROTOBUF_NAMESPACE_ID::Struct* context);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_context();

  // @@protoc_insertion_point(class_scope:authzed.api.v1.ContextualizedCaveat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr caveat_name_;
    ::PROTOBUF_NAMESPACE_ID::Struct* context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fcore_2eproto;
};
// -------------------------------------------------------------------

class SubjectReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.SubjectReference) */ {
 public:
  inline SubjectReference() : SubjectReference(nullptr) {}
  ~SubjectReference() override;
  explicit PROTOBUF_CONSTEXPR SubjectReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubjectReference(const SubjectReference& from);
  SubjectReference(SubjectReference&& from) noexcept
    : SubjectReference() {
    *this = ::std::move(from);
  }

  inline SubjectReference& operator=(const SubjectReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubjectReference& operator=(SubjectReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubjectReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubjectReference* internal_default_instance() {
    return reinterpret_cast<const SubjectReference*>(
               &_SubjectReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SubjectReference& a, SubjectReference& b) {
    a.Swap(&b);
  }
  inline void Swap(SubjectReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubjectReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubjectReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubjectReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubjectReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubjectReference& from) {
    SubjectReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubjectReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.SubjectReference";
  }
  protected:
  explicit SubjectReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionalRelationFieldNumber = 2,
    kObjectFieldNumber = 1,
  };
  // string optional_relation = 2 [json_name = "optionalRelation", (.validate.rules) = {
  void clear_optional_relation();
  const std::string& optional_relation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_optional_relation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_optional_relation();
  PROTOBUF_NODISCARD std::string* release_optional_relation();
  void set_allocated_optional_relation(std::string* optional_relation);
  private:
  const std::string& _internal_optional_relation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_optional_relation(const std::string& value);
  std::string* _internal_mutable_optional_relation();
  public:

  // .authzed.api.v1.ObjectReference object = 1 [json_name = "object", (.validate.rules) = {
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::authzed::api::v1::ObjectReference& object() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::ObjectReference* release_object();
  ::authzed::api::v1::ObjectReference* mutable_object();
  void set_allocated_object(::authzed::api::v1::ObjectReference* object);
  private:
  const ::authzed::api::v1::ObjectReference& _internal_object() const;
  ::authzed::api::v1::ObjectReference* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::authzed::api::v1::ObjectReference* object);
  ::authzed::api::v1::ObjectReference* unsafe_arena_release_object();

  // @@protoc_insertion_point(class_scope:authzed.api.v1.SubjectReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr optional_relation_;
    ::authzed::api::v1::ObjectReference* object_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fcore_2eproto;
};
// -------------------------------------------------------------------

class ObjectReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.ObjectReference) */ {
 public:
  inline ObjectReference() : ObjectReference(nullptr) {}
  ~ObjectReference() override;
  explicit PROTOBUF_CONSTEXPR ObjectReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectReference(const ObjectReference& from);
  ObjectReference(ObjectReference&& from) noexcept
    : ObjectReference() {
    *this = ::std::move(from);
  }

  inline ObjectReference& operator=(const ObjectReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectReference& operator=(ObjectReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectReference* internal_default_instance() {
    return reinterpret_cast<const ObjectReference*>(
               &_ObjectReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ObjectReference& a, ObjectReference& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObjectReference& from) {
    ObjectReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.ObjectReference";
  }
  protected:
  explicit ObjectReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectTypeFieldNumber = 1,
    kObjectIdFieldNumber = 2,
  };
  // string object_type = 1 [json_name = "objectType", (.validate.rules) = {
  void clear_object_type();
  const std::string& object_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_object_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_object_type();
  PROTOBUF_NODISCARD std::string* release_object_type();
  void set_allocated_object_type(std::string* object_type);
  private:
  const std::string& _internal_object_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object_type(const std::string& value);
  std::string* _internal_mutable_object_type();
  public:

  // string object_id = 2 [json_name = "objectId", (.validate.rules) = {
  void clear_object_id();
  const std::string& object_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_object_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_object_id();
  PROTOBUF_NODISCARD std::string* release_object_id();
  void set_allocated_object_id(std::string* object_id);
  private:
  const std::string& _internal_object_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object_id(const std::string& value);
  std::string* _internal_mutable_object_id();
  public:

  // @@protoc_insertion_point(class_scope:authzed.api.v1.ObjectReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr object_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr object_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fcore_2eproto;
};
// -------------------------------------------------------------------

class ZedToken final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.ZedToken) */ {
 public:
  inline ZedToken() : ZedToken(nullptr) {}
  ~ZedToken() override;
  explicit PROTOBUF_CONSTEXPR ZedToken(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ZedToken(const ZedToken& from);
  ZedToken(ZedToken&& from) noexcept
    : ZedToken() {
    *this = ::std::move(from);
  }

  inline ZedToken& operator=(const ZedToken& from) {
    CopyFrom(from);
    return *this;
  }
  inline ZedToken& operator=(ZedToken&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ZedToken& default_instance() {
    return *internal_default_instance();
  }
  static inline const ZedToken* internal_default_instance() {
    return reinterpret_cast<const ZedToken*>(
               &_ZedToken_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ZedToken& a, ZedToken& b) {
    a.Swap(&b);
  }
  inline void Swap(ZedToken* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ZedToken* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ZedToken* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ZedToken>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ZedToken& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ZedToken& from) {
    ZedToken::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ZedToken* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.ZedToken";
  }
  protected:
  explicit ZedToken(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
  };
  // string token = 1 [json_name = "token", (.validate.rules) = {
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // @@protoc_insertion_point(class_scope:authzed.api.v1.ZedToken)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fcore_2eproto;
};
// -------------------------------------------------------------------

class RelationshipUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.RelationshipUpdate) */ {
 public:
  inline RelationshipUpdate() : RelationshipUpdate(nullptr) {}
  ~RelationshipUpdate() override;
  explicit PROTOBUF_CONSTEXPR RelationshipUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelationshipUpdate(const RelationshipUpdate& from);
  RelationshipUpdate(RelationshipUpdate&& from) noexcept
    : RelationshipUpdate() {
    *this = ::std::move(from);
  }

  inline RelationshipUpdate& operator=(const RelationshipUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelationshipUpdate& operator=(RelationshipUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelationshipUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelationshipUpdate* internal_default_instance() {
    return reinterpret_cast<const RelationshipUpdate*>(
               &_RelationshipUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RelationshipUpdate& a, RelationshipUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(RelationshipUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelationshipUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelationshipUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelationshipUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RelationshipUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RelationshipUpdate& from) {
    RelationshipUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelationshipUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.RelationshipUpdate";
  }
  protected:
  explicit RelationshipUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RelationshipUpdate_Operation Operation;
  static constexpr Operation OPERATION_UNSPECIFIED =
    RelationshipUpdate_Operation_OPERATION_UNSPECIFIED;
  static constexpr Operation OPERATION_CREATE =
    RelationshipUpdate_Operation_OPERATION_CREATE;
  static constexpr Operation OPERATION_TOUCH =
    RelationshipUpdate_Operation_OPERATION_TOUCH;
  static constexpr Operation OPERATION_DELETE =
    RelationshipUpdate_Operation_OPERATION_DELETE;
  static inline bool Operation_IsValid(int value) {
    return RelationshipUpdate_Operation_IsValid(value);
  }
  static constexpr Operation Operation_MIN =
    RelationshipUpdate_Operation_Operation_MIN;
  static constexpr Operation Operation_MAX =
    RelationshipUpdate_Operation_Operation_MAX;
  static constexpr int Operation_ARRAYSIZE =
    RelationshipUpdate_Operation_Operation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Operation_descriptor() {
    return RelationshipUpdate_Operation_descriptor();
  }
  template<typename T>
  static inline const std::string& Operation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Operation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Operation_Name.");
    return RelationshipUpdate_Operation_Name(enum_t_value);
  }
  static inline bool Operation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Operation* value) {
    return RelationshipUpdate_Operation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRelationshipFieldNumber = 2,
    kOperationFieldNumber = 1,
  };
  // .authzed.api.v1.Relationship relationship = 2 [json_name = "relationship", (.validate.rules) = {
  bool has_relationship() const;
  private:
  bool _internal_has_relationship() const;
  public:
  void clear_relationship();
  const ::authzed::api::v1::Relationship& relationship() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::Relationship* release_relationship();
  ::authzed::api::v1::Relationship* mutable_relationship();
  void set_allocated_relationship(::authzed::api::v1::Relationship* relationship);
  private:
  const ::authzed::api::v1::Relationship& _internal_relationship() const;
  ::authzed::api::v1::Relationship* _internal_mutable_relationship();
  public:
  void unsafe_arena_set_allocated_relationship(
      ::authzed::api::v1::Relationship* relationship);
  ::authzed::api::v1::Relationship* unsafe_arena_release_relationship();

  // .authzed.api.v1.RelationshipUpdate.Operation operation = 1 [json_name = "operation", (.validate.rules) = {
  void clear_operation();
  ::authzed::api::v1::RelationshipUpdate_Operation operation() const;
  void set_operation(::authzed::api::v1::RelationshipUpdate_Operation value);
  private:
  ::authzed::api::v1::RelationshipUpdate_Operation _internal_operation() const;
  void _internal_set_operation(::authzed::api::v1::RelationshipUpdate_Operation value);
  public:

  // @@protoc_insertion_point(class_scope:authzed.api.v1.RelationshipUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::authzed::api::v1::Relationship* relationship_;
    int operation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fcore_2eproto;
};
// -------------------------------------------------------------------

class PermissionRelationshipTree final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.PermissionRelationshipTree) */ {
 public:
  inline PermissionRelationshipTree() : PermissionRelationshipTree(nullptr) {}
  ~PermissionRelationshipTree() override;
  explicit PROTOBUF_CONSTEXPR PermissionRelationshipTree(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PermissionRelationshipTree(const PermissionRelationshipTree& from);
  PermissionRelationshipTree(PermissionRelationshipTree&& from) noexcept
    : PermissionRelationshipTree() {
    *this = ::std::move(from);
  }

  inline PermissionRelationshipTree& operator=(const PermissionRelationshipTree& from) {
    CopyFrom(from);
    return *this;
  }
  inline PermissionRelationshipTree& operator=(PermissionRelationshipTree&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PermissionRelationshipTree& default_instance() {
    return *internal_default_instance();
  }
  enum TreeTypeCase {
    kIntermediate = 1,
    kLeaf = 2,
    TREE_TYPE_NOT_SET = 0,
  };

  static inline const PermissionRelationshipTree* internal_default_instance() {
    return reinterpret_cast<const PermissionRelationshipTree*>(
               &_PermissionRelationshipTree_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PermissionRelationshipTree& a, PermissionRelationshipTree& b) {
    a.Swap(&b);
  }
  inline void Swap(PermissionRelationshipTree* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PermissionRelationshipTree* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PermissionRelationshipTree* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PermissionRelationshipTree>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PermissionRelationshipTree& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PermissionRelationshipTree& from) {
    PermissionRelationshipTree::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PermissionRelationshipTree* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.PermissionRelationshipTree";
  }
  protected:
  explicit PermissionRelationshipTree(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExpandedRelationFieldNumber = 4,
    kExpandedObjectFieldNumber = 3,
    kIntermediateFieldNumber = 1,
    kLeafFieldNumber = 2,
  };
  // string expanded_relation = 4 [json_name = "expandedRelation"];
  void clear_expanded_relation();
  const std::string& expanded_relation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_expanded_relation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_expanded_relation();
  PROTOBUF_NODISCARD std::string* release_expanded_relation();
  void set_allocated_expanded_relation(std::string* expanded_relation);
  private:
  const std::string& _internal_expanded_relation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expanded_relation(const std::string& value);
  std::string* _internal_mutable_expanded_relation();
  public:

  // .authzed.api.v1.ObjectReference expanded_object = 3 [json_name = "expandedObject"];
  bool has_expanded_object() const;
  private:
  bool _internal_has_expanded_object() const;
  public:
  void clear_expanded_object();
  const ::authzed::api::v1::ObjectReference& expanded_object() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::ObjectReference* release_expanded_object();
  ::authzed::api::v1::ObjectReference* mutable_expanded_object();
  void set_allocated_expanded_object(::authzed::api::v1::ObjectReference* expanded_object);
  private:
  const ::authzed::api::v1::ObjectReference& _internal_expanded_object() const;
  ::authzed::api::v1::ObjectReference* _internal_mutable_expanded_object();
  public:
  void unsafe_arena_set_allocated_expanded_object(
      ::authzed::api::v1::ObjectReference* expanded_object);
  ::authzed::api::v1::ObjectReference* unsafe_arena_release_expanded_object();

  // .authzed.api.v1.AlgebraicSubjectSet intermediate = 1 [json_name = "intermediate"];
  bool has_intermediate() const;
  private:
  bool _internal_has_intermediate() const;
  public:
  void clear_intermediate();
  const ::authzed::api::v1::AlgebraicSubjectSet& intermediate() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::AlgebraicSubjectSet* release_intermediate();
  ::authzed::api::v1::AlgebraicSubjectSet* mutable_intermediate();
  void set_allocated_intermediate(::authzed::api::v1::AlgebraicSubjectSet* intermediate);
  private:
  const ::authzed::api::v1::AlgebraicSubjectSet& _internal_intermediate() const;
  ::authzed::api::v1::AlgebraicSubjectSet* _internal_mutable_intermediate();
  public:
  void unsafe_arena_set_allocated_intermediate(
      ::authzed::api::v1::AlgebraicSubjectSet* intermediate);
  ::authzed::api::v1::AlgebraicSubjectSet* unsafe_arena_release_intermediate();

  // .authzed.api.v1.DirectSubjectSet leaf = 2 [json_name = "leaf"];
  bool has_leaf() const;
  private:
  bool _internal_has_leaf() const;
  public:
  void clear_leaf();
  const ::authzed::api::v1::DirectSubjectSet& leaf() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::DirectSubjectSet* release_leaf();
  ::authzed::api::v1::DirectSubjectSet* mutable_leaf();
  void set_allocated_leaf(::authzed::api::v1::DirectSubjectSet* leaf);
  private:
  const ::authzed::api::v1::DirectSubjectSet& _internal_leaf() const;
  ::authzed::api::v1::DirectSubjectSet* _internal_mutable_leaf();
  public:
  void unsafe_arena_set_allocated_leaf(
      ::authzed::api::v1::DirectSubjectSet* leaf);
  ::authzed::api::v1::DirectSubjectSet* unsafe_arena_release_leaf();

  void clear_tree_type();
  TreeTypeCase tree_type_case() const;
  // @@protoc_insertion_point(class_scope:authzed.api.v1.PermissionRelationshipTree)
 private:
  class _Internal;
  void set_has_intermediate();
  void set_has_leaf();

  inline bool has_tree_type() const;
  inline void clear_has_tree_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr expanded_relation_;
    ::authzed::api::v1::ObjectReference* expanded_object_;
    union TreeTypeUnion {
      constexpr TreeTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::authzed::api::v1::AlgebraicSubjectSet* intermediate_;
      ::authzed::api::v1::DirectSubjectSet* leaf_;
    } tree_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fcore_2eproto;
};
// -------------------------------------------------------------------

class AlgebraicSubjectSet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.AlgebraicSubjectSet) */ {
 public:
  inline AlgebraicSubjectSet() : AlgebraicSubjectSet(nullptr) {}
  ~AlgebraicSubjectSet() override;
  explicit PROTOBUF_CONSTEXPR AlgebraicSubjectSet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlgebraicSubjectSet(const AlgebraicSubjectSet& from);
  AlgebraicSubjectSet(AlgebraicSubjectSet&& from) noexcept
    : AlgebraicSubjectSet() {
    *this = ::std::move(from);
  }

  inline AlgebraicSubjectSet& operator=(const AlgebraicSubjectSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlgebraicSubjectSet& operator=(AlgebraicSubjectSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlgebraicSubjectSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlgebraicSubjectSet* internal_default_instance() {
    return reinterpret_cast<const AlgebraicSubjectSet*>(
               &_AlgebraicSubjectSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AlgebraicSubjectSet& a, AlgebraicSubjectSet& b) {
    a.Swap(&b);
  }
  inline void Swap(AlgebraicSubjectSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlgebraicSubjectSet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlgebraicSubjectSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlgebraicSubjectSet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AlgebraicSubjectSet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AlgebraicSubjectSet& from) {
    AlgebraicSubjectSet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlgebraicSubjectSet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.AlgebraicSubjectSet";
  }
  protected:
  explicit AlgebraicSubjectSet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AlgebraicSubjectSet_Operation Operation;
  static constexpr Operation OPERATION_UNSPECIFIED =
    AlgebraicSubjectSet_Operation_OPERATION_UNSPECIFIED;
  static constexpr Operation OPERATION_UNION =
    AlgebraicSubjectSet_Operation_OPERATION_UNION;
  static constexpr Operation OPERATION_INTERSECTION =
    AlgebraicSubjectSet_Operation_OPERATION_INTERSECTION;
  static constexpr Operation OPERATION_EXCLUSION =
    AlgebraicSubjectSet_Operation_OPERATION_EXCLUSION;
  static inline bool Operation_IsValid(int value) {
    return AlgebraicSubjectSet_Operation_IsValid(value);
  }
  static constexpr Operation Operation_MIN =
    AlgebraicSubjectSet_Operation_Operation_MIN;
  static constexpr Operation Operation_MAX =
    AlgebraicSubjectSet_Operation_Operation_MAX;
  static constexpr int Operation_ARRAYSIZE =
    AlgebraicSubjectSet_Operation_Operation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Operation_descriptor() {
    return AlgebraicSubjectSet_Operation_descriptor();
  }
  template<typename T>
  static inline const std::string& Operation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Operation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Operation_Name.");
    return AlgebraicSubjectSet_Operation_Name(enum_t_value);
  }
  static inline bool Operation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Operation* value) {
    return AlgebraicSubjectSet_Operation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kChildrenFieldNumber = 2,
    kOperationFieldNumber = 1,
  };
  // repeated .authzed.api.v1.PermissionRelationshipTree children = 2 [json_name = "children", (.validate.rules) = {
  int children_size() const;
  private:
  int _internal_children_size() const;
  public:
  void clear_children();
  ::authzed::api::v1::PermissionRelationshipTree* mutable_children(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::PermissionRelationshipTree >*
      mutable_children();
  private:
  const ::authzed::api::v1::PermissionRelationshipTree& _internal_children(int index) const;
  ::authzed::api::v1::PermissionRelationshipTree* _internal_add_children();
  public:
  const ::authzed::api::v1::PermissionRelationshipTree& children(int index) const;
  ::authzed::api::v1::PermissionRelationshipTree* add_children();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::PermissionRelationshipTree >&
      children() const;

  // .authzed.api.v1.AlgebraicSubjectSet.Operation operation = 1 [json_name = "operation", (.validate.rules) = {
  void clear_operation();
  ::authzed::api::v1::AlgebraicSubjectSet_Operation operation() const;
  void set_operation(::authzed::api::v1::AlgebraicSubjectSet_Operation value);
  private:
  ::authzed::api::v1::AlgebraicSubjectSet_Operation _internal_operation() const;
  void _internal_set_operation(::authzed::api::v1::AlgebraicSubjectSet_Operation value);
  public:

  // @@protoc_insertion_point(class_scope:authzed.api.v1.AlgebraicSubjectSet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::PermissionRelationshipTree > children_;
    int operation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fcore_2eproto;
};
// -------------------------------------------------------------------

class DirectSubjectSet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.DirectSubjectSet) */ {
 public:
  inline DirectSubjectSet() : DirectSubjectSet(nullptr) {}
  ~DirectSubjectSet() override;
  explicit PROTOBUF_CONSTEXPR DirectSubjectSet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectSubjectSet(const DirectSubjectSet& from);
  DirectSubjectSet(DirectSubjectSet&& from) noexcept
    : DirectSubjectSet() {
    *this = ::std::move(from);
  }

  inline DirectSubjectSet& operator=(const DirectSubjectSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectSubjectSet& operator=(DirectSubjectSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DirectSubjectSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectSubjectSet* internal_default_instance() {
    return reinterpret_cast<const DirectSubjectSet*>(
               &_DirectSubjectSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DirectSubjectSet& a, DirectSubjectSet& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectSubjectSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectSubjectSet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DirectSubjectSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DirectSubjectSet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DirectSubjectSet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DirectSubjectSet& from) {
    DirectSubjectSet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectSubjectSet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.DirectSubjectSet";
  }
  protected:
  explicit DirectSubjectSet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubjectsFieldNumber = 1,
  };
  // repeated .authzed.api.v1.SubjectReference subjects = 1 [json_name = "subjects"];
  int subjects_size() const;
  private:
  int _internal_subjects_size() const;
  public:
  void clear_subjects();
  ::authzed::api::v1::SubjectReference* mutable_subjects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::SubjectReference >*
      mutable_subjects();
  private:
  const ::authzed::api::v1::SubjectReference& _internal_subjects(int index) const;
  ::authzed::api::v1::SubjectReference* _internal_add_subjects();
  public:
  const ::authzed::api::v1::SubjectReference& subjects(int index) const;
  ::authzed::api::v1::SubjectReference* add_subjects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::SubjectReference >&
      subjects() const;

  // @@protoc_insertion_point(class_scope:authzed.api.v1.DirectSubjectSet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::SubjectReference > subjects_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fcore_2eproto;
};
// -------------------------------------------------------------------

class PartialCaveatInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.PartialCaveatInfo) */ {
 public:
  inline PartialCaveatInfo() : PartialCaveatInfo(nullptr) {}
  ~PartialCaveatInfo() override;
  explicit PROTOBUF_CONSTEXPR PartialCaveatInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartialCaveatInfo(const PartialCaveatInfo& from);
  PartialCaveatInfo(PartialCaveatInfo&& from) noexcept
    : PartialCaveatInfo() {
    *this = ::std::move(from);
  }

  inline PartialCaveatInfo& operator=(const PartialCaveatInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartialCaveatInfo& operator=(PartialCaveatInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartialCaveatInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartialCaveatInfo* internal_default_instance() {
    return reinterpret_cast<const PartialCaveatInfo*>(
               &_PartialCaveatInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PartialCaveatInfo& a, PartialCaveatInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PartialCaveatInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartialCaveatInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartialCaveatInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PartialCaveatInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartialCaveatInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PartialCaveatInfo& from) {
    PartialCaveatInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartialCaveatInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.PartialCaveatInfo";
  }
  protected:
  explicit PartialCaveatInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMissingRequiredContextFieldNumber = 1,
  };
  // repeated string missing_required_context = 1 [json_name = "missingRequiredContext", (.validate.rules) = {
  int missing_required_context_size() const;
  private:
  int _internal_missing_required_context_size() const;
  public:
  void clear_missing_required_context();
  const std::string& missing_required_context(int index) const;
  std::string* mutable_missing_required_context(int index);
  void set_missing_required_context(int index, const std::string& value);
  void set_missing_required_context(int index, std::string&& value);
  void set_missing_required_context(int index, const char* value);
  void set_missing_required_context(int index, const char* value, size_t size);
  std::string* add_missing_required_context();
  void add_missing_required_context(const std::string& value);
  void add_missing_required_context(std::string&& value);
  void add_missing_required_context(const char* value);
  void add_missing_required_context(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& missing_required_context() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_missing_required_context();
  private:
  const std::string& _internal_missing_required_context(int index) const;
  std::string* _internal_add_missing_required_context();
  public:

  // @@protoc_insertion_point(class_scope:authzed.api.v1.PartialCaveatInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> missing_required_context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fcore_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Relationship

// .authzed.api.v1.ObjectReference resource = 1 [json_name = "resource", (.validate.rules) = {
inline bool Relationship::_internal_has_resource() const {
  return this != internal_default_instance() && _impl_.resource_ != nullptr;
}
inline bool Relationship::has_resource() const {
  return _internal_has_resource();
}
inline void Relationship::clear_resource() {
  if (GetArenaForAllocation() == nullptr && _impl_.resource_ != nullptr) {
    delete _impl_.resource_;
  }
  _impl_.resource_ = nullptr;
}
inline const ::authzed::api::v1::ObjectReference& Relationship::_internal_resource() const {
  const ::authzed::api::v1::ObjectReference* p = _impl_.resource_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::ObjectReference&>(
      ::authzed::api::v1::_ObjectReference_default_instance_);
}
inline const ::authzed::api::v1::ObjectReference& Relationship::resource() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.Relationship.resource)
  return _internal_resource();
}
inline void Relationship::unsafe_arena_set_allocated_resource(
    ::authzed::api::v1::ObjectReference* resource) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resource_);
  }
  _impl_.resource_ = resource;
  if (resource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.Relationship.resource)
}
inline ::authzed::api::v1::ObjectReference* Relationship::release_resource() {
  
  ::authzed::api::v1::ObjectReference* temp = _impl_.resource_;
  _impl_.resource_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::ObjectReference* Relationship::unsafe_arena_release_resource() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.Relationship.resource)
  
  ::authzed::api::v1::ObjectReference* temp = _impl_.resource_;
  _impl_.resource_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::ObjectReference* Relationship::_internal_mutable_resource() {
  
  if (_impl_.resource_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::ObjectReference>(GetArenaForAllocation());
    _impl_.resource_ = p;
  }
  return _impl_.resource_;
}
inline ::authzed::api::v1::ObjectReference* Relationship::mutable_resource() {
  ::authzed::api::v1::ObjectReference* _msg = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.Relationship.resource)
  return _msg;
}
inline void Relationship::set_allocated_resource(::authzed::api::v1::ObjectReference* resource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.resource_;
  }
  if (resource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(resource);
    if (message_arena != submessage_arena) {
      resource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resource, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.resource_ = resource;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.Relationship.resource)
}

// string relation = 2 [json_name = "relation", (.validate.rules) = {
inline void Relationship::clear_relation() {
  _impl_.relation_.ClearToEmpty();
}
inline const std::string& Relationship::relation() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.Relationship.relation)
  return _internal_relation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Relationship::set_relation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.relation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.Relationship.relation)
}
inline std::string* Relationship::mutable_relation() {
  std::string* _s = _internal_mutable_relation();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.Relationship.relation)
  return _s;
}
inline const std::string& Relationship::_internal_relation() const {
  return _impl_.relation_.Get();
}
inline void Relationship::_internal_set_relation(const std::string& value) {
  
  _impl_.relation_.Set(value, GetArenaForAllocation());
}
inline std::string* Relationship::_internal_mutable_relation() {
  
  return _impl_.relation_.Mutable(GetArenaForAllocation());
}
inline std::string* Relationship::release_relation() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.Relationship.relation)
  return _impl_.relation_.Release();
}
inline void Relationship::set_allocated_relation(std::string* relation) {
  if (relation != nullptr) {
    
  } else {
    
  }
  _impl_.relation_.SetAllocated(relation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.relation_.IsDefault()) {
    _impl_.relation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.Relationship.relation)
}

// .authzed.api.v1.SubjectReference subject = 3 [json_name = "subject", (.validate.rules) = {
inline bool Relationship::_internal_has_subject() const {
  return this != internal_default_instance() && _impl_.subject_ != nullptr;
}
inline bool Relationship::has_subject() const {
  return _internal_has_subject();
}
inline void Relationship::clear_subject() {
  if (GetArenaForAllocation() == nullptr && _impl_.subject_ != nullptr) {
    delete _impl_.subject_;
  }
  _impl_.subject_ = nullptr;
}
inline const ::authzed::api::v1::SubjectReference& Relationship::_internal_subject() const {
  const ::authzed::api::v1::SubjectReference* p = _impl_.subject_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::SubjectReference&>(
      ::authzed::api::v1::_SubjectReference_default_instance_);
}
inline const ::authzed::api::v1::SubjectReference& Relationship::subject() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.Relationship.subject)
  return _internal_subject();
}
inline void Relationship::unsafe_arena_set_allocated_subject(
    ::authzed::api::v1::SubjectReference* subject) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subject_);
  }
  _impl_.subject_ = subject;
  if (subject) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.Relationship.subject)
}
inline ::authzed::api::v1::SubjectReference* Relationship::release_subject() {
  
  ::authzed::api::v1::SubjectReference* temp = _impl_.subject_;
  _impl_.subject_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::SubjectReference* Relationship::unsafe_arena_release_subject() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.Relationship.subject)
  
  ::authzed::api::v1::SubjectReference* temp = _impl_.subject_;
  _impl_.subject_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::SubjectReference* Relationship::_internal_mutable_subject() {
  
  if (_impl_.subject_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::SubjectReference>(GetArenaForAllocation());
    _impl_.subject_ = p;
  }
  return _impl_.subject_;
}
inline ::authzed::api::v1::SubjectReference* Relationship::mutable_subject() {
  ::authzed::api::v1::SubjectReference* _msg = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.Relationship.subject)
  return _msg;
}
inline void Relationship::set_allocated_subject(::authzed::api::v1::SubjectReference* subject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.subject_;
  }
  if (subject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(subject);
    if (message_arena != submessage_arena) {
      subject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subject, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.subject_ = subject;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.Relationship.subject)
}

// .authzed.api.v1.ContextualizedCaveat optional_caveat = 4 [json_name = "optionalCaveat", (.validate.rules) = {
inline bool Relationship::_internal_has_optional_caveat() const {
  return this != internal_default_instance() && _impl_.optional_caveat_ != nullptr;
}
inline bool Relationship::has_optional_caveat() const {
  return _internal_has_optional_caveat();
}
inline void Relationship::clear_optional_caveat() {
  if (GetArenaForAllocation() == nullptr && _impl_.optional_caveat_ != nullptr) {
    delete _impl_.optional_caveat_;
  }
  _impl_.optional_caveat_ = nullptr;
}
inline const ::authzed::api::v1::ContextualizedCaveat& Relationship::_internal_optional_caveat() const {
  const ::authzed::api::v1::ContextualizedCaveat* p = _impl_.optional_caveat_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::ContextualizedCaveat&>(
      ::authzed::api::v1::_ContextualizedCaveat_default_instance_);
}
inline const ::authzed::api::v1::ContextualizedCaveat& Relationship::optional_caveat() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.Relationship.optional_caveat)
  return _internal_optional_caveat();
}
inline void Relationship::unsafe_arena_set_allocated_optional_caveat(
    ::authzed::api::v1::ContextualizedCaveat* optional_caveat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.optional_caveat_);
  }
  _impl_.optional_caveat_ = optional_caveat;
  if (optional_caveat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.Relationship.optional_caveat)
}
inline ::authzed::api::v1::ContextualizedCaveat* Relationship::release_optional_caveat() {
  
  ::authzed::api::v1::ContextualizedCaveat* temp = _impl_.optional_caveat_;
  _impl_.optional_caveat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::ContextualizedCaveat* Relationship::unsafe_arena_release_optional_caveat() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.Relationship.optional_caveat)
  
  ::authzed::api::v1::ContextualizedCaveat* temp = _impl_.optional_caveat_;
  _impl_.optional_caveat_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::ContextualizedCaveat* Relationship::_internal_mutable_optional_caveat() {
  
  if (_impl_.optional_caveat_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::ContextualizedCaveat>(GetArenaForAllocation());
    _impl_.optional_caveat_ = p;
  }
  return _impl_.optional_caveat_;
}
inline ::authzed::api::v1::ContextualizedCaveat* Relationship::mutable_optional_caveat() {
  ::authzed::api::v1::ContextualizedCaveat* _msg = _internal_mutable_optional_caveat();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.Relationship.optional_caveat)
  return _msg;
}
inline void Relationship::set_allocated_optional_caveat(::authzed::api::v1::ContextualizedCaveat* optional_caveat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.optional_caveat_;
  }
  if (optional_caveat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(optional_caveat);
    if (message_arena != submessage_arena) {
      optional_caveat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, optional_caveat, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.optional_caveat_ = optional_caveat;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.Relationship.optional_caveat)
}

// -------------------------------------------------------------------

// ContextualizedCaveat

// string caveat_name = 1 [json_name = "caveatName", (.validate.rules) = {
inline void ContextualizedCaveat::clear_caveat_name() {
  _impl_.caveat_name_.ClearToEmpty();
}
inline const std::string& ContextualizedCaveat::caveat_name() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.ContextualizedCaveat.caveat_name)
  return _internal_caveat_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContextualizedCaveat::set_caveat_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.caveat_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.ContextualizedCaveat.caveat_name)
}
inline std::string* ContextualizedCaveat::mutable_caveat_name() {
  std::string* _s = _internal_mutable_caveat_name();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.ContextualizedCaveat.caveat_name)
  return _s;
}
inline const std::string& ContextualizedCaveat::_internal_caveat_name() const {
  return _impl_.caveat_name_.Get();
}
inline void ContextualizedCaveat::_internal_set_caveat_name(const std::string& value) {
  
  _impl_.caveat_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ContextualizedCaveat::_internal_mutable_caveat_name() {
  
  return _impl_.caveat_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ContextualizedCaveat::release_caveat_name() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.ContextualizedCaveat.caveat_name)
  return _impl_.caveat_name_.Release();
}
inline void ContextualizedCaveat::set_allocated_caveat_name(std::string* caveat_name) {
  if (caveat_name != nullptr) {
    
  } else {
    
  }
  _impl_.caveat_name_.SetAllocated(caveat_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.caveat_name_.IsDefault()) {
    _impl_.caveat_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.ContextualizedCaveat.caveat_name)
}

// .google.protobuf.Struct context = 2 [json_name = "context", (.validate.rules) = {
inline bool ContextualizedCaveat::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool ContextualizedCaveat::has_context() const {
  return _internal_has_context();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ContextualizedCaveat::_internal_context() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ContextualizedCaveat::context() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.ContextualizedCaveat.context)
  return _internal_context();
}
inline void ContextualizedCaveat::unsafe_arena_set_allocated_context(
    ::PROTOBUF_NAMESPACE_ID::Struct* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.ContextualizedCaveat.context)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ContextualizedCaveat::release_context() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ContextualizedCaveat::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.ContextualizedCaveat.context)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ContextualizedCaveat::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ContextualizedCaveat::mutable_context() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.ContextualizedCaveat.context)
  return _msg;
}
inline void ContextualizedCaveat::set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(context));
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.ContextualizedCaveat.context)
}

// -------------------------------------------------------------------

// SubjectReference

// .authzed.api.v1.ObjectReference object = 1 [json_name = "object", (.validate.rules) = {
inline bool SubjectReference::_internal_has_object() const {
  return this != internal_default_instance() && _impl_.object_ != nullptr;
}
inline bool SubjectReference::has_object() const {
  return _internal_has_object();
}
inline void SubjectReference::clear_object() {
  if (GetArenaForAllocation() == nullptr && _impl_.object_ != nullptr) {
    delete _impl_.object_;
  }
  _impl_.object_ = nullptr;
}
inline const ::authzed::api::v1::ObjectReference& SubjectReference::_internal_object() const {
  const ::authzed::api::v1::ObjectReference* p = _impl_.object_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::ObjectReference&>(
      ::authzed::api::v1::_ObjectReference_default_instance_);
}
inline const ::authzed::api::v1::ObjectReference& SubjectReference::object() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.SubjectReference.object)
  return _internal_object();
}
inline void SubjectReference::unsafe_arena_set_allocated_object(
    ::authzed::api::v1::ObjectReference* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.object_);
  }
  _impl_.object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.SubjectReference.object)
}
inline ::authzed::api::v1::ObjectReference* SubjectReference::release_object() {
  
  ::authzed::api::v1::ObjectReference* temp = _impl_.object_;
  _impl_.object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::ObjectReference* SubjectReference::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.SubjectReference.object)
  
  ::authzed::api::v1::ObjectReference* temp = _impl_.object_;
  _impl_.object_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::ObjectReference* SubjectReference::_internal_mutable_object() {
  
  if (_impl_.object_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::ObjectReference>(GetArenaForAllocation());
    _impl_.object_ = p;
  }
  return _impl_.object_;
}
inline ::authzed::api::v1::ObjectReference* SubjectReference::mutable_object() {
  ::authzed::api::v1::ObjectReference* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.SubjectReference.object)
  return _msg;
}
inline void SubjectReference::set_allocated_object(::authzed::api::v1::ObjectReference* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.object_ = object;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.SubjectReference.object)
}

// string optional_relation = 2 [json_name = "optionalRelation", (.validate.rules) = {
inline void SubjectReference::clear_optional_relation() {
  _impl_.optional_relation_.ClearToEmpty();
}
inline const std::string& SubjectReference::optional_relation() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.SubjectReference.optional_relation)
  return _internal_optional_relation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubjectReference::set_optional_relation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.optional_relation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.SubjectReference.optional_relation)
}
inline std::string* SubjectReference::mutable_optional_relation() {
  std::string* _s = _internal_mutable_optional_relation();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.SubjectReference.optional_relation)
  return _s;
}
inline const std::string& SubjectReference::_internal_optional_relation() const {
  return _impl_.optional_relation_.Get();
}
inline void SubjectReference::_internal_set_optional_relation(const std::string& value) {
  
  _impl_.optional_relation_.Set(value, GetArenaForAllocation());
}
inline std::string* SubjectReference::_internal_mutable_optional_relation() {
  
  return _impl_.optional_relation_.Mutable(GetArenaForAllocation());
}
inline std::string* SubjectReference::release_optional_relation() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.SubjectReference.optional_relation)
  return _impl_.optional_relation_.Release();
}
inline void SubjectReference::set_allocated_optional_relation(std::string* optional_relation) {
  if (optional_relation != nullptr) {
    
  } else {
    
  }
  _impl_.optional_relation_.SetAllocated(optional_relation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.optional_relation_.IsDefault()) {
    _impl_.optional_relation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.SubjectReference.optional_relation)
}

// -------------------------------------------------------------------

// ObjectReference

// string object_type = 1 [json_name = "objectType", (.validate.rules) = {
inline void ObjectReference::clear_object_type() {
  _impl_.object_type_.ClearToEmpty();
}
inline const std::string& ObjectReference::object_type() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.ObjectReference.object_type)
  return _internal_object_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectReference::set_object_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.object_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.ObjectReference.object_type)
}
inline std::string* ObjectReference::mutable_object_type() {
  std::string* _s = _internal_mutable_object_type();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.ObjectReference.object_type)
  return _s;
}
inline const std::string& ObjectReference::_internal_object_type() const {
  return _impl_.object_type_.Get();
}
inline void ObjectReference::_internal_set_object_type(const std::string& value) {
  
  _impl_.object_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectReference::_internal_mutable_object_type() {
  
  return _impl_.object_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectReference::release_object_type() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.ObjectReference.object_type)
  return _impl_.object_type_.Release();
}
inline void ObjectReference::set_allocated_object_type(std::string* object_type) {
  if (object_type != nullptr) {
    
  } else {
    
  }
  _impl_.object_type_.SetAllocated(object_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.object_type_.IsDefault()) {
    _impl_.object_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.ObjectReference.object_type)
}

// string object_id = 2 [json_name = "objectId", (.validate.rules) = {
inline void ObjectReference::clear_object_id() {
  _impl_.object_id_.ClearToEmpty();
}
inline const std::string& ObjectReference::object_id() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.ObjectReference.object_id)
  return _internal_object_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectReference::set_object_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.object_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.ObjectReference.object_id)
}
inline std::string* ObjectReference::mutable_object_id() {
  std::string* _s = _internal_mutable_object_id();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.ObjectReference.object_id)
  return _s;
}
inline const std::string& ObjectReference::_internal_object_id() const {
  return _impl_.object_id_.Get();
}
inline void ObjectReference::_internal_set_object_id(const std::string& value) {
  
  _impl_.object_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectReference::_internal_mutable_object_id() {
  
  return _impl_.object_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectReference::release_object_id() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.ObjectReference.object_id)
  return _impl_.object_id_.Release();
}
inline void ObjectReference::set_allocated_object_id(std::string* object_id) {
  if (object_id != nullptr) {
    
  } else {
    
  }
  _impl_.object_id_.SetAllocated(object_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.object_id_.IsDefault()) {
    _impl_.object_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.ObjectReference.object_id)
}

// -------------------------------------------------------------------

// ZedToken

// string token = 1 [json_name = "token", (.validate.rules) = {
inline void ZedToken::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& ZedToken::token() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.ZedToken.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ZedToken::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.ZedToken.token)
}
inline std::string* ZedToken::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.ZedToken.token)
  return _s;
}
inline const std::string& ZedToken::_internal_token() const {
  return _impl_.token_.Get();
}
inline void ZedToken::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* ZedToken::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* ZedToken::release_token() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.ZedToken.token)
  return _impl_.token_.Release();
}
inline void ZedToken::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.ZedToken.token)
}

// -------------------------------------------------------------------

// RelationshipUpdate

// .authzed.api.v1.RelationshipUpdate.Operation operation = 1 [json_name = "operation", (.validate.rules) = {
inline void RelationshipUpdate::clear_operation() {
  _impl_.operation_ = 0;
}
inline ::authzed::api::v1::RelationshipUpdate_Operation RelationshipUpdate::_internal_operation() const {
  return static_cast< ::authzed::api::v1::RelationshipUpdate_Operation >(_impl_.operation_);
}
inline ::authzed::api::v1::RelationshipUpdate_Operation RelationshipUpdate::operation() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.RelationshipUpdate.operation)
  return _internal_operation();
}
inline void RelationshipUpdate::_internal_set_operation(::authzed::api::v1::RelationshipUpdate_Operation value) {
  
  _impl_.operation_ = value;
}
inline void RelationshipUpdate::set_operation(::authzed::api::v1::RelationshipUpdate_Operation value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:authzed.api.v1.RelationshipUpdate.operation)
}

// .authzed.api.v1.Relationship relationship = 2 [json_name = "relationship", (.validate.rules) = {
inline bool RelationshipUpdate::_internal_has_relationship() const {
  return this != internal_default_instance() && _impl_.relationship_ != nullptr;
}
inline bool RelationshipUpdate::has_relationship() const {
  return _internal_has_relationship();
}
inline void RelationshipUpdate::clear_relationship() {
  if (GetArenaForAllocation() == nullptr && _impl_.relationship_ != nullptr) {
    delete _impl_.relationship_;
  }
  _impl_.relationship_ = nullptr;
}
inline const ::authzed::api::v1::Relationship& RelationshipUpdate::_internal_relationship() const {
  const ::authzed::api::v1::Relationship* p = _impl_.relationship_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::Relationship&>(
      ::authzed::api::v1::_Relationship_default_instance_);
}
inline const ::authzed::api::v1::Relationship& RelationshipUpdate::relationship() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.RelationshipUpdate.relationship)
  return _internal_relationship();
}
inline void RelationshipUpdate::unsafe_arena_set_allocated_relationship(
    ::authzed::api::v1::Relationship* relationship) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.relationship_);
  }
  _impl_.relationship_ = relationship;
  if (relationship) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.RelationshipUpdate.relationship)
}
inline ::authzed::api::v1::Relationship* RelationshipUpdate::release_relationship() {
  
  ::authzed::api::v1::Relationship* temp = _impl_.relationship_;
  _impl_.relationship_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::Relationship* RelationshipUpdate::unsafe_arena_release_relationship() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.RelationshipUpdate.relationship)
  
  ::authzed::api::v1::Relationship* temp = _impl_.relationship_;
  _impl_.relationship_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::Relationship* RelationshipUpdate::_internal_mutable_relationship() {
  
  if (_impl_.relationship_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::Relationship>(GetArenaForAllocation());
    _impl_.relationship_ = p;
  }
  return _impl_.relationship_;
}
inline ::authzed::api::v1::Relationship* RelationshipUpdate::mutable_relationship() {
  ::authzed::api::v1::Relationship* _msg = _internal_mutable_relationship();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.RelationshipUpdate.relationship)
  return _msg;
}
inline void RelationshipUpdate::set_allocated_relationship(::authzed::api::v1::Relationship* relationship) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.relationship_;
  }
  if (relationship) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(relationship);
    if (message_arena != submessage_arena) {
      relationship = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, relationship, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.relationship_ = relationship;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.RelationshipUpdate.relationship)
}

// -------------------------------------------------------------------

// PermissionRelationshipTree

// .authzed.api.v1.AlgebraicSubjectSet intermediate = 1 [json_name = "intermediate"];
inline bool PermissionRelationshipTree::_internal_has_intermediate() const {
  return tree_type_case() == kIntermediate;
}
inline bool PermissionRelationshipTree::has_intermediate() const {
  return _internal_has_intermediate();
}
inline void PermissionRelationshipTree::set_has_intermediate() {
  _impl_._oneof_case_[0] = kIntermediate;
}
inline void PermissionRelationshipTree::clear_intermediate() {
  if (_internal_has_intermediate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.tree_type_.intermediate_;
    }
    clear_has_tree_type();
  }
}
inline ::authzed::api::v1::AlgebraicSubjectSet* PermissionRelationshipTree::release_intermediate() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.PermissionRelationshipTree.intermediate)
  if (_internal_has_intermediate()) {
    clear_has_tree_type();
    ::authzed::api::v1::AlgebraicSubjectSet* temp = _impl_.tree_type_.intermediate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.tree_type_.intermediate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::authzed::api::v1::AlgebraicSubjectSet& PermissionRelationshipTree::_internal_intermediate() const {
  return _internal_has_intermediate()
      ? *_impl_.tree_type_.intermediate_
      : reinterpret_cast< ::authzed::api::v1::AlgebraicSubjectSet&>(::authzed::api::v1::_AlgebraicSubjectSet_default_instance_);
}
inline const ::authzed::api::v1::AlgebraicSubjectSet& PermissionRelationshipTree::intermediate() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.PermissionRelationshipTree.intermediate)
  return _internal_intermediate();
}
inline ::authzed::api::v1::AlgebraicSubjectSet* PermissionRelationshipTree::unsafe_arena_release_intermediate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:authzed.api.v1.PermissionRelationshipTree.intermediate)
  if (_internal_has_intermediate()) {
    clear_has_tree_type();
    ::authzed::api::v1::AlgebraicSubjectSet* temp = _impl_.tree_type_.intermediate_;
    _impl_.tree_type_.intermediate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PermissionRelationshipTree::unsafe_arena_set_allocated_intermediate(::authzed::api::v1::AlgebraicSubjectSet* intermediate) {
  clear_tree_type();
  if (intermediate) {
    set_has_intermediate();
    _impl_.tree_type_.intermediate_ = intermediate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.PermissionRelationshipTree.intermediate)
}
inline ::authzed::api::v1::AlgebraicSubjectSet* PermissionRelationshipTree::_internal_mutable_intermediate() {
  if (!_internal_has_intermediate()) {
    clear_tree_type();
    set_has_intermediate();
    _impl_.tree_type_.intermediate_ = CreateMaybeMessage< ::authzed::api::v1::AlgebraicSubjectSet >(GetArenaForAllocation());
  }
  return _impl_.tree_type_.intermediate_;
}
inline ::authzed::api::v1::AlgebraicSubjectSet* PermissionRelationshipTree::mutable_intermediate() {
  ::authzed::api::v1::AlgebraicSubjectSet* _msg = _internal_mutable_intermediate();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.PermissionRelationshipTree.intermediate)
  return _msg;
}

// .authzed.api.v1.DirectSubjectSet leaf = 2 [json_name = "leaf"];
inline bool PermissionRelationshipTree::_internal_has_leaf() const {
  return tree_type_case() == kLeaf;
}
inline bool PermissionRelationshipTree::has_leaf() const {
  return _internal_has_leaf();
}
inline void PermissionRelationshipTree::set_has_leaf() {
  _impl_._oneof_case_[0] = kLeaf;
}
inline void PermissionRelationshipTree::clear_leaf() {
  if (_internal_has_leaf()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.tree_type_.leaf_;
    }
    clear_has_tree_type();
  }
}
inline ::authzed::api::v1::DirectSubjectSet* PermissionRelationshipTree::release_leaf() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.PermissionRelationshipTree.leaf)
  if (_internal_has_leaf()) {
    clear_has_tree_type();
    ::authzed::api::v1::DirectSubjectSet* temp = _impl_.tree_type_.leaf_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.tree_type_.leaf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::authzed::api::v1::DirectSubjectSet& PermissionRelationshipTree::_internal_leaf() const {
  return _internal_has_leaf()
      ? *_impl_.tree_type_.leaf_
      : reinterpret_cast< ::authzed::api::v1::DirectSubjectSet&>(::authzed::api::v1::_DirectSubjectSet_default_instance_);
}
inline const ::authzed::api::v1::DirectSubjectSet& PermissionRelationshipTree::leaf() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.PermissionRelationshipTree.leaf)
  return _internal_leaf();
}
inline ::authzed::api::v1::DirectSubjectSet* PermissionRelationshipTree::unsafe_arena_release_leaf() {
  // @@protoc_insertion_point(field_unsafe_arena_release:authzed.api.v1.PermissionRelationshipTree.leaf)
  if (_internal_has_leaf()) {
    clear_has_tree_type();
    ::authzed::api::v1::DirectSubjectSet* temp = _impl_.tree_type_.leaf_;
    _impl_.tree_type_.leaf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PermissionRelationshipTree::unsafe_arena_set_allocated_leaf(::authzed::api::v1::DirectSubjectSet* leaf) {
  clear_tree_type();
  if (leaf) {
    set_has_leaf();
    _impl_.tree_type_.leaf_ = leaf;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.PermissionRelationshipTree.leaf)
}
inline ::authzed::api::v1::DirectSubjectSet* PermissionRelationshipTree::_internal_mutable_leaf() {
  if (!_internal_has_leaf()) {
    clear_tree_type();
    set_has_leaf();
    _impl_.tree_type_.leaf_ = CreateMaybeMessage< ::authzed::api::v1::DirectSubjectSet >(GetArenaForAllocation());
  }
  return _impl_.tree_type_.leaf_;
}
inline ::authzed::api::v1::DirectSubjectSet* PermissionRelationshipTree::mutable_leaf() {
  ::authzed::api::v1::DirectSubjectSet* _msg = _internal_mutable_leaf();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.PermissionRelationshipTree.leaf)
  return _msg;
}

// .authzed.api.v1.ObjectReference expanded_object = 3 [json_name = "expandedObject"];
inline bool PermissionRelationshipTree::_internal_has_expanded_object() const {
  return this != internal_default_instance() && _impl_.expanded_object_ != nullptr;
}
inline bool PermissionRelationshipTree::has_expanded_object() const {
  return _internal_has_expanded_object();
}
inline void PermissionRelationshipTree::clear_expanded_object() {
  if (GetArenaForAllocation() == nullptr && _impl_.expanded_object_ != nullptr) {
    delete _impl_.expanded_object_;
  }
  _impl_.expanded_object_ = nullptr;
}
inline const ::authzed::api::v1::ObjectReference& PermissionRelationshipTree::_internal_expanded_object() const {
  const ::authzed::api::v1::ObjectReference* p = _impl_.expanded_object_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::ObjectReference&>(
      ::authzed::api::v1::_ObjectReference_default_instance_);
}
inline const ::authzed::api::v1::ObjectReference& PermissionRelationshipTree::expanded_object() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.PermissionRelationshipTree.expanded_object)
  return _internal_expanded_object();
}
inline void PermissionRelationshipTree::unsafe_arena_set_allocated_expanded_object(
    ::authzed::api::v1::ObjectReference* expanded_object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expanded_object_);
  }
  _impl_.expanded_object_ = expanded_object;
  if (expanded_object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.PermissionRelationshipTree.expanded_object)
}
inline ::authzed::api::v1::ObjectReference* PermissionRelationshipTree::release_expanded_object() {
  
  ::authzed::api::v1::ObjectReference* temp = _impl_.expanded_object_;
  _impl_.expanded_object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::ObjectReference* PermissionRelationshipTree::unsafe_arena_release_expanded_object() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.PermissionRelationshipTree.expanded_object)
  
  ::authzed::api::v1::ObjectReference* temp = _impl_.expanded_object_;
  _impl_.expanded_object_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::ObjectReference* PermissionRelationshipTree::_internal_mutable_expanded_object() {
  
  if (_impl_.expanded_object_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::ObjectReference>(GetArenaForAllocation());
    _impl_.expanded_object_ = p;
  }
  return _impl_.expanded_object_;
}
inline ::authzed::api::v1::ObjectReference* PermissionRelationshipTree::mutable_expanded_object() {
  ::authzed::api::v1::ObjectReference* _msg = _internal_mutable_expanded_object();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.PermissionRelationshipTree.expanded_object)
  return _msg;
}
inline void PermissionRelationshipTree::set_allocated_expanded_object(::authzed::api::v1::ObjectReference* expanded_object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.expanded_object_;
  }
  if (expanded_object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(expanded_object);
    if (message_arena != submessage_arena) {
      expanded_object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expanded_object, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.expanded_object_ = expanded_object;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.PermissionRelationshipTree.expanded_object)
}

// string expanded_relation = 4 [json_name = "expandedRelation"];
inline void PermissionRelationshipTree::clear_expanded_relation() {
  _impl_.expanded_relation_.ClearToEmpty();
}
inline const std::string& PermissionRelationshipTree::expanded_relation() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.PermissionRelationshipTree.expanded_relation)
  return _internal_expanded_relation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PermissionRelationshipTree::set_expanded_relation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.expanded_relation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.PermissionRelationshipTree.expanded_relation)
}
inline std::string* PermissionRelationshipTree::mutable_expanded_relation() {
  std::string* _s = _internal_mutable_expanded_relation();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.PermissionRelationshipTree.expanded_relation)
  return _s;
}
inline const std::string& PermissionRelationshipTree::_internal_expanded_relation() const {
  return _impl_.expanded_relation_.Get();
}
inline void PermissionRelationshipTree::_internal_set_expanded_relation(const std::string& value) {
  
  _impl_.expanded_relation_.Set(value, GetArenaForAllocation());
}
inline std::string* PermissionRelationshipTree::_internal_mutable_expanded_relation() {
  
  return _impl_.expanded_relation_.Mutable(GetArenaForAllocation());
}
inline std::string* PermissionRelationshipTree::release_expanded_relation() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.PermissionRelationshipTree.expanded_relation)
  return _impl_.expanded_relation_.Release();
}
inline void PermissionRelationshipTree::set_allocated_expanded_relation(std::string* expanded_relation) {
  if (expanded_relation != nullptr) {
    
  } else {
    
  }
  _impl_.expanded_relation_.SetAllocated(expanded_relation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.expanded_relation_.IsDefault()) {
    _impl_.expanded_relation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.PermissionRelationshipTree.expanded_relation)
}

inline bool PermissionRelationshipTree::has_tree_type() const {
  return tree_type_case() != TREE_TYPE_NOT_SET;
}
inline void PermissionRelationshipTree::clear_has_tree_type() {
  _impl_._oneof_case_[0] = TREE_TYPE_NOT_SET;
}
inline PermissionRelationshipTree::TreeTypeCase PermissionRelationshipTree::tree_type_case() const {
  return PermissionRelationshipTree::TreeTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AlgebraicSubjectSet

// .authzed.api.v1.AlgebraicSubjectSet.Operation operation = 1 [json_name = "operation", (.validate.rules) = {
inline void AlgebraicSubjectSet::clear_operation() {
  _impl_.operation_ = 0;
}
inline ::authzed::api::v1::AlgebraicSubjectSet_Operation AlgebraicSubjectSet::_internal_operation() const {
  return static_cast< ::authzed::api::v1::AlgebraicSubjectSet_Operation >(_impl_.operation_);
}
inline ::authzed::api::v1::AlgebraicSubjectSet_Operation AlgebraicSubjectSet::operation() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.AlgebraicSubjectSet.operation)
  return _internal_operation();
}
inline void AlgebraicSubjectSet::_internal_set_operation(::authzed::api::v1::AlgebraicSubjectSet_Operation value) {
  
  _impl_.operation_ = value;
}
inline void AlgebraicSubjectSet::set_operation(::authzed::api::v1::AlgebraicSubjectSet_Operation value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:authzed.api.v1.AlgebraicSubjectSet.operation)
}

// repeated .authzed.api.v1.PermissionRelationshipTree children = 2 [json_name = "children", (.validate.rules) = {
inline int AlgebraicSubjectSet::_internal_children_size() const {
  return _impl_.children_.size();
}
inline int AlgebraicSubjectSet::children_size() const {
  return _internal_children_size();
}
inline void AlgebraicSubjectSet::clear_children() {
  _impl_.children_.Clear();
}
inline ::authzed::api::v1::PermissionRelationshipTree* AlgebraicSubjectSet::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.AlgebraicSubjectSet.children)
  return _impl_.children_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::PermissionRelationshipTree >*
AlgebraicSubjectSet::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:authzed.api.v1.AlgebraicSubjectSet.children)
  return &_impl_.children_;
}
inline const ::authzed::api::v1::PermissionRelationshipTree& AlgebraicSubjectSet::_internal_children(int index) const {
  return _impl_.children_.Get(index);
}
inline const ::authzed::api::v1::PermissionRelationshipTree& AlgebraicSubjectSet::children(int index) const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.AlgebraicSubjectSet.children)
  return _internal_children(index);
}
inline ::authzed::api::v1::PermissionRelationshipTree* AlgebraicSubjectSet::_internal_add_children() {
  return _impl_.children_.Add();
}
inline ::authzed::api::v1::PermissionRelationshipTree* AlgebraicSubjectSet::add_children() {
  ::authzed::api::v1::PermissionRelationshipTree* _add = _internal_add_children();
  // @@protoc_insertion_point(field_add:authzed.api.v1.AlgebraicSubjectSet.children)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::PermissionRelationshipTree >&
AlgebraicSubjectSet::children() const {
  // @@protoc_insertion_point(field_list:authzed.api.v1.AlgebraicSubjectSet.children)
  return _impl_.children_;
}

// -------------------------------------------------------------------

// DirectSubjectSet

// repeated .authzed.api.v1.SubjectReference subjects = 1 [json_name = "subjects"];
inline int DirectSubjectSet::_internal_subjects_size() const {
  return _impl_.subjects_.size();
}
inline int DirectSubjectSet::subjects_size() const {
  return _internal_subjects_size();
}
inline void DirectSubjectSet::clear_subjects() {
  _impl_.subjects_.Clear();
}
inline ::authzed::api::v1::SubjectReference* DirectSubjectSet::mutable_subjects(int index) {
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.DirectSubjectSet.subjects)
  return _impl_.subjects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::SubjectReference >*
DirectSubjectSet::mutable_subjects() {
  // @@protoc_insertion_point(field_mutable_list:authzed.api.v1.DirectSubjectSet.subjects)
  return &_impl_.subjects_;
}
inline const ::authzed::api::v1::SubjectReference& DirectSubjectSet::_internal_subjects(int index) const {
  return _impl_.subjects_.Get(index);
}
inline const ::authzed::api::v1::SubjectReference& DirectSubjectSet::subjects(int index) const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.DirectSubjectSet.subjects)
  return _internal_subjects(index);
}
inline ::authzed::api::v1::SubjectReference* DirectSubjectSet::_internal_add_subjects() {
  return _impl_.subjects_.Add();
}
inline ::authzed::api::v1::SubjectReference* DirectSubjectSet::add_subjects() {
  ::authzed::api::v1::SubjectReference* _add = _internal_add_subjects();
  // @@protoc_insertion_point(field_add:authzed.api.v1.DirectSubjectSet.subjects)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::SubjectReference >&
DirectSubjectSet::subjects() const {
  // @@protoc_insertion_point(field_list:authzed.api.v1.DirectSubjectSet.subjects)
  return _impl_.subjects_;
}

// -------------------------------------------------------------------

// PartialCaveatInfo

// repeated string missing_required_context = 1 [json_name = "missingRequiredContext", (.validate.rules) = {
inline int PartialCaveatInfo::_internal_missing_required_context_size() const {
  return _impl_.missing_required_context_.size();
}
inline int PartialCaveatInfo::missing_required_context_size() const {
  return _internal_missing_required_context_size();
}
inline void PartialCaveatInfo::clear_missing_required_context() {
  _impl_.missing_required_context_.Clear();
}
inline std::string* PartialCaveatInfo::add_missing_required_context() {
  std::string* _s = _internal_add_missing_required_context();
  // @@protoc_insertion_point(field_add_mutable:authzed.api.v1.PartialCaveatInfo.missing_required_context)
  return _s;
}
inline const std::string& PartialCaveatInfo::_internal_missing_required_context(int index) const {
  return _impl_.missing_required_context_.Get(index);
}
inline const std::string& PartialCaveatInfo::missing_required_context(int index) const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.PartialCaveatInfo.missing_required_context)
  return _internal_missing_required_context(index);
}
inline std::string* PartialCaveatInfo::mutable_missing_required_context(int index) {
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.PartialCaveatInfo.missing_required_context)
  return _impl_.missing_required_context_.Mutable(index);
}
inline void PartialCaveatInfo::set_missing_required_context(int index, const std::string& value) {
  _impl_.missing_required_context_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:authzed.api.v1.PartialCaveatInfo.missing_required_context)
}
inline void PartialCaveatInfo::set_missing_required_context(int index, std::string&& value) {
  _impl_.missing_required_context_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:authzed.api.v1.PartialCaveatInfo.missing_required_context)
}
inline void PartialCaveatInfo::set_missing_required_context(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.missing_required_context_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:authzed.api.v1.PartialCaveatInfo.missing_required_context)
}
inline void PartialCaveatInfo::set_missing_required_context(int index, const char* value, size_t size) {
  _impl_.missing_required_context_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:authzed.api.v1.PartialCaveatInfo.missing_required_context)
}
inline std::string* PartialCaveatInfo::_internal_add_missing_required_context() {
  return _impl_.missing_required_context_.Add();
}
inline void PartialCaveatInfo::add_missing_required_context(const std::string& value) {
  _impl_.missing_required_context_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:authzed.api.v1.PartialCaveatInfo.missing_required_context)
}
inline void PartialCaveatInfo::add_missing_required_context(std::string&& value) {
  _impl_.missing_required_context_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:authzed.api.v1.PartialCaveatInfo.missing_required_context)
}
inline void PartialCaveatInfo::add_missing_required_context(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.missing_required_context_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:authzed.api.v1.PartialCaveatInfo.missing_required_context)
}
inline void PartialCaveatInfo::add_missing_required_context(const char* value, size_t size) {
  _impl_.missing_required_context_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:authzed.api.v1.PartialCaveatInfo.missing_required_context)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PartialCaveatInfo::missing_required_context() const {
  // @@protoc_insertion_point(field_list:authzed.api.v1.PartialCaveatInfo.missing_required_context)
  return _impl_.missing_required_context_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PartialCaveatInfo::mutable_missing_required_context() {
  // @@protoc_insertion_point(field_mutable_list:authzed.api.v1.PartialCaveatInfo.missing_required_context)
  return &_impl_.missing_required_context_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace api
}  // namespace authzed

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::authzed::api::v1::RelationshipUpdate_Operation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::authzed::api::v1::RelationshipUpdate_Operation>() {
  return ::authzed::api::v1::RelationshipUpdate_Operation_descriptor();
}
template <> struct is_proto_enum< ::authzed::api::v1::AlgebraicSubjectSet_Operation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::authzed::api::v1::AlgebraicSubjectSet_Operation>() {
  return ::authzed::api::v1::AlgebraicSubjectSet_Operation_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_authzed_2fapi_2fv1_2fcore_2eproto
