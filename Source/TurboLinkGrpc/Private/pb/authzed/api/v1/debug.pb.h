#ifdef check
#undef check
#if defined(_MSC_VER)
  #pragma warning (disable:4946) // reinterpret_cast used between related classes: 'class1' and 'class2'
#endif
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: authzed/api/v1/debug.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_authzed_2fapi_2fv1_2fdebug_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_authzed_2fapi_2fv1_2fdebug_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "pb/authzed/api/v1/core.pb.h"
#include "pb/validate/validate.pb.h"
#include <google/protobuf/struct.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_authzed_2fapi_2fv1_2fdebug_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_authzed_2fapi_2fv1_2fdebug_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_authzed_2fapi_2fv1_2fdebug_2eproto;
namespace authzed {
namespace api {
namespace v1 {
class CaveatEvalInfo;
struct CaveatEvalInfoDefaultTypeInternal;
extern CaveatEvalInfoDefaultTypeInternal _CaveatEvalInfo_default_instance_;
class CheckDebugTrace;
struct CheckDebugTraceDefaultTypeInternal;
extern CheckDebugTraceDefaultTypeInternal _CheckDebugTrace_default_instance_;
class CheckDebugTrace_SubProblems;
struct CheckDebugTrace_SubProblemsDefaultTypeInternal;
extern CheckDebugTrace_SubProblemsDefaultTypeInternal _CheckDebugTrace_SubProblems_default_instance_;
class DebugInformation;
struct DebugInformationDefaultTypeInternal;
extern DebugInformationDefaultTypeInternal _DebugInformation_default_instance_;
}  // namespace v1
}  // namespace api
}  // namespace authzed
PROTOBUF_NAMESPACE_OPEN
template<> ::authzed::api::v1::CaveatEvalInfo* Arena::CreateMaybeMessage<::authzed::api::v1::CaveatEvalInfo>(Arena*);
template<> ::authzed::api::v1::CheckDebugTrace* Arena::CreateMaybeMessage<::authzed::api::v1::CheckDebugTrace>(Arena*);
template<> ::authzed::api::v1::CheckDebugTrace_SubProblems* Arena::CreateMaybeMessage<::authzed::api::v1::CheckDebugTrace_SubProblems>(Arena*);
template<> ::authzed::api::v1::DebugInformation* Arena::CreateMaybeMessage<::authzed::api::v1::DebugInformation>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace authzed {
namespace api {
namespace v1 {

enum CheckDebugTrace_PermissionType : int {
  CheckDebugTrace_PermissionType_PERMISSION_TYPE_UNSPECIFIED = 0,
  CheckDebugTrace_PermissionType_PERMISSION_TYPE_RELATION = 1,
  CheckDebugTrace_PermissionType_PERMISSION_TYPE_PERMISSION = 2,
  CheckDebugTrace_PermissionType_CheckDebugTrace_PermissionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CheckDebugTrace_PermissionType_CheckDebugTrace_PermissionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CheckDebugTrace_PermissionType_IsValid(int value);
constexpr CheckDebugTrace_PermissionType CheckDebugTrace_PermissionType_PermissionType_MIN = CheckDebugTrace_PermissionType_PERMISSION_TYPE_UNSPECIFIED;
constexpr CheckDebugTrace_PermissionType CheckDebugTrace_PermissionType_PermissionType_MAX = CheckDebugTrace_PermissionType_PERMISSION_TYPE_PERMISSION;
constexpr int CheckDebugTrace_PermissionType_PermissionType_ARRAYSIZE = CheckDebugTrace_PermissionType_PermissionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CheckDebugTrace_PermissionType_descriptor();
template<typename T>
inline const std::string& CheckDebugTrace_PermissionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CheckDebugTrace_PermissionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CheckDebugTrace_PermissionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CheckDebugTrace_PermissionType_descriptor(), enum_t_value);
}
inline bool CheckDebugTrace_PermissionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CheckDebugTrace_PermissionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CheckDebugTrace_PermissionType>(
    CheckDebugTrace_PermissionType_descriptor(), name, value);
}
enum CheckDebugTrace_Permissionship : int {
  CheckDebugTrace_Permissionship_PERMISSIONSHIP_UNSPECIFIED = 0,
  CheckDebugTrace_Permissionship_PERMISSIONSHIP_NO_PERMISSION = 1,
  CheckDebugTrace_Permissionship_PERMISSIONSHIP_HAS_PERMISSION = 2,
  CheckDebugTrace_Permissionship_PERMISSIONSHIP_CONDITIONAL_PERMISSION = 3,
  CheckDebugTrace_Permissionship_CheckDebugTrace_Permissionship_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CheckDebugTrace_Permissionship_CheckDebugTrace_Permissionship_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CheckDebugTrace_Permissionship_IsValid(int value);
constexpr CheckDebugTrace_Permissionship CheckDebugTrace_Permissionship_Permissionship_MIN = CheckDebugTrace_Permissionship_PERMISSIONSHIP_UNSPECIFIED;
constexpr CheckDebugTrace_Permissionship CheckDebugTrace_Permissionship_Permissionship_MAX = CheckDebugTrace_Permissionship_PERMISSIONSHIP_CONDITIONAL_PERMISSION;
constexpr int CheckDebugTrace_Permissionship_Permissionship_ARRAYSIZE = CheckDebugTrace_Permissionship_Permissionship_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CheckDebugTrace_Permissionship_descriptor();
template<typename T>
inline const std::string& CheckDebugTrace_Permissionship_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CheckDebugTrace_Permissionship>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CheckDebugTrace_Permissionship_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CheckDebugTrace_Permissionship_descriptor(), enum_t_value);
}
inline bool CheckDebugTrace_Permissionship_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CheckDebugTrace_Permissionship* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CheckDebugTrace_Permissionship>(
    CheckDebugTrace_Permissionship_descriptor(), name, value);
}
enum CaveatEvalInfo_Result : int {
  CaveatEvalInfo_Result_RESULT_UNSPECIFIED = 0,
  CaveatEvalInfo_Result_RESULT_UNEVALUATED = 1,
  CaveatEvalInfo_Result_RESULT_FALSE = 2,
  CaveatEvalInfo_Result_RESULT_TRUE = 3,
  CaveatEvalInfo_Result_RESULT_MISSING_SOME_CONTEXT = 4,
  CaveatEvalInfo_Result_CaveatEvalInfo_Result_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CaveatEvalInfo_Result_CaveatEvalInfo_Result_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CaveatEvalInfo_Result_IsValid(int value);
constexpr CaveatEvalInfo_Result CaveatEvalInfo_Result_Result_MIN = CaveatEvalInfo_Result_RESULT_UNSPECIFIED;
constexpr CaveatEvalInfo_Result CaveatEvalInfo_Result_Result_MAX = CaveatEvalInfo_Result_RESULT_MISSING_SOME_CONTEXT;
constexpr int CaveatEvalInfo_Result_Result_ARRAYSIZE = CaveatEvalInfo_Result_Result_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CaveatEvalInfo_Result_descriptor();
template<typename T>
inline const std::string& CaveatEvalInfo_Result_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CaveatEvalInfo_Result>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CaveatEvalInfo_Result_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CaveatEvalInfo_Result_descriptor(), enum_t_value);
}
inline bool CaveatEvalInfo_Result_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CaveatEvalInfo_Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CaveatEvalInfo_Result>(
    CaveatEvalInfo_Result_descriptor(), name, value);
}
// ===================================================================

class DebugInformation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.DebugInformation) */ {
 public:
  inline DebugInformation() : DebugInformation(nullptr) {}
  ~DebugInformation() override;
  explicit PROTOBUF_CONSTEXPR DebugInformation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DebugInformation(const DebugInformation& from);
  DebugInformation(DebugInformation&& from) noexcept
    : DebugInformation() {
    *this = ::std::move(from);
  }

  inline DebugInformation& operator=(const DebugInformation& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugInformation& operator=(DebugInformation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebugInformation& default_instance() {
    return *internal_default_instance();
  }
  static inline const DebugInformation* internal_default_instance() {
    return reinterpret_cast<const DebugInformation*>(
               &_DebugInformation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DebugInformation& a, DebugInformation& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugInformation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugInformation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebugInformation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DebugInformation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DebugInformation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DebugInformation& from) {
    DebugInformation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugInformation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.DebugInformation";
  }
  protected:
  explicit DebugInformation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaUsedFieldNumber = 2,
    kCheckFieldNumber = 1,
  };
  // string schema_used = 2 [json_name = "schemaUsed"];
  void clear_schema_used();
  const std::string& schema_used() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_used(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_used();
  PROTOBUF_NODISCARD std::string* release_schema_used();
  void set_allocated_schema_used(std::string* schema_used);
  private:
  const std::string& _internal_schema_used() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_used(const std::string& value);
  std::string* _internal_mutable_schema_used();
  public:

  // .authzed.api.v1.CheckDebugTrace check = 1 [json_name = "check"];
  bool has_check() const;
  private:
  bool _internal_has_check() const;
  public:
  void clear_check();
  const ::authzed::api::v1::CheckDebugTrace& check() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::CheckDebugTrace* release_check();
  ::authzed::api::v1::CheckDebugTrace* mutable_check();
  void set_allocated_check(::authzed::api::v1::CheckDebugTrace* check);
  private:
  const ::authzed::api::v1::CheckDebugTrace& _internal_check() const;
  ::authzed::api::v1::CheckDebugTrace* _internal_mutable_check();
  public:
  void unsafe_arena_set_allocated_check(
      ::authzed::api::v1::CheckDebugTrace* check);
  ::authzed::api::v1::CheckDebugTrace* unsafe_arena_release_check();

  // @@protoc_insertion_point(class_scope:authzed.api.v1.DebugInformation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_used_;
    ::authzed::api::v1::CheckDebugTrace* check_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class CheckDebugTrace_SubProblems final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.CheckDebugTrace.SubProblems) */ {
 public:
  inline CheckDebugTrace_SubProblems() : CheckDebugTrace_SubProblems(nullptr) {}
  ~CheckDebugTrace_SubProblems() override;
  explicit PROTOBUF_CONSTEXPR CheckDebugTrace_SubProblems(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckDebugTrace_SubProblems(const CheckDebugTrace_SubProblems& from);
  CheckDebugTrace_SubProblems(CheckDebugTrace_SubProblems&& from) noexcept
    : CheckDebugTrace_SubProblems() {
    *this = ::std::move(from);
  }

  inline CheckDebugTrace_SubProblems& operator=(const CheckDebugTrace_SubProblems& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckDebugTrace_SubProblems& operator=(CheckDebugTrace_SubProblems&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckDebugTrace_SubProblems& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckDebugTrace_SubProblems* internal_default_instance() {
    return reinterpret_cast<const CheckDebugTrace_SubProblems*>(
               &_CheckDebugTrace_SubProblems_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CheckDebugTrace_SubProblems& a, CheckDebugTrace_SubProblems& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckDebugTrace_SubProblems* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckDebugTrace_SubProblems* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckDebugTrace_SubProblems* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckDebugTrace_SubProblems>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckDebugTrace_SubProblems& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CheckDebugTrace_SubProblems& from) {
    CheckDebugTrace_SubProblems::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckDebugTrace_SubProblems* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.CheckDebugTrace.SubProblems";
  }
  protected:
  explicit CheckDebugTrace_SubProblems(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTracesFieldNumber = 1,
  };
  // repeated .authzed.api.v1.CheckDebugTrace traces = 1 [json_name = "traces"];
  int traces_size() const;
  private:
  int _internal_traces_size() const;
  public:
  void clear_traces();
  ::authzed::api::v1::CheckDebugTrace* mutable_traces(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::CheckDebugTrace >*
      mutable_traces();
  private:
  const ::authzed::api::v1::CheckDebugTrace& _internal_traces(int index) const;
  ::authzed::api::v1::CheckDebugTrace* _internal_add_traces();
  public:
  const ::authzed::api::v1::CheckDebugTrace& traces(int index) const;
  ::authzed::api::v1::CheckDebugTrace* add_traces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::CheckDebugTrace >&
      traces() const;

  // @@protoc_insertion_point(class_scope:authzed.api.v1.CheckDebugTrace.SubProblems)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::CheckDebugTrace > traces_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class CheckDebugTrace final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.CheckDebugTrace) */ {
 public:
  inline CheckDebugTrace() : CheckDebugTrace(nullptr) {}
  ~CheckDebugTrace() override;
  explicit PROTOBUF_CONSTEXPR CheckDebugTrace(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckDebugTrace(const CheckDebugTrace& from);
  CheckDebugTrace(CheckDebugTrace&& from) noexcept
    : CheckDebugTrace() {
    *this = ::std::move(from);
  }

  inline CheckDebugTrace& operator=(const CheckDebugTrace& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckDebugTrace& operator=(CheckDebugTrace&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckDebugTrace& default_instance() {
    return *internal_default_instance();
  }
  enum ResolutionCase {
    kWasCachedResult = 6,
    kSubProblems = 7,
    RESOLUTION_NOT_SET = 0,
  };

  static inline const CheckDebugTrace* internal_default_instance() {
    return reinterpret_cast<const CheckDebugTrace*>(
               &_CheckDebugTrace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CheckDebugTrace& a, CheckDebugTrace& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckDebugTrace* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckDebugTrace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckDebugTrace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckDebugTrace>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckDebugTrace& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CheckDebugTrace& from) {
    CheckDebugTrace::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckDebugTrace* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.CheckDebugTrace";
  }
  protected:
  explicit CheckDebugTrace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CheckDebugTrace_SubProblems SubProblems;

  typedef CheckDebugTrace_PermissionType PermissionType;
  static constexpr PermissionType PERMISSION_TYPE_UNSPECIFIED =
    CheckDebugTrace_PermissionType_PERMISSION_TYPE_UNSPECIFIED;
  static constexpr PermissionType PERMISSION_TYPE_RELATION =
    CheckDebugTrace_PermissionType_PERMISSION_TYPE_RELATION;
  static constexpr PermissionType PERMISSION_TYPE_PERMISSION =
    CheckDebugTrace_PermissionType_PERMISSION_TYPE_PERMISSION;
  static inline bool PermissionType_IsValid(int value) {
    return CheckDebugTrace_PermissionType_IsValid(value);
  }
  static constexpr PermissionType PermissionType_MIN =
    CheckDebugTrace_PermissionType_PermissionType_MIN;
  static constexpr PermissionType PermissionType_MAX =
    CheckDebugTrace_PermissionType_PermissionType_MAX;
  static constexpr int PermissionType_ARRAYSIZE =
    CheckDebugTrace_PermissionType_PermissionType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PermissionType_descriptor() {
    return CheckDebugTrace_PermissionType_descriptor();
  }
  template<typename T>
  static inline const std::string& PermissionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PermissionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PermissionType_Name.");
    return CheckDebugTrace_PermissionType_Name(enum_t_value);
  }
  static inline bool PermissionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PermissionType* value) {
    return CheckDebugTrace_PermissionType_Parse(name, value);
  }

  typedef CheckDebugTrace_Permissionship Permissionship;
  static constexpr Permissionship PERMISSIONSHIP_UNSPECIFIED =
    CheckDebugTrace_Permissionship_PERMISSIONSHIP_UNSPECIFIED;
  static constexpr Permissionship PERMISSIONSHIP_NO_PERMISSION =
    CheckDebugTrace_Permissionship_PERMISSIONSHIP_NO_PERMISSION;
  static constexpr Permissionship PERMISSIONSHIP_HAS_PERMISSION =
    CheckDebugTrace_Permissionship_PERMISSIONSHIP_HAS_PERMISSION;
  static constexpr Permissionship PERMISSIONSHIP_CONDITIONAL_PERMISSION =
    CheckDebugTrace_Permissionship_PERMISSIONSHIP_CONDITIONAL_PERMISSION;
  static inline bool Permissionship_IsValid(int value) {
    return CheckDebugTrace_Permissionship_IsValid(value);
  }
  static constexpr Permissionship Permissionship_MIN =
    CheckDebugTrace_Permissionship_Permissionship_MIN;
  static constexpr Permissionship Permissionship_MAX =
    CheckDebugTrace_Permissionship_Permissionship_MAX;
  static constexpr int Permissionship_ARRAYSIZE =
    CheckDebugTrace_Permissionship_Permissionship_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Permissionship_descriptor() {
    return CheckDebugTrace_Permissionship_descriptor();
  }
  template<typename T>
  static inline const std::string& Permissionship_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Permissionship>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Permissionship_Name.");
    return CheckDebugTrace_Permissionship_Name(enum_t_value);
  }
  static inline bool Permissionship_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Permissionship* value) {
    return CheckDebugTrace_Permissionship_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionFieldNumber = 2,
    kResourceFieldNumber = 1,
    kSubjectFieldNumber = 4,
    kCaveatEvaluationInfoFieldNumber = 8,
    kPermissionTypeFieldNumber = 3,
    kResultFieldNumber = 5,
    kWasCachedResultFieldNumber = 6,
    kSubProblemsFieldNumber = 7,
  };
  // string permission = 2 [json_name = "permission"];
  void clear_permission();
  const std::string& permission() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_permission(ArgT0&& arg0, ArgT... args);
  std::string* mutable_permission();
  PROTOBUF_NODISCARD std::string* release_permission();
  void set_allocated_permission(std::string* permission);
  private:
  const std::string& _internal_permission() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_permission(const std::string& value);
  std::string* _internal_mutable_permission();
  public:

  // .authzed.api.v1.ObjectReference resource = 1 [json_name = "resource", (.validate.rules) = {
  bool has_resource() const;
  private:
  bool _internal_has_resource() const;
  public:
  void clear_resource();
  const ::authzed::api::v1::ObjectReference& resource() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::ObjectReference* release_resource();
  ::authzed::api::v1::ObjectReference* mutable_resource();
  void set_allocated_resource(::authzed::api::v1::ObjectReference* resource);
  private:
  const ::authzed::api::v1::ObjectReference& _internal_resource() const;
  ::authzed::api::v1::ObjectReference* _internal_mutable_resource();
  public:
  void unsafe_arena_set_allocated_resource(
      ::authzed::api::v1::ObjectReference* resource);
  ::authzed::api::v1::ObjectReference* unsafe_arena_release_resource();

  // .authzed.api.v1.SubjectReference subject = 4 [json_name = "subject", (.validate.rules) = {
  bool has_subject() const;
  private:
  bool _internal_has_subject() const;
  public:
  void clear_subject();
  const ::authzed::api::v1::SubjectReference& subject() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::SubjectReference* release_subject();
  ::authzed::api::v1::SubjectReference* mutable_subject();
  void set_allocated_subject(::authzed::api::v1::SubjectReference* subject);
  private:
  const ::authzed::api::v1::SubjectReference& _internal_subject() const;
  ::authzed::api::v1::SubjectReference* _internal_mutable_subject();
  public:
  void unsafe_arena_set_allocated_subject(
      ::authzed::api::v1::SubjectReference* subject);
  ::authzed::api::v1::SubjectReference* unsafe_arena_release_subject();

  // .authzed.api.v1.CaveatEvalInfo caveat_evaluation_info = 8 [json_name = "caveatEvaluationInfo"];
  bool has_caveat_evaluation_info() const;
  private:
  bool _internal_has_caveat_evaluation_info() const;
  public:
  void clear_caveat_evaluation_info();
  const ::authzed::api::v1::CaveatEvalInfo& caveat_evaluation_info() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::CaveatEvalInfo* release_caveat_evaluation_info();
  ::authzed::api::v1::CaveatEvalInfo* mutable_caveat_evaluation_info();
  void set_allocated_caveat_evaluation_info(::authzed::api::v1::CaveatEvalInfo* caveat_evaluation_info);
  private:
  const ::authzed::api::v1::CaveatEvalInfo& _internal_caveat_evaluation_info() const;
  ::authzed::api::v1::CaveatEvalInfo* _internal_mutable_caveat_evaluation_info();
  public:
  void unsafe_arena_set_allocated_caveat_evaluation_info(
      ::authzed::api::v1::CaveatEvalInfo* caveat_evaluation_info);
  ::authzed::api::v1::CaveatEvalInfo* unsafe_arena_release_caveat_evaluation_info();

  // .authzed.api.v1.CheckDebugTrace.PermissionType permission_type = 3 [json_name = "permissionType", (.validate.rules) = {
  void clear_permission_type();
  ::authzed::api::v1::CheckDebugTrace_PermissionType permission_type() const;
  void set_permission_type(::authzed::api::v1::CheckDebugTrace_PermissionType value);
  private:
  ::authzed::api::v1::CheckDebugTrace_PermissionType _internal_permission_type() const;
  void _internal_set_permission_type(::authzed::api::v1::CheckDebugTrace_PermissionType value);
  public:

  // .authzed.api.v1.CheckDebugTrace.Permissionship result = 5 [json_name = "result", (.validate.rules) = {
  void clear_result();
  ::authzed::api::v1::CheckDebugTrace_Permissionship result() const;
  void set_result(::authzed::api::v1::CheckDebugTrace_Permissionship value);
  private:
  ::authzed::api::v1::CheckDebugTrace_Permissionship _internal_result() const;
  void _internal_set_result(::authzed::api::v1::CheckDebugTrace_Permissionship value);
  public:

  // bool was_cached_result = 6 [json_name = "wasCachedResult"];
  bool has_was_cached_result() const;
  private:
  bool _internal_has_was_cached_result() const;
  public:
  void clear_was_cached_result();
  bool was_cached_result() const;
  void set_was_cached_result(bool value);
  private:
  bool _internal_was_cached_result() const;
  void _internal_set_was_cached_result(bool value);
  public:

  // .authzed.api.v1.CheckDebugTrace.SubProblems sub_problems = 7 [json_name = "subProblems"];
  bool has_sub_problems() const;
  private:
  bool _internal_has_sub_problems() const;
  public:
  void clear_sub_problems();
  const ::authzed::api::v1::CheckDebugTrace_SubProblems& sub_problems() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::CheckDebugTrace_SubProblems* release_sub_problems();
  ::authzed::api::v1::CheckDebugTrace_SubProblems* mutable_sub_problems();
  void set_allocated_sub_problems(::authzed::api::v1::CheckDebugTrace_SubProblems* sub_problems);
  private:
  const ::authzed::api::v1::CheckDebugTrace_SubProblems& _internal_sub_problems() const;
  ::authzed::api::v1::CheckDebugTrace_SubProblems* _internal_mutable_sub_problems();
  public:
  void unsafe_arena_set_allocated_sub_problems(
      ::authzed::api::v1::CheckDebugTrace_SubProblems* sub_problems);
  ::authzed::api::v1::CheckDebugTrace_SubProblems* unsafe_arena_release_sub_problems();

  void clear_resolution();
  ResolutionCase resolution_case() const;
  // @@protoc_insertion_point(class_scope:authzed.api.v1.CheckDebugTrace)
 private:
  class _Internal;
  void set_has_was_cached_result();
  void set_has_sub_problems();

  inline bool has_resolution() const;
  inline void clear_has_resolution();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr permission_;
    ::authzed::api::v1::ObjectReference* resource_;
    ::authzed::api::v1::SubjectReference* subject_;
    ::authzed::api::v1::CaveatEvalInfo* caveat_evaluation_info_;
    int permission_type_;
    int result_;
    union ResolutionUnion {
      constexpr ResolutionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool was_cached_result_;
      ::authzed::api::v1::CheckDebugTrace_SubProblems* sub_problems_;
    } resolution_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class CaveatEvalInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.CaveatEvalInfo) */ {
 public:
  inline CaveatEvalInfo() : CaveatEvalInfo(nullptr) {}
  ~CaveatEvalInfo() override;
  explicit PROTOBUF_CONSTEXPR CaveatEvalInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CaveatEvalInfo(const CaveatEvalInfo& from);
  CaveatEvalInfo(CaveatEvalInfo&& from) noexcept
    : CaveatEvalInfo() {
    *this = ::std::move(from);
  }

  inline CaveatEvalInfo& operator=(const CaveatEvalInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CaveatEvalInfo& operator=(CaveatEvalInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CaveatEvalInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CaveatEvalInfo* internal_default_instance() {
    return reinterpret_cast<const CaveatEvalInfo*>(
               &_CaveatEvalInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CaveatEvalInfo& a, CaveatEvalInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CaveatEvalInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CaveatEvalInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CaveatEvalInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CaveatEvalInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CaveatEvalInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CaveatEvalInfo& from) {
    CaveatEvalInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CaveatEvalInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.CaveatEvalInfo";
  }
  protected:
  explicit CaveatEvalInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CaveatEvalInfo_Result Result;
  static constexpr Result RESULT_UNSPECIFIED =
    CaveatEvalInfo_Result_RESULT_UNSPECIFIED;
  static constexpr Result RESULT_UNEVALUATED =
    CaveatEvalInfo_Result_RESULT_UNEVALUATED;
  static constexpr Result RESULT_FALSE =
    CaveatEvalInfo_Result_RESULT_FALSE;
  static constexpr Result RESULT_TRUE =
    CaveatEvalInfo_Result_RESULT_TRUE;
  static constexpr Result RESULT_MISSING_SOME_CONTEXT =
    CaveatEvalInfo_Result_RESULT_MISSING_SOME_CONTEXT;
  static inline bool Result_IsValid(int value) {
    return CaveatEvalInfo_Result_IsValid(value);
  }
  static constexpr Result Result_MIN =
    CaveatEvalInfo_Result_Result_MIN;
  static constexpr Result Result_MAX =
    CaveatEvalInfo_Result_Result_MAX;
  static constexpr int Result_ARRAYSIZE =
    CaveatEvalInfo_Result_Result_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Result_descriptor() {
    return CaveatEvalInfo_Result_descriptor();
  }
  template<typename T>
  static inline const std::string& Result_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Result>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Result_Name.");
    return CaveatEvalInfo_Result_Name(enum_t_value);
  }
  static inline bool Result_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Result* value) {
    return CaveatEvalInfo_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kExpressionFieldNumber = 1,
    kCaveatNameFieldNumber = 5,
    kContextFieldNumber = 3,
    kPartialCaveatInfoFieldNumber = 4,
    kResultFieldNumber = 2,
  };
  // string expression = 1 [json_name = "expression"];
  void clear_expression();
  const std::string& expression() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_expression(ArgT0&& arg0, ArgT... args);
  std::string* mutable_expression();
  PROTOBUF_NODISCARD std::string* release_expression();
  void set_allocated_expression(std::string* expression);
  private:
  const std::string& _internal_expression() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expression(const std::string& value);
  std::string* _internal_mutable_expression();
  public:

  // string caveat_name = 5 [json_name = "caveatName"];
  void clear_caveat_name();
  const std::string& caveat_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_caveat_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_caveat_name();
  PROTOBUF_NODISCARD std::string* release_caveat_name();
  void set_allocated_caveat_name(std::string* caveat_name);
  private:
  const std::string& _internal_caveat_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_caveat_name(const std::string& value);
  std::string* _internal_mutable_caveat_name();
  public:

  // .google.protobuf.Struct context = 3 [json_name = "context"];
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::PROTOBUF_NAMESPACE_ID::Struct& context() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_context();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_context();
  void set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_context() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::PROTOBUF_NAMESPACE_ID::Struct* context);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_context();

  // .authzed.api.v1.PartialCaveatInfo partial_caveat_info = 4 [json_name = "partialCaveatInfo"];
  bool has_partial_caveat_info() const;
  private:
  bool _internal_has_partial_caveat_info() const;
  public:
  void clear_partial_caveat_info();
  const ::authzed::api::v1::PartialCaveatInfo& partial_caveat_info() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::PartialCaveatInfo* release_partial_caveat_info();
  ::authzed::api::v1::PartialCaveatInfo* mutable_partial_caveat_info();
  void set_allocated_partial_caveat_info(::authzed::api::v1::PartialCaveatInfo* partial_caveat_info);
  private:
  const ::authzed::api::v1::PartialCaveatInfo& _internal_partial_caveat_info() const;
  ::authzed::api::v1::PartialCaveatInfo* _internal_mutable_partial_caveat_info();
  public:
  void unsafe_arena_set_allocated_partial_caveat_info(
      ::authzed::api::v1::PartialCaveatInfo* partial_caveat_info);
  ::authzed::api::v1::PartialCaveatInfo* unsafe_arena_release_partial_caveat_info();

  // .authzed.api.v1.CaveatEvalInfo.Result result = 2 [json_name = "result"];
  void clear_result();
  ::authzed::api::v1::CaveatEvalInfo_Result result() const;
  void set_result(::authzed::api::v1::CaveatEvalInfo_Result value);
  private:
  ::authzed::api::v1::CaveatEvalInfo_Result _internal_result() const;
  void _internal_set_result(::authzed::api::v1::CaveatEvalInfo_Result value);
  public:

  // @@protoc_insertion_point(class_scope:authzed.api.v1.CaveatEvalInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr expression_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr caveat_name_;
    ::PROTOBUF_NAMESPACE_ID::Struct* context_;
    ::authzed::api::v1::PartialCaveatInfo* partial_caveat_info_;
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fdebug_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DebugInformation

// .authzed.api.v1.CheckDebugTrace check = 1 [json_name = "check"];
inline bool DebugInformation::_internal_has_check() const {
  return this != internal_default_instance() && _impl_.check_ != nullptr;
}
inline bool DebugInformation::has_check() const {
  return _internal_has_check();
}
inline void DebugInformation::clear_check() {
  if (GetArenaForAllocation() == nullptr && _impl_.check_ != nullptr) {
    delete _impl_.check_;
  }
  _impl_.check_ = nullptr;
}
inline const ::authzed::api::v1::CheckDebugTrace& DebugInformation::_internal_check() const {
  const ::authzed::api::v1::CheckDebugTrace* p = _impl_.check_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::CheckDebugTrace&>(
      ::authzed::api::v1::_CheckDebugTrace_default_instance_);
}
inline const ::authzed::api::v1::CheckDebugTrace& DebugInformation::check() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.DebugInformation.check)
  return _internal_check();
}
inline void DebugInformation::unsafe_arena_set_allocated_check(
    ::authzed::api::v1::CheckDebugTrace* check) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.check_);
  }
  _impl_.check_ = check;
  if (check) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.DebugInformation.check)
}
inline ::authzed::api::v1::CheckDebugTrace* DebugInformation::release_check() {
  
  ::authzed::api::v1::CheckDebugTrace* temp = _impl_.check_;
  _impl_.check_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::CheckDebugTrace* DebugInformation::unsafe_arena_release_check() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.DebugInformation.check)
  
  ::authzed::api::v1::CheckDebugTrace* temp = _impl_.check_;
  _impl_.check_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::CheckDebugTrace* DebugInformation::_internal_mutable_check() {
  
  if (_impl_.check_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::CheckDebugTrace>(GetArenaForAllocation());
    _impl_.check_ = p;
  }
  return _impl_.check_;
}
inline ::authzed::api::v1::CheckDebugTrace* DebugInformation::mutable_check() {
  ::authzed::api::v1::CheckDebugTrace* _msg = _internal_mutable_check();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.DebugInformation.check)
  return _msg;
}
inline void DebugInformation::set_allocated_check(::authzed::api::v1::CheckDebugTrace* check) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.check_;
  }
  if (check) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(check);
    if (message_arena != submessage_arena) {
      check = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.check_ = check;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.DebugInformation.check)
}

// string schema_used = 2 [json_name = "schemaUsed"];
inline void DebugInformation::clear_schema_used() {
  _impl_.schema_used_.ClearToEmpty();
}
inline const std::string& DebugInformation::schema_used() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.DebugInformation.schema_used)
  return _internal_schema_used();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DebugInformation::set_schema_used(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_used_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.DebugInformation.schema_used)
}
inline std::string* DebugInformation::mutable_schema_used() {
  std::string* _s = _internal_mutable_schema_used();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.DebugInformation.schema_used)
  return _s;
}
inline const std::string& DebugInformation::_internal_schema_used() const {
  return _impl_.schema_used_.Get();
}
inline void DebugInformation::_internal_set_schema_used(const std::string& value) {
  
  _impl_.schema_used_.Set(value, GetArenaForAllocation());
}
inline std::string* DebugInformation::_internal_mutable_schema_used() {
  
  return _impl_.schema_used_.Mutable(GetArenaForAllocation());
}
inline std::string* DebugInformation::release_schema_used() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.DebugInformation.schema_used)
  return _impl_.schema_used_.Release();
}
inline void DebugInformation::set_allocated_schema_used(std::string* schema_used) {
  if (schema_used != nullptr) {
    
  } else {
    
  }
  _impl_.schema_used_.SetAllocated(schema_used, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_used_.IsDefault()) {
    _impl_.schema_used_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.DebugInformation.schema_used)
}

// -------------------------------------------------------------------

// CheckDebugTrace_SubProblems

// repeated .authzed.api.v1.CheckDebugTrace traces = 1 [json_name = "traces"];
inline int CheckDebugTrace_SubProblems::_internal_traces_size() const {
  return _impl_.traces_.size();
}
inline int CheckDebugTrace_SubProblems::traces_size() const {
  return _internal_traces_size();
}
inline void CheckDebugTrace_SubProblems::clear_traces() {
  _impl_.traces_.Clear();
}
inline ::authzed::api::v1::CheckDebugTrace* CheckDebugTrace_SubProblems::mutable_traces(int index) {
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.CheckDebugTrace.SubProblems.traces)
  return _impl_.traces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::CheckDebugTrace >*
CheckDebugTrace_SubProblems::mutable_traces() {
  // @@protoc_insertion_point(field_mutable_list:authzed.api.v1.CheckDebugTrace.SubProblems.traces)
  return &_impl_.traces_;
}
inline const ::authzed::api::v1::CheckDebugTrace& CheckDebugTrace_SubProblems::_internal_traces(int index) const {
  return _impl_.traces_.Get(index);
}
inline const ::authzed::api::v1::CheckDebugTrace& CheckDebugTrace_SubProblems::traces(int index) const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.CheckDebugTrace.SubProblems.traces)
  return _internal_traces(index);
}
inline ::authzed::api::v1::CheckDebugTrace* CheckDebugTrace_SubProblems::_internal_add_traces() {
  return _impl_.traces_.Add();
}
inline ::authzed::api::v1::CheckDebugTrace* CheckDebugTrace_SubProblems::add_traces() {
  ::authzed::api::v1::CheckDebugTrace* _add = _internal_add_traces();
  // @@protoc_insertion_point(field_add:authzed.api.v1.CheckDebugTrace.SubProblems.traces)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::CheckDebugTrace >&
CheckDebugTrace_SubProblems::traces() const {
  // @@protoc_insertion_point(field_list:authzed.api.v1.CheckDebugTrace.SubProblems.traces)
  return _impl_.traces_;
}

// -------------------------------------------------------------------

// CheckDebugTrace

// .authzed.api.v1.ObjectReference resource = 1 [json_name = "resource", (.validate.rules) = {
inline bool CheckDebugTrace::_internal_has_resource() const {
  return this != internal_default_instance() && _impl_.resource_ != nullptr;
}
inline bool CheckDebugTrace::has_resource() const {
  return _internal_has_resource();
}
inline const ::authzed::api::v1::ObjectReference& CheckDebugTrace::_internal_resource() const {
  const ::authzed::api::v1::ObjectReference* p = _impl_.resource_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::ObjectReference&>(
      ::authzed::api::v1::_ObjectReference_default_instance_);
}
inline const ::authzed::api::v1::ObjectReference& CheckDebugTrace::resource() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.CheckDebugTrace.resource)
  return _internal_resource();
}
inline void CheckDebugTrace::unsafe_arena_set_allocated_resource(
    ::authzed::api::v1::ObjectReference* resource) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resource_);
  }
  _impl_.resource_ = resource;
  if (resource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.CheckDebugTrace.resource)
}
inline ::authzed::api::v1::ObjectReference* CheckDebugTrace::release_resource() {
  
  ::authzed::api::v1::ObjectReference* temp = _impl_.resource_;
  _impl_.resource_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::ObjectReference* CheckDebugTrace::unsafe_arena_release_resource() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.CheckDebugTrace.resource)
  
  ::authzed::api::v1::ObjectReference* temp = _impl_.resource_;
  _impl_.resource_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::ObjectReference* CheckDebugTrace::_internal_mutable_resource() {
  
  if (_impl_.resource_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::ObjectReference>(GetArenaForAllocation());
    _impl_.resource_ = p;
  }
  return _impl_.resource_;
}
inline ::authzed::api::v1::ObjectReference* CheckDebugTrace::mutable_resource() {
  ::authzed::api::v1::ObjectReference* _msg = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.CheckDebugTrace.resource)
  return _msg;
}
inline void CheckDebugTrace::set_allocated_resource(::authzed::api::v1::ObjectReference* resource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resource_);
  }
  if (resource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resource));
    if (message_arena != submessage_arena) {
      resource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resource, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.resource_ = resource;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.CheckDebugTrace.resource)
}

// string permission = 2 [json_name = "permission"];
inline void CheckDebugTrace::clear_permission() {
  _impl_.permission_.ClearToEmpty();
}
inline const std::string& CheckDebugTrace::permission() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.CheckDebugTrace.permission)
  return _internal_permission();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckDebugTrace::set_permission(ArgT0&& arg0, ArgT... args) {
 
 _impl_.permission_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.CheckDebugTrace.permission)
}
inline std::string* CheckDebugTrace::mutable_permission() {
  std::string* _s = _internal_mutable_permission();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.CheckDebugTrace.permission)
  return _s;
}
inline const std::string& CheckDebugTrace::_internal_permission() const {
  return _impl_.permission_.Get();
}
inline void CheckDebugTrace::_internal_set_permission(const std::string& value) {
  
  _impl_.permission_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckDebugTrace::_internal_mutable_permission() {
  
  return _impl_.permission_.Mutable(GetArenaForAllocation());
}
inline std::string* CheckDebugTrace::release_permission() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.CheckDebugTrace.permission)
  return _impl_.permission_.Release();
}
inline void CheckDebugTrace::set_allocated_permission(std::string* permission) {
  if (permission != nullptr) {
    
  } else {
    
  }
  _impl_.permission_.SetAllocated(permission, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.permission_.IsDefault()) {
    _impl_.permission_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.CheckDebugTrace.permission)
}

// .authzed.api.v1.CheckDebugTrace.PermissionType permission_type = 3 [json_name = "permissionType", (.validate.rules) = {
inline void CheckDebugTrace::clear_permission_type() {
  _impl_.permission_type_ = 0;
}
inline ::authzed::api::v1::CheckDebugTrace_PermissionType CheckDebugTrace::_internal_permission_type() const {
  return static_cast< ::authzed::api::v1::CheckDebugTrace_PermissionType >(_impl_.permission_type_);
}
inline ::authzed::api::v1::CheckDebugTrace_PermissionType CheckDebugTrace::permission_type() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.CheckDebugTrace.permission_type)
  return _internal_permission_type();
}
inline void CheckDebugTrace::_internal_set_permission_type(::authzed::api::v1::CheckDebugTrace_PermissionType value) {
  
  _impl_.permission_type_ = value;
}
inline void CheckDebugTrace::set_permission_type(::authzed::api::v1::CheckDebugTrace_PermissionType value) {
  _internal_set_permission_type(value);
  // @@protoc_insertion_point(field_set:authzed.api.v1.CheckDebugTrace.permission_type)
}

// .authzed.api.v1.SubjectReference subject = 4 [json_name = "subject", (.validate.rules) = {
inline bool CheckDebugTrace::_internal_has_subject() const {
  return this != internal_default_instance() && _impl_.subject_ != nullptr;
}
inline bool CheckDebugTrace::has_subject() const {
  return _internal_has_subject();
}
inline const ::authzed::api::v1::SubjectReference& CheckDebugTrace::_internal_subject() const {
  const ::authzed::api::v1::SubjectReference* p = _impl_.subject_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::SubjectReference&>(
      ::authzed::api::v1::_SubjectReference_default_instance_);
}
inline const ::authzed::api::v1::SubjectReference& CheckDebugTrace::subject() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.CheckDebugTrace.subject)
  return _internal_subject();
}
inline void CheckDebugTrace::unsafe_arena_set_allocated_subject(
    ::authzed::api::v1::SubjectReference* subject) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subject_);
  }
  _impl_.subject_ = subject;
  if (subject) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.CheckDebugTrace.subject)
}
inline ::authzed::api::v1::SubjectReference* CheckDebugTrace::release_subject() {
  
  ::authzed::api::v1::SubjectReference* temp = _impl_.subject_;
  _impl_.subject_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::SubjectReference* CheckDebugTrace::unsafe_arena_release_subject() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.CheckDebugTrace.subject)
  
  ::authzed::api::v1::SubjectReference* temp = _impl_.subject_;
  _impl_.subject_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::SubjectReference* CheckDebugTrace::_internal_mutable_subject() {
  
  if (_impl_.subject_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::SubjectReference>(GetArenaForAllocation());
    _impl_.subject_ = p;
  }
  return _impl_.subject_;
}
inline ::authzed::api::v1::SubjectReference* CheckDebugTrace::mutable_subject() {
  ::authzed::api::v1::SubjectReference* _msg = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.CheckDebugTrace.subject)
  return _msg;
}
inline void CheckDebugTrace::set_allocated_subject(::authzed::api::v1::SubjectReference* subject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subject_);
  }
  if (subject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subject));
    if (message_arena != submessage_arena) {
      subject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subject, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.subject_ = subject;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.CheckDebugTrace.subject)
}

// .authzed.api.v1.CheckDebugTrace.Permissionship result = 5 [json_name = "result", (.validate.rules) = {
inline void CheckDebugTrace::clear_result() {
  _impl_.result_ = 0;
}
inline ::authzed::api::v1::CheckDebugTrace_Permissionship CheckDebugTrace::_internal_result() const {
  return static_cast< ::authzed::api::v1::CheckDebugTrace_Permissionship >(_impl_.result_);
}
inline ::authzed::api::v1::CheckDebugTrace_Permissionship CheckDebugTrace::result() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.CheckDebugTrace.result)
  return _internal_result();
}
inline void CheckDebugTrace::_internal_set_result(::authzed::api::v1::CheckDebugTrace_Permissionship value) {
  
  _impl_.result_ = value;
}
inline void CheckDebugTrace::set_result(::authzed::api::v1::CheckDebugTrace_Permissionship value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:authzed.api.v1.CheckDebugTrace.result)
}

// .authzed.api.v1.CaveatEvalInfo caveat_evaluation_info = 8 [json_name = "caveatEvaluationInfo"];
inline bool CheckDebugTrace::_internal_has_caveat_evaluation_info() const {
  return this != internal_default_instance() && _impl_.caveat_evaluation_info_ != nullptr;
}
inline bool CheckDebugTrace::has_caveat_evaluation_info() const {
  return _internal_has_caveat_evaluation_info();
}
inline void CheckDebugTrace::clear_caveat_evaluation_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.caveat_evaluation_info_ != nullptr) {
    delete _impl_.caveat_evaluation_info_;
  }
  _impl_.caveat_evaluation_info_ = nullptr;
}
inline const ::authzed::api::v1::CaveatEvalInfo& CheckDebugTrace::_internal_caveat_evaluation_info() const {
  const ::authzed::api::v1::CaveatEvalInfo* p = _impl_.caveat_evaluation_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::CaveatEvalInfo&>(
      ::authzed::api::v1::_CaveatEvalInfo_default_instance_);
}
inline const ::authzed::api::v1::CaveatEvalInfo& CheckDebugTrace::caveat_evaluation_info() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.CheckDebugTrace.caveat_evaluation_info)
  return _internal_caveat_evaluation_info();
}
inline void CheckDebugTrace::unsafe_arena_set_allocated_caveat_evaluation_info(
    ::authzed::api::v1::CaveatEvalInfo* caveat_evaluation_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.caveat_evaluation_info_);
  }
  _impl_.caveat_evaluation_info_ = caveat_evaluation_info;
  if (caveat_evaluation_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.CheckDebugTrace.caveat_evaluation_info)
}
inline ::authzed::api::v1::CaveatEvalInfo* CheckDebugTrace::release_caveat_evaluation_info() {
  
  ::authzed::api::v1::CaveatEvalInfo* temp = _impl_.caveat_evaluation_info_;
  _impl_.caveat_evaluation_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::CaveatEvalInfo* CheckDebugTrace::unsafe_arena_release_caveat_evaluation_info() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.CheckDebugTrace.caveat_evaluation_info)
  
  ::authzed::api::v1::CaveatEvalInfo* temp = _impl_.caveat_evaluation_info_;
  _impl_.caveat_evaluation_info_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::CaveatEvalInfo* CheckDebugTrace::_internal_mutable_caveat_evaluation_info() {
  
  if (_impl_.caveat_evaluation_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::CaveatEvalInfo>(GetArenaForAllocation());
    _impl_.caveat_evaluation_info_ = p;
  }
  return _impl_.caveat_evaluation_info_;
}
inline ::authzed::api::v1::CaveatEvalInfo* CheckDebugTrace::mutable_caveat_evaluation_info() {
  ::authzed::api::v1::CaveatEvalInfo* _msg = _internal_mutable_caveat_evaluation_info();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.CheckDebugTrace.caveat_evaluation_info)
  return _msg;
}
inline void CheckDebugTrace::set_allocated_caveat_evaluation_info(::authzed::api::v1::CaveatEvalInfo* caveat_evaluation_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.caveat_evaluation_info_;
  }
  if (caveat_evaluation_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(caveat_evaluation_info);
    if (message_arena != submessage_arena) {
      caveat_evaluation_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, caveat_evaluation_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.caveat_evaluation_info_ = caveat_evaluation_info;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.CheckDebugTrace.caveat_evaluation_info)
}

// bool was_cached_result = 6 [json_name = "wasCachedResult"];
inline bool CheckDebugTrace::_internal_has_was_cached_result() const {
  return resolution_case() == kWasCachedResult;
}
inline bool CheckDebugTrace::has_was_cached_result() const {
  return _internal_has_was_cached_result();
}
inline void CheckDebugTrace::set_has_was_cached_result() {
  _impl_._oneof_case_[0] = kWasCachedResult;
}
inline void CheckDebugTrace::clear_was_cached_result() {
  if (_internal_has_was_cached_result()) {
    _impl_.resolution_.was_cached_result_ = false;
    clear_has_resolution();
  }
}
inline bool CheckDebugTrace::_internal_was_cached_result() const {
  if (_internal_has_was_cached_result()) {
    return _impl_.resolution_.was_cached_result_;
  }
  return false;
}
inline void CheckDebugTrace::_internal_set_was_cached_result(bool value) {
  if (!_internal_has_was_cached_result()) {
    clear_resolution();
    set_has_was_cached_result();
  }
  _impl_.resolution_.was_cached_result_ = value;
}
inline bool CheckDebugTrace::was_cached_result() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.CheckDebugTrace.was_cached_result)
  return _internal_was_cached_result();
}
inline void CheckDebugTrace::set_was_cached_result(bool value) {
  _internal_set_was_cached_result(value);
  // @@protoc_insertion_point(field_set:authzed.api.v1.CheckDebugTrace.was_cached_result)
}

// .authzed.api.v1.CheckDebugTrace.SubProblems sub_problems = 7 [json_name = "subProblems"];
inline bool CheckDebugTrace::_internal_has_sub_problems() const {
  return resolution_case() == kSubProblems;
}
inline bool CheckDebugTrace::has_sub_problems() const {
  return _internal_has_sub_problems();
}
inline void CheckDebugTrace::set_has_sub_problems() {
  _impl_._oneof_case_[0] = kSubProblems;
}
inline void CheckDebugTrace::clear_sub_problems() {
  if (_internal_has_sub_problems()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.resolution_.sub_problems_;
    }
    clear_has_resolution();
  }
}
inline ::authzed::api::v1::CheckDebugTrace_SubProblems* CheckDebugTrace::release_sub_problems() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.CheckDebugTrace.sub_problems)
  if (_internal_has_sub_problems()) {
    clear_has_resolution();
    ::authzed::api::v1::CheckDebugTrace_SubProblems* temp = _impl_.resolution_.sub_problems_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.resolution_.sub_problems_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::authzed::api::v1::CheckDebugTrace_SubProblems& CheckDebugTrace::_internal_sub_problems() const {
  return _internal_has_sub_problems()
      ? *_impl_.resolution_.sub_problems_
      : reinterpret_cast< ::authzed::api::v1::CheckDebugTrace_SubProblems&>(::authzed::api::v1::_CheckDebugTrace_SubProblems_default_instance_);
}
inline const ::authzed::api::v1::CheckDebugTrace_SubProblems& CheckDebugTrace::sub_problems() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.CheckDebugTrace.sub_problems)
  return _internal_sub_problems();
}
inline ::authzed::api::v1::CheckDebugTrace_SubProblems* CheckDebugTrace::unsafe_arena_release_sub_problems() {
  // @@protoc_insertion_point(field_unsafe_arena_release:authzed.api.v1.CheckDebugTrace.sub_problems)
  if (_internal_has_sub_problems()) {
    clear_has_resolution();
    ::authzed::api::v1::CheckDebugTrace_SubProblems* temp = _impl_.resolution_.sub_problems_;
    _impl_.resolution_.sub_problems_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CheckDebugTrace::unsafe_arena_set_allocated_sub_problems(::authzed::api::v1::CheckDebugTrace_SubProblems* sub_problems) {
  clear_resolution();
  if (sub_problems) {
    set_has_sub_problems();
    _impl_.resolution_.sub_problems_ = sub_problems;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.CheckDebugTrace.sub_problems)
}
inline ::authzed::api::v1::CheckDebugTrace_SubProblems* CheckDebugTrace::_internal_mutable_sub_problems() {
  if (!_internal_has_sub_problems()) {
    clear_resolution();
    set_has_sub_problems();
    _impl_.resolution_.sub_problems_ = CreateMaybeMessage< ::authzed::api::v1::CheckDebugTrace_SubProblems >(GetArenaForAllocation());
  }
  return _impl_.resolution_.sub_problems_;
}
inline ::authzed::api::v1::CheckDebugTrace_SubProblems* CheckDebugTrace::mutable_sub_problems() {
  ::authzed::api::v1::CheckDebugTrace_SubProblems* _msg = _internal_mutable_sub_problems();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.CheckDebugTrace.sub_problems)
  return _msg;
}

inline bool CheckDebugTrace::has_resolution() const {
  return resolution_case() != RESOLUTION_NOT_SET;
}
inline void CheckDebugTrace::clear_has_resolution() {
  _impl_._oneof_case_[0] = RESOLUTION_NOT_SET;
}
inline CheckDebugTrace::ResolutionCase CheckDebugTrace::resolution_case() const {
  return CheckDebugTrace::ResolutionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CaveatEvalInfo

// string expression = 1 [json_name = "expression"];
inline void CaveatEvalInfo::clear_expression() {
  _impl_.expression_.ClearToEmpty();
}
inline const std::string& CaveatEvalInfo::expression() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.CaveatEvalInfo.expression)
  return _internal_expression();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CaveatEvalInfo::set_expression(ArgT0&& arg0, ArgT... args) {
 
 _impl_.expression_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.CaveatEvalInfo.expression)
}
inline std::string* CaveatEvalInfo::mutable_expression() {
  std::string* _s = _internal_mutable_expression();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.CaveatEvalInfo.expression)
  return _s;
}
inline const std::string& CaveatEvalInfo::_internal_expression() const {
  return _impl_.expression_.Get();
}
inline void CaveatEvalInfo::_internal_set_expression(const std::string& value) {
  
  _impl_.expression_.Set(value, GetArenaForAllocation());
}
inline std::string* CaveatEvalInfo::_internal_mutable_expression() {
  
  return _impl_.expression_.Mutable(GetArenaForAllocation());
}
inline std::string* CaveatEvalInfo::release_expression() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.CaveatEvalInfo.expression)
  return _impl_.expression_.Release();
}
inline void CaveatEvalInfo::set_allocated_expression(std::string* expression) {
  if (expression != nullptr) {
    
  } else {
    
  }
  _impl_.expression_.SetAllocated(expression, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.expression_.IsDefault()) {
    _impl_.expression_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.CaveatEvalInfo.expression)
}

// .authzed.api.v1.CaveatEvalInfo.Result result = 2 [json_name = "result"];
inline void CaveatEvalInfo::clear_result() {
  _impl_.result_ = 0;
}
inline ::authzed::api::v1::CaveatEvalInfo_Result CaveatEvalInfo::_internal_result() const {
  return static_cast< ::authzed::api::v1::CaveatEvalInfo_Result >(_impl_.result_);
}
inline ::authzed::api::v1::CaveatEvalInfo_Result CaveatEvalInfo::result() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.CaveatEvalInfo.result)
  return _internal_result();
}
inline void CaveatEvalInfo::_internal_set_result(::authzed::api::v1::CaveatEvalInfo_Result value) {
  
  _impl_.result_ = value;
}
inline void CaveatEvalInfo::set_result(::authzed::api::v1::CaveatEvalInfo_Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:authzed.api.v1.CaveatEvalInfo.result)
}

// .google.protobuf.Struct context = 3 [json_name = "context"];
inline bool CaveatEvalInfo::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool CaveatEvalInfo::has_context() const {
  return _internal_has_context();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& CaveatEvalInfo::_internal_context() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& CaveatEvalInfo::context() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.CaveatEvalInfo.context)
  return _internal_context();
}
inline void CaveatEvalInfo::unsafe_arena_set_allocated_context(
    ::PROTOBUF_NAMESPACE_ID::Struct* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.CaveatEvalInfo.context)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CaveatEvalInfo::release_context() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CaveatEvalInfo::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.CaveatEvalInfo.context)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CaveatEvalInfo::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CaveatEvalInfo::mutable_context() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.CaveatEvalInfo.context)
  return _msg;
}
inline void CaveatEvalInfo::set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(context));
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.CaveatEvalInfo.context)
}

// .authzed.api.v1.PartialCaveatInfo partial_caveat_info = 4 [json_name = "partialCaveatInfo"];
inline bool CaveatEvalInfo::_internal_has_partial_caveat_info() const {
  return this != internal_default_instance() && _impl_.partial_caveat_info_ != nullptr;
}
inline bool CaveatEvalInfo::has_partial_caveat_info() const {
  return _internal_has_partial_caveat_info();
}
inline const ::authzed::api::v1::PartialCaveatInfo& CaveatEvalInfo::_internal_partial_caveat_info() const {
  const ::authzed::api::v1::PartialCaveatInfo* p = _impl_.partial_caveat_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::PartialCaveatInfo&>(
      ::authzed::api::v1::_PartialCaveatInfo_default_instance_);
}
inline const ::authzed::api::v1::PartialCaveatInfo& CaveatEvalInfo::partial_caveat_info() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.CaveatEvalInfo.partial_caveat_info)
  return _internal_partial_caveat_info();
}
inline void CaveatEvalInfo::unsafe_arena_set_allocated_partial_caveat_info(
    ::authzed::api::v1::PartialCaveatInfo* partial_caveat_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.partial_caveat_info_);
  }
  _impl_.partial_caveat_info_ = partial_caveat_info;
  if (partial_caveat_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.CaveatEvalInfo.partial_caveat_info)
}
inline ::authzed::api::v1::PartialCaveatInfo* CaveatEvalInfo::release_partial_caveat_info() {
  
  ::authzed::api::v1::PartialCaveatInfo* temp = _impl_.partial_caveat_info_;
  _impl_.partial_caveat_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::PartialCaveatInfo* CaveatEvalInfo::unsafe_arena_release_partial_caveat_info() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.CaveatEvalInfo.partial_caveat_info)
  
  ::authzed::api::v1::PartialCaveatInfo* temp = _impl_.partial_caveat_info_;
  _impl_.partial_caveat_info_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::PartialCaveatInfo* CaveatEvalInfo::_internal_mutable_partial_caveat_info() {
  
  if (_impl_.partial_caveat_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::PartialCaveatInfo>(GetArenaForAllocation());
    _impl_.partial_caveat_info_ = p;
  }
  return _impl_.partial_caveat_info_;
}
inline ::authzed::api::v1::PartialCaveatInfo* CaveatEvalInfo::mutable_partial_caveat_info() {
  ::authzed::api::v1::PartialCaveatInfo* _msg = _internal_mutable_partial_caveat_info();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.CaveatEvalInfo.partial_caveat_info)
  return _msg;
}
inline void CaveatEvalInfo::set_allocated_partial_caveat_info(::authzed::api::v1::PartialCaveatInfo* partial_caveat_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.partial_caveat_info_);
  }
  if (partial_caveat_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(partial_caveat_info));
    if (message_arena != submessage_arena) {
      partial_caveat_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partial_caveat_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.partial_caveat_info_ = partial_caveat_info;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.CaveatEvalInfo.partial_caveat_info)
}

// string caveat_name = 5 [json_name = "caveatName"];
inline void CaveatEvalInfo::clear_caveat_name() {
  _impl_.caveat_name_.ClearToEmpty();
}
inline const std::string& CaveatEvalInfo::caveat_name() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.CaveatEvalInfo.caveat_name)
  return _internal_caveat_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CaveatEvalInfo::set_caveat_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.caveat_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.CaveatEvalInfo.caveat_name)
}
inline std::string* CaveatEvalInfo::mutable_caveat_name() {
  std::string* _s = _internal_mutable_caveat_name();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.CaveatEvalInfo.caveat_name)
  return _s;
}
inline const std::string& CaveatEvalInfo::_internal_caveat_name() const {
  return _impl_.caveat_name_.Get();
}
inline void CaveatEvalInfo::_internal_set_caveat_name(const std::string& value) {
  
  _impl_.caveat_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CaveatEvalInfo::_internal_mutable_caveat_name() {
  
  return _impl_.caveat_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CaveatEvalInfo::release_caveat_name() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.CaveatEvalInfo.caveat_name)
  return _impl_.caveat_name_.Release();
}
inline void CaveatEvalInfo::set_allocated_caveat_name(std::string* caveat_name) {
  if (caveat_name != nullptr) {
    
  } else {
    
  }
  _impl_.caveat_name_.SetAllocated(caveat_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.caveat_name_.IsDefault()) {
    _impl_.caveat_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.CaveatEvalInfo.caveat_name)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace api
}  // namespace authzed

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::authzed::api::v1::CheckDebugTrace_PermissionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::authzed::api::v1::CheckDebugTrace_PermissionType>() {
  return ::authzed::api::v1::CheckDebugTrace_PermissionType_descriptor();
}
template <> struct is_proto_enum< ::authzed::api::v1::CheckDebugTrace_Permissionship> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::authzed::api::v1::CheckDebugTrace_Permissionship>() {
  return ::authzed::api::v1::CheckDebugTrace_Permissionship_descriptor();
}
template <> struct is_proto_enum< ::authzed::api::v1::CaveatEvalInfo_Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::authzed::api::v1::CaveatEvalInfo_Result>() {
  return ::authzed::api::v1::CaveatEvalInfo_Result_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_authzed_2fapi_2fv1_2fdebug_2eproto
#endif // ifdef check