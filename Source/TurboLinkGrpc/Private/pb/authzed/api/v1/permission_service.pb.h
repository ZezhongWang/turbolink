#if defined(_MSC_VER)
  #pragma warning (disable:4946) // reinterpret_cast used between related classes: 'class1' and 'class2'
#endif
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: authzed/api/v1/permission_service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_authzed_2fapi_2fv1_2fpermission_5fservice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_authzed_2fapi_2fv1_2fpermission_5fservice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/struct.pb.h>
#include "pb/google/api/annotations.pb.h"
#include "pb/validate/validate.pb.h"
#include "pb/authzed/api/v1/core.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_authzed_2fapi_2fv1_2fpermission_5fservice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_authzed_2fapi_2fv1_2fpermission_5fservice_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_authzed_2fapi_2fv1_2fpermission_5fservice_2eproto;
namespace authzed {
namespace api {
namespace v1 {
class CheckPermissionRequest;
struct CheckPermissionRequestDefaultTypeInternal;
extern CheckPermissionRequestDefaultTypeInternal _CheckPermissionRequest_default_instance_;
class CheckPermissionResponse;
struct CheckPermissionResponseDefaultTypeInternal;
extern CheckPermissionResponseDefaultTypeInternal _CheckPermissionResponse_default_instance_;
class Consistency;
struct ConsistencyDefaultTypeInternal;
extern ConsistencyDefaultTypeInternal _Consistency_default_instance_;
class DeleteRelationshipsRequest;
struct DeleteRelationshipsRequestDefaultTypeInternal;
extern DeleteRelationshipsRequestDefaultTypeInternal _DeleteRelationshipsRequest_default_instance_;
class DeleteRelationshipsResponse;
struct DeleteRelationshipsResponseDefaultTypeInternal;
extern DeleteRelationshipsResponseDefaultTypeInternal _DeleteRelationshipsResponse_default_instance_;
class ExpandPermissionTreeRequest;
struct ExpandPermissionTreeRequestDefaultTypeInternal;
extern ExpandPermissionTreeRequestDefaultTypeInternal _ExpandPermissionTreeRequest_default_instance_;
class ExpandPermissionTreeResponse;
struct ExpandPermissionTreeResponseDefaultTypeInternal;
extern ExpandPermissionTreeResponseDefaultTypeInternal _ExpandPermissionTreeResponse_default_instance_;
class LookupResourcesRequest;
struct LookupResourcesRequestDefaultTypeInternal;
extern LookupResourcesRequestDefaultTypeInternal _LookupResourcesRequest_default_instance_;
class LookupResourcesResponse;
struct LookupResourcesResponseDefaultTypeInternal;
extern LookupResourcesResponseDefaultTypeInternal _LookupResourcesResponse_default_instance_;
class LookupSubjectsRequest;
struct LookupSubjectsRequestDefaultTypeInternal;
extern LookupSubjectsRequestDefaultTypeInternal _LookupSubjectsRequest_default_instance_;
class LookupSubjectsResponse;
struct LookupSubjectsResponseDefaultTypeInternal;
extern LookupSubjectsResponseDefaultTypeInternal _LookupSubjectsResponse_default_instance_;
class Precondition;
struct PreconditionDefaultTypeInternal;
extern PreconditionDefaultTypeInternal _Precondition_default_instance_;
class ReadRelationshipsRequest;
struct ReadRelationshipsRequestDefaultTypeInternal;
extern ReadRelationshipsRequestDefaultTypeInternal _ReadRelationshipsRequest_default_instance_;
class ReadRelationshipsResponse;
struct ReadRelationshipsResponseDefaultTypeInternal;
extern ReadRelationshipsResponseDefaultTypeInternal _ReadRelationshipsResponse_default_instance_;
class RelationshipFilter;
struct RelationshipFilterDefaultTypeInternal;
extern RelationshipFilterDefaultTypeInternal _RelationshipFilter_default_instance_;
class ResolvedSubject;
struct ResolvedSubjectDefaultTypeInternal;
extern ResolvedSubjectDefaultTypeInternal _ResolvedSubject_default_instance_;
class SubjectFilter;
struct SubjectFilterDefaultTypeInternal;
extern SubjectFilterDefaultTypeInternal _SubjectFilter_default_instance_;
class SubjectFilter_RelationFilter;
struct SubjectFilter_RelationFilterDefaultTypeInternal;
extern SubjectFilter_RelationFilterDefaultTypeInternal _SubjectFilter_RelationFilter_default_instance_;
class WriteRelationshipsRequest;
struct WriteRelationshipsRequestDefaultTypeInternal;
extern WriteRelationshipsRequestDefaultTypeInternal _WriteRelationshipsRequest_default_instance_;
class WriteRelationshipsResponse;
struct WriteRelationshipsResponseDefaultTypeInternal;
extern WriteRelationshipsResponseDefaultTypeInternal _WriteRelationshipsResponse_default_instance_;
}  // namespace v1
}  // namespace api
}  // namespace authzed
PROTOBUF_NAMESPACE_OPEN
template<> ::authzed::api::v1::CheckPermissionRequest* Arena::CreateMaybeMessage<::authzed::api::v1::CheckPermissionRequest>(Arena*);
template<> ::authzed::api::v1::CheckPermissionResponse* Arena::CreateMaybeMessage<::authzed::api::v1::CheckPermissionResponse>(Arena*);
template<> ::authzed::api::v1::Consistency* Arena::CreateMaybeMessage<::authzed::api::v1::Consistency>(Arena*);
template<> ::authzed::api::v1::DeleteRelationshipsRequest* Arena::CreateMaybeMessage<::authzed::api::v1::DeleteRelationshipsRequest>(Arena*);
template<> ::authzed::api::v1::DeleteRelationshipsResponse* Arena::CreateMaybeMessage<::authzed::api::v1::DeleteRelationshipsResponse>(Arena*);
template<> ::authzed::api::v1::ExpandPermissionTreeRequest* Arena::CreateMaybeMessage<::authzed::api::v1::ExpandPermissionTreeRequest>(Arena*);
template<> ::authzed::api::v1::ExpandPermissionTreeResponse* Arena::CreateMaybeMessage<::authzed::api::v1::ExpandPermissionTreeResponse>(Arena*);
template<> ::authzed::api::v1::LookupResourcesRequest* Arena::CreateMaybeMessage<::authzed::api::v1::LookupResourcesRequest>(Arena*);
template<> ::authzed::api::v1::LookupResourcesResponse* Arena::CreateMaybeMessage<::authzed::api::v1::LookupResourcesResponse>(Arena*);
template<> ::authzed::api::v1::LookupSubjectsRequest* Arena::CreateMaybeMessage<::authzed::api::v1::LookupSubjectsRequest>(Arena*);
template<> ::authzed::api::v1::LookupSubjectsResponse* Arena::CreateMaybeMessage<::authzed::api::v1::LookupSubjectsResponse>(Arena*);
template<> ::authzed::api::v1::Precondition* Arena::CreateMaybeMessage<::authzed::api::v1::Precondition>(Arena*);
template<> ::authzed::api::v1::ReadRelationshipsRequest* Arena::CreateMaybeMessage<::authzed::api::v1::ReadRelationshipsRequest>(Arena*);
template<> ::authzed::api::v1::ReadRelationshipsResponse* Arena::CreateMaybeMessage<::authzed::api::v1::ReadRelationshipsResponse>(Arena*);
template<> ::authzed::api::v1::RelationshipFilter* Arena::CreateMaybeMessage<::authzed::api::v1::RelationshipFilter>(Arena*);
template<> ::authzed::api::v1::ResolvedSubject* Arena::CreateMaybeMessage<::authzed::api::v1::ResolvedSubject>(Arena*);
template<> ::authzed::api::v1::SubjectFilter* Arena::CreateMaybeMessage<::authzed::api::v1::SubjectFilter>(Arena*);
template<> ::authzed::api::v1::SubjectFilter_RelationFilter* Arena::CreateMaybeMessage<::authzed::api::v1::SubjectFilter_RelationFilter>(Arena*);
template<> ::authzed::api::v1::WriteRelationshipsRequest* Arena::CreateMaybeMessage<::authzed::api::v1::WriteRelationshipsRequest>(Arena*);
template<> ::authzed::api::v1::WriteRelationshipsResponse* Arena::CreateMaybeMessage<::authzed::api::v1::WriteRelationshipsResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace authzed {
namespace api {
namespace v1 {

enum Precondition_Operation : int {
  Precondition_Operation_OPERATION_UNSPECIFIED = 0,
  Precondition_Operation_OPERATION_MUST_NOT_MATCH = 1,
  Precondition_Operation_OPERATION_MUST_MATCH = 2,
  Precondition_Operation_Precondition_Operation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Precondition_Operation_Precondition_Operation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Precondition_Operation_IsValid(int value);
constexpr Precondition_Operation Precondition_Operation_Operation_MIN = Precondition_Operation_OPERATION_UNSPECIFIED;
constexpr Precondition_Operation Precondition_Operation_Operation_MAX = Precondition_Operation_OPERATION_MUST_MATCH;
constexpr int Precondition_Operation_Operation_ARRAYSIZE = Precondition_Operation_Operation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Precondition_Operation_descriptor();
template<typename T>
inline const std::string& Precondition_Operation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Precondition_Operation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Precondition_Operation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Precondition_Operation_descriptor(), enum_t_value);
}
inline bool Precondition_Operation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Precondition_Operation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Precondition_Operation>(
    Precondition_Operation_descriptor(), name, value);
}
enum CheckPermissionResponse_Permissionship : int {
  CheckPermissionResponse_Permissionship_PERMISSIONSHIP_UNSPECIFIED = 0,
  CheckPermissionResponse_Permissionship_PERMISSIONSHIP_NO_PERMISSION = 1,
  CheckPermissionResponse_Permissionship_PERMISSIONSHIP_HAS_PERMISSION = 2,
  CheckPermissionResponse_Permissionship_PERMISSIONSHIP_CONDITIONAL_PERMISSION = 3,
  CheckPermissionResponse_Permissionship_CheckPermissionResponse_Permissionship_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CheckPermissionResponse_Permissionship_CheckPermissionResponse_Permissionship_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CheckPermissionResponse_Permissionship_IsValid(int value);
constexpr CheckPermissionResponse_Permissionship CheckPermissionResponse_Permissionship_Permissionship_MIN = CheckPermissionResponse_Permissionship_PERMISSIONSHIP_UNSPECIFIED;
constexpr CheckPermissionResponse_Permissionship CheckPermissionResponse_Permissionship_Permissionship_MAX = CheckPermissionResponse_Permissionship_PERMISSIONSHIP_CONDITIONAL_PERMISSION;
constexpr int CheckPermissionResponse_Permissionship_Permissionship_ARRAYSIZE = CheckPermissionResponse_Permissionship_Permissionship_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CheckPermissionResponse_Permissionship_descriptor();
template<typename T>
inline const std::string& CheckPermissionResponse_Permissionship_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CheckPermissionResponse_Permissionship>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CheckPermissionResponse_Permissionship_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CheckPermissionResponse_Permissionship_descriptor(), enum_t_value);
}
inline bool CheckPermissionResponse_Permissionship_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CheckPermissionResponse_Permissionship* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CheckPermissionResponse_Permissionship>(
    CheckPermissionResponse_Permissionship_descriptor(), name, value);
}
enum LookupPermissionship : int {
  LOOKUP_PERMISSIONSHIP_UNSPECIFIED = 0,
  LOOKUP_PERMISSIONSHIP_HAS_PERMISSION = 1,
  LOOKUP_PERMISSIONSHIP_CONDITIONAL_PERMISSION = 2,
  LookupPermissionship_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LookupPermissionship_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LookupPermissionship_IsValid(int value);
constexpr LookupPermissionship LookupPermissionship_MIN = LOOKUP_PERMISSIONSHIP_UNSPECIFIED;
constexpr LookupPermissionship LookupPermissionship_MAX = LOOKUP_PERMISSIONSHIP_CONDITIONAL_PERMISSION;
constexpr int LookupPermissionship_ARRAYSIZE = LookupPermissionship_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LookupPermissionship_descriptor();
template<typename T>
inline const std::string& LookupPermissionship_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LookupPermissionship>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LookupPermissionship_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LookupPermissionship_descriptor(), enum_t_value);
}
inline bool LookupPermissionship_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LookupPermissionship* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LookupPermissionship>(
    LookupPermissionship_descriptor(), name, value);
}
// ===================================================================

class Consistency final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.Consistency) */ {
 public:
  inline Consistency() : Consistency(nullptr) {}
  ~Consistency() override;
  explicit PROTOBUF_CONSTEXPR Consistency(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Consistency(const Consistency& from);
  Consistency(Consistency&& from) noexcept
    : Consistency() {
    *this = ::std::move(from);
  }

  inline Consistency& operator=(const Consistency& from) {
    CopyFrom(from);
    return *this;
  }
  inline Consistency& operator=(Consistency&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Consistency& default_instance() {
    return *internal_default_instance();
  }
  enum RequirementCase {
    kMinimizeLatency = 1,
    kAtLeastAsFresh = 2,
    kAtExactSnapshot = 3,
    kFullyConsistent = 4,
    REQUIREMENT_NOT_SET = 0,
  };

  static inline const Consistency* internal_default_instance() {
    return reinterpret_cast<const Consistency*>(
               &_Consistency_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Consistency& a, Consistency& b) {
    a.Swap(&b);
  }
  inline void Swap(Consistency* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Consistency* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Consistency* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Consistency>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Consistency& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Consistency& from) {
    Consistency::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Consistency* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.Consistency";
  }
  protected:
  explicit Consistency(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinimizeLatencyFieldNumber = 1,
    kAtLeastAsFreshFieldNumber = 2,
    kAtExactSnapshotFieldNumber = 3,
    kFullyConsistentFieldNumber = 4,
  };
  // bool minimize_latency = 1 [json_name = "minimizeLatency", (.validate.rules) = {
  bool has_minimize_latency() const;
  private:
  bool _internal_has_minimize_latency() const;
  public:
  void clear_minimize_latency();
  bool minimize_latency() const;
  void set_minimize_latency(bool value);
  private:
  bool _internal_minimize_latency() const;
  void _internal_set_minimize_latency(bool value);
  public:

  // .authzed.api.v1.ZedToken at_least_as_fresh = 2 [json_name = "atLeastAsFresh"];
  bool has_at_least_as_fresh() const;
  private:
  bool _internal_has_at_least_as_fresh() const;
  public:
  void clear_at_least_as_fresh();
  const ::authzed::api::v1::ZedToken& at_least_as_fresh() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::ZedToken* release_at_least_as_fresh();
  ::authzed::api::v1::ZedToken* mutable_at_least_as_fresh();
  void set_allocated_at_least_as_fresh(::authzed::api::v1::ZedToken* at_least_as_fresh);
  private:
  const ::authzed::api::v1::ZedToken& _internal_at_least_as_fresh() const;
  ::authzed::api::v1::ZedToken* _internal_mutable_at_least_as_fresh();
  public:
  void unsafe_arena_set_allocated_at_least_as_fresh(
      ::authzed::api::v1::ZedToken* at_least_as_fresh);
  ::authzed::api::v1::ZedToken* unsafe_arena_release_at_least_as_fresh();

  // .authzed.api.v1.ZedToken at_exact_snapshot = 3 [json_name = "atExactSnapshot"];
  bool has_at_exact_snapshot() const;
  private:
  bool _internal_has_at_exact_snapshot() const;
  public:
  void clear_at_exact_snapshot();
  const ::authzed::api::v1::ZedToken& at_exact_snapshot() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::ZedToken* release_at_exact_snapshot();
  ::authzed::api::v1::ZedToken* mutable_at_exact_snapshot();
  void set_allocated_at_exact_snapshot(::authzed::api::v1::ZedToken* at_exact_snapshot);
  private:
  const ::authzed::api::v1::ZedToken& _internal_at_exact_snapshot() const;
  ::authzed::api::v1::ZedToken* _internal_mutable_at_exact_snapshot();
  public:
  void unsafe_arena_set_allocated_at_exact_snapshot(
      ::authzed::api::v1::ZedToken* at_exact_snapshot);
  ::authzed::api::v1::ZedToken* unsafe_arena_release_at_exact_snapshot();

  // bool fully_consistent = 4 [json_name = "fullyConsistent", (.validate.rules) = {
  bool has_fully_consistent() const;
  private:
  bool _internal_has_fully_consistent() const;
  public:
  void clear_fully_consistent();
  bool fully_consistent() const;
  void set_fully_consistent(bool value);
  private:
  bool _internal_fully_consistent() const;
  void _internal_set_fully_consistent(bool value);
  public:

  void clear_requirement();
  RequirementCase requirement_case() const;
  // @@protoc_insertion_point(class_scope:authzed.api.v1.Consistency)
 private:
  class _Internal;
  void set_has_minimize_latency();
  void set_has_at_least_as_fresh();
  void set_has_at_exact_snapshot();
  void set_has_fully_consistent();

  inline bool has_requirement() const;
  inline void clear_has_requirement();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union RequirementUnion {
      constexpr RequirementUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool minimize_latency_;
      ::authzed::api::v1::ZedToken* at_least_as_fresh_;
      ::authzed::api::v1::ZedToken* at_exact_snapshot_;
      bool fully_consistent_;
    } requirement_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fpermission_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RelationshipFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.RelationshipFilter) */ {
 public:
  inline RelationshipFilter() : RelationshipFilter(nullptr) {}
  ~RelationshipFilter() override;
  explicit PROTOBUF_CONSTEXPR RelationshipFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelationshipFilter(const RelationshipFilter& from);
  RelationshipFilter(RelationshipFilter&& from) noexcept
    : RelationshipFilter() {
    *this = ::std::move(from);
  }

  inline RelationshipFilter& operator=(const RelationshipFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelationshipFilter& operator=(RelationshipFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelationshipFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelationshipFilter* internal_default_instance() {
    return reinterpret_cast<const RelationshipFilter*>(
               &_RelationshipFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RelationshipFilter& a, RelationshipFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(RelationshipFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelationshipFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelationshipFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelationshipFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RelationshipFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RelationshipFilter& from) {
    RelationshipFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelationshipFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.RelationshipFilter";
  }
  protected:
  explicit RelationshipFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceTypeFieldNumber = 1,
    kOptionalResourceIdFieldNumber = 2,
    kOptionalRelationFieldNumber = 3,
    kOptionalSubjectFilterFieldNumber = 4,
  };
  // string resource_type = 1 [json_name = "resourceType", (.validate.rules) = {
  void clear_resource_type();
  const std::string& resource_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_type();
  PROTOBUF_NODISCARD std::string* release_resource_type();
  void set_allocated_resource_type(std::string* resource_type);
  private:
  const std::string& _internal_resource_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_type(const std::string& value);
  std::string* _internal_mutable_resource_type();
  public:

  // string optional_resource_id = 2 [json_name = "optionalResourceId", (.validate.rules) = {
  void clear_optional_resource_id();
  const std::string& optional_resource_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_optional_resource_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_optional_resource_id();
  PROTOBUF_NODISCARD std::string* release_optional_resource_id();
  void set_allocated_optional_resource_id(std::string* optional_resource_id);
  private:
  const std::string& _internal_optional_resource_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_optional_resource_id(const std::string& value);
  std::string* _internal_mutable_optional_resource_id();
  public:

  // string optional_relation = 3 [json_name = "optionalRelation", (.validate.rules) = {
  void clear_optional_relation();
  const std::string& optional_relation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_optional_relation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_optional_relation();
  PROTOBUF_NODISCARD std::string* release_optional_relation();
  void set_allocated_optional_relation(std::string* optional_relation);
  private:
  const std::string& _internal_optional_relation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_optional_relation(const std::string& value);
  std::string* _internal_mutable_optional_relation();
  public:

  // .authzed.api.v1.SubjectFilter optional_subject_filter = 4 [json_name = "optionalSubjectFilter"];
  bool has_optional_subject_filter() const;
  private:
  bool _internal_has_optional_subject_filter() const;
  public:
  void clear_optional_subject_filter();
  const ::authzed::api::v1::SubjectFilter& optional_subject_filter() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::SubjectFilter* release_optional_subject_filter();
  ::authzed::api::v1::SubjectFilter* mutable_optional_subject_filter();
  void set_allocated_optional_subject_filter(::authzed::api::v1::SubjectFilter* optional_subject_filter);
  private:
  const ::authzed::api::v1::SubjectFilter& _internal_optional_subject_filter() const;
  ::authzed::api::v1::SubjectFilter* _internal_mutable_optional_subject_filter();
  public:
  void unsafe_arena_set_allocated_optional_subject_filter(
      ::authzed::api::v1::SubjectFilter* optional_subject_filter);
  ::authzed::api::v1::SubjectFilter* unsafe_arena_release_optional_subject_filter();

  // @@protoc_insertion_point(class_scope:authzed.api.v1.RelationshipFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr optional_resource_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr optional_relation_;
    ::authzed::api::v1::SubjectFilter* optional_subject_filter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fpermission_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SubjectFilter_RelationFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.SubjectFilter.RelationFilter) */ {
 public:
  inline SubjectFilter_RelationFilter() : SubjectFilter_RelationFilter(nullptr) {}
  ~SubjectFilter_RelationFilter() override;
  explicit PROTOBUF_CONSTEXPR SubjectFilter_RelationFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubjectFilter_RelationFilter(const SubjectFilter_RelationFilter& from);
  SubjectFilter_RelationFilter(SubjectFilter_RelationFilter&& from) noexcept
    : SubjectFilter_RelationFilter() {
    *this = ::std::move(from);
  }

  inline SubjectFilter_RelationFilter& operator=(const SubjectFilter_RelationFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubjectFilter_RelationFilter& operator=(SubjectFilter_RelationFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubjectFilter_RelationFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubjectFilter_RelationFilter* internal_default_instance() {
    return reinterpret_cast<const SubjectFilter_RelationFilter*>(
               &_SubjectFilter_RelationFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SubjectFilter_RelationFilter& a, SubjectFilter_RelationFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(SubjectFilter_RelationFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubjectFilter_RelationFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubjectFilter_RelationFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubjectFilter_RelationFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubjectFilter_RelationFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubjectFilter_RelationFilter& from) {
    SubjectFilter_RelationFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubjectFilter_RelationFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.SubjectFilter.RelationFilter";
  }
  protected:
  explicit SubjectFilter_RelationFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRelationFieldNumber = 1,
  };
  // string relation = 1 [json_name = "relation", (.validate.rules) = {
  void clear_relation();
  const std::string& relation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_relation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_relation();
  PROTOBUF_NODISCARD std::string* release_relation();
  void set_allocated_relation(std::string* relation);
  private:
  const std::string& _internal_relation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relation(const std::string& value);
  std::string* _internal_mutable_relation();
  public:

  // @@protoc_insertion_point(class_scope:authzed.api.v1.SubjectFilter.RelationFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fpermission_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SubjectFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.SubjectFilter) */ {
 public:
  inline SubjectFilter() : SubjectFilter(nullptr) {}
  ~SubjectFilter() override;
  explicit PROTOBUF_CONSTEXPR SubjectFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubjectFilter(const SubjectFilter& from);
  SubjectFilter(SubjectFilter&& from) noexcept
    : SubjectFilter() {
    *this = ::std::move(from);
  }

  inline SubjectFilter& operator=(const SubjectFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubjectFilter& operator=(SubjectFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubjectFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubjectFilter* internal_default_instance() {
    return reinterpret_cast<const SubjectFilter*>(
               &_SubjectFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SubjectFilter& a, SubjectFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(SubjectFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubjectFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubjectFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubjectFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubjectFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubjectFilter& from) {
    SubjectFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubjectFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.SubjectFilter";
  }
  protected:
  explicit SubjectFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SubjectFilter_RelationFilter RelationFilter;

  // accessors -------------------------------------------------------

  enum : int {
    kSubjectTypeFieldNumber = 1,
    kOptionalSubjectIdFieldNumber = 2,
    kOptionalRelationFieldNumber = 3,
  };
  // string subject_type = 1 [json_name = "subjectType", (.validate.rules) = {
  void clear_subject_type();
  const std::string& subject_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subject_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subject_type();
  PROTOBUF_NODISCARD std::string* release_subject_type();
  void set_allocated_subject_type(std::string* subject_type);
  private:
  const std::string& _internal_subject_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject_type(const std::string& value);
  std::string* _internal_mutable_subject_type();
  public:

  // string optional_subject_id = 2 [json_name = "optionalSubjectId", (.validate.rules) = {
  void clear_optional_subject_id();
  const std::string& optional_subject_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_optional_subject_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_optional_subject_id();
  PROTOBUF_NODISCARD std::string* release_optional_subject_id();
  void set_allocated_optional_subject_id(std::string* optional_subject_id);
  private:
  const std::string& _internal_optional_subject_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_optional_subject_id(const std::string& value);
  std::string* _internal_mutable_optional_subject_id();
  public:

  // .authzed.api.v1.SubjectFilter.RelationFilter optional_relation = 3 [json_name = "optionalRelation"];
  bool has_optional_relation() const;
  private:
  bool _internal_has_optional_relation() const;
  public:
  void clear_optional_relation();
  const ::authzed::api::v1::SubjectFilter_RelationFilter& optional_relation() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::SubjectFilter_RelationFilter* release_optional_relation();
  ::authzed::api::v1::SubjectFilter_RelationFilter* mutable_optional_relation();
  void set_allocated_optional_relation(::authzed::api::v1::SubjectFilter_RelationFilter* optional_relation);
  private:
  const ::authzed::api::v1::SubjectFilter_RelationFilter& _internal_optional_relation() const;
  ::authzed::api::v1::SubjectFilter_RelationFilter* _internal_mutable_optional_relation();
  public:
  void unsafe_arena_set_allocated_optional_relation(
      ::authzed::api::v1::SubjectFilter_RelationFilter* optional_relation);
  ::authzed::api::v1::SubjectFilter_RelationFilter* unsafe_arena_release_optional_relation();

  // @@protoc_insertion_point(class_scope:authzed.api.v1.SubjectFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subject_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr optional_subject_id_;
    ::authzed::api::v1::SubjectFilter_RelationFilter* optional_relation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fpermission_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ReadRelationshipsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.ReadRelationshipsRequest) */ {
 public:
  inline ReadRelationshipsRequest() : ReadRelationshipsRequest(nullptr) {}
  ~ReadRelationshipsRequest() override;
  explicit PROTOBUF_CONSTEXPR ReadRelationshipsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadRelationshipsRequest(const ReadRelationshipsRequest& from);
  ReadRelationshipsRequest(ReadRelationshipsRequest&& from) noexcept
    : ReadRelationshipsRequest() {
    *this = ::std::move(from);
  }

  inline ReadRelationshipsRequest& operator=(const ReadRelationshipsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadRelationshipsRequest& operator=(ReadRelationshipsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadRelationshipsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadRelationshipsRequest* internal_default_instance() {
    return reinterpret_cast<const ReadRelationshipsRequest*>(
               &_ReadRelationshipsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ReadRelationshipsRequest& a, ReadRelationshipsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadRelationshipsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadRelationshipsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadRelationshipsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadRelationshipsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadRelationshipsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadRelationshipsRequest& from) {
    ReadRelationshipsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadRelationshipsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.ReadRelationshipsRequest";
  }
  protected:
  explicit ReadRelationshipsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConsistencyFieldNumber = 1,
    kRelationshipFilterFieldNumber = 2,
  };
  // .authzed.api.v1.Consistency consistency = 1 [json_name = "consistency"];
  bool has_consistency() const;
  private:
  bool _internal_has_consistency() const;
  public:
  void clear_consistency();
  const ::authzed::api::v1::Consistency& consistency() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::Consistency* release_consistency();
  ::authzed::api::v1::Consistency* mutable_consistency();
  void set_allocated_consistency(::authzed::api::v1::Consistency* consistency);
  private:
  const ::authzed::api::v1::Consistency& _internal_consistency() const;
  ::authzed::api::v1::Consistency* _internal_mutable_consistency();
  public:
  void unsafe_arena_set_allocated_consistency(
      ::authzed::api::v1::Consistency* consistency);
  ::authzed::api::v1::Consistency* unsafe_arena_release_consistency();

  // .authzed.api.v1.RelationshipFilter relationship_filter = 2 [json_name = "relationshipFilter", (.validate.rules) = {
  bool has_relationship_filter() const;
  private:
  bool _internal_has_relationship_filter() const;
  public:
  void clear_relationship_filter();
  const ::authzed::api::v1::RelationshipFilter& relationship_filter() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::RelationshipFilter* release_relationship_filter();
  ::authzed::api::v1::RelationshipFilter* mutable_relationship_filter();
  void set_allocated_relationship_filter(::authzed::api::v1::RelationshipFilter* relationship_filter);
  private:
  const ::authzed::api::v1::RelationshipFilter& _internal_relationship_filter() const;
  ::authzed::api::v1::RelationshipFilter* _internal_mutable_relationship_filter();
  public:
  void unsafe_arena_set_allocated_relationship_filter(
      ::authzed::api::v1::RelationshipFilter* relationship_filter);
  ::authzed::api::v1::RelationshipFilter* unsafe_arena_release_relationship_filter();

  // @@protoc_insertion_point(class_scope:authzed.api.v1.ReadRelationshipsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::authzed::api::v1::Consistency* consistency_;
    ::authzed::api::v1::RelationshipFilter* relationship_filter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fpermission_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ReadRelationshipsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.ReadRelationshipsResponse) */ {
 public:
  inline ReadRelationshipsResponse() : ReadRelationshipsResponse(nullptr) {}
  ~ReadRelationshipsResponse() override;
  explicit PROTOBUF_CONSTEXPR ReadRelationshipsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadRelationshipsResponse(const ReadRelationshipsResponse& from);
  ReadRelationshipsResponse(ReadRelationshipsResponse&& from) noexcept
    : ReadRelationshipsResponse() {
    *this = ::std::move(from);
  }

  inline ReadRelationshipsResponse& operator=(const ReadRelationshipsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadRelationshipsResponse& operator=(ReadRelationshipsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadRelationshipsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadRelationshipsResponse* internal_default_instance() {
    return reinterpret_cast<const ReadRelationshipsResponse*>(
               &_ReadRelationshipsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ReadRelationshipsResponse& a, ReadRelationshipsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadRelationshipsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadRelationshipsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadRelationshipsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadRelationshipsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadRelationshipsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadRelationshipsResponse& from) {
    ReadRelationshipsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadRelationshipsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.ReadRelationshipsResponse";
  }
  protected:
  explicit ReadRelationshipsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReadAtFieldNumber = 1,
    kRelationshipFieldNumber = 2,
  };
  // .authzed.api.v1.ZedToken read_at = 1 [json_name = "readAt", (.validate.rules) = {
  bool has_read_at() const;
  private:
  bool _internal_has_read_at() const;
  public:
  void clear_read_at();
  const ::authzed::api::v1::ZedToken& read_at() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::ZedToken* release_read_at();
  ::authzed::api::v1::ZedToken* mutable_read_at();
  void set_allocated_read_at(::authzed::api::v1::ZedToken* read_at);
  private:
  const ::authzed::api::v1::ZedToken& _internal_read_at() const;
  ::authzed::api::v1::ZedToken* _internal_mutable_read_at();
  public:
  void unsafe_arena_set_allocated_read_at(
      ::authzed::api::v1::ZedToken* read_at);
  ::authzed::api::v1::ZedToken* unsafe_arena_release_read_at();

  // .authzed.api.v1.Relationship relationship = 2 [json_name = "relationship", (.validate.rules) = {
  bool has_relationship() const;
  private:
  bool _internal_has_relationship() const;
  public:
  void clear_relationship();
  const ::authzed::api::v1::Relationship& relationship() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::Relationship* release_relationship();
  ::authzed::api::v1::Relationship* mutable_relationship();
  void set_allocated_relationship(::authzed::api::v1::Relationship* relationship);
  private:
  const ::authzed::api::v1::Relationship& _internal_relationship() const;
  ::authzed::api::v1::Relationship* _internal_mutable_relationship();
  public:
  void unsafe_arena_set_allocated_relationship(
      ::authzed::api::v1::Relationship* relationship);
  ::authzed::api::v1::Relationship* unsafe_arena_release_relationship();

  // @@protoc_insertion_point(class_scope:authzed.api.v1.ReadRelationshipsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::authzed::api::v1::ZedToken* read_at_;
    ::authzed::api::v1::Relationship* relationship_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fpermission_5fservice_2eproto;
};
// -------------------------------------------------------------------

class Precondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.Precondition) */ {
 public:
  inline Precondition() : Precondition(nullptr) {}
  ~Precondition() override;
  explicit PROTOBUF_CONSTEXPR Precondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Precondition(const Precondition& from);
  Precondition(Precondition&& from) noexcept
    : Precondition() {
    *this = ::std::move(from);
  }

  inline Precondition& operator=(const Precondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Precondition& operator=(Precondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Precondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const Precondition* internal_default_instance() {
    return reinterpret_cast<const Precondition*>(
               &_Precondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Precondition& a, Precondition& b) {
    a.Swap(&b);
  }
  inline void Swap(Precondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Precondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Precondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Precondition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Precondition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Precondition& from) {
    Precondition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Precondition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.Precondition";
  }
  protected:
  explicit Precondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Precondition_Operation Operation;
  static constexpr Operation OPERATION_UNSPECIFIED =
    Precondition_Operation_OPERATION_UNSPECIFIED;
  static constexpr Operation OPERATION_MUST_NOT_MATCH =
    Precondition_Operation_OPERATION_MUST_NOT_MATCH;
  static constexpr Operation OPERATION_MUST_MATCH =
    Precondition_Operation_OPERATION_MUST_MATCH;
  static inline bool Operation_IsValid(int value) {
    return Precondition_Operation_IsValid(value);
  }
  static constexpr Operation Operation_MIN =
    Precondition_Operation_Operation_MIN;
  static constexpr Operation Operation_MAX =
    Precondition_Operation_Operation_MAX;
  static constexpr int Operation_ARRAYSIZE =
    Precondition_Operation_Operation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Operation_descriptor() {
    return Precondition_Operation_descriptor();
  }
  template<typename T>
  static inline const std::string& Operation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Operation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Operation_Name.");
    return Precondition_Operation_Name(enum_t_value);
  }
  static inline bool Operation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Operation* value) {
    return Precondition_Operation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 2,
    kOperationFieldNumber = 1,
  };
  // .authzed.api.v1.RelationshipFilter filter = 2 [json_name = "filter", (.validate.rules) = {
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const ::authzed::api::v1::RelationshipFilter& filter() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::RelationshipFilter* release_filter();
  ::authzed::api::v1::RelationshipFilter* mutable_filter();
  void set_allocated_filter(::authzed::api::v1::RelationshipFilter* filter);
  private:
  const ::authzed::api::v1::RelationshipFilter& _internal_filter() const;
  ::authzed::api::v1::RelationshipFilter* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::authzed::api::v1::RelationshipFilter* filter);
  ::authzed::api::v1::RelationshipFilter* unsafe_arena_release_filter();

  // .authzed.api.v1.Precondition.Operation operation = 1 [json_name = "operation", (.validate.rules) = {
  void clear_operation();
  ::authzed::api::v1::Precondition_Operation operation() const;
  void set_operation(::authzed::api::v1::Precondition_Operation value);
  private:
  ::authzed::api::v1::Precondition_Operation _internal_operation() const;
  void _internal_set_operation(::authzed::api::v1::Precondition_Operation value);
  public:

  // @@protoc_insertion_point(class_scope:authzed.api.v1.Precondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::authzed::api::v1::RelationshipFilter* filter_;
    int operation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fpermission_5fservice_2eproto;
};
// -------------------------------------------------------------------

class WriteRelationshipsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.WriteRelationshipsRequest) */ {
 public:
  inline WriteRelationshipsRequest() : WriteRelationshipsRequest(nullptr) {}
  ~WriteRelationshipsRequest() override;
  explicit PROTOBUF_CONSTEXPR WriteRelationshipsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteRelationshipsRequest(const WriteRelationshipsRequest& from);
  WriteRelationshipsRequest(WriteRelationshipsRequest&& from) noexcept
    : WriteRelationshipsRequest() {
    *this = ::std::move(from);
  }

  inline WriteRelationshipsRequest& operator=(const WriteRelationshipsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteRelationshipsRequest& operator=(WriteRelationshipsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteRelationshipsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteRelationshipsRequest* internal_default_instance() {
    return reinterpret_cast<const WriteRelationshipsRequest*>(
               &_WriteRelationshipsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(WriteRelationshipsRequest& a, WriteRelationshipsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteRelationshipsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteRelationshipsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteRelationshipsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteRelationshipsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteRelationshipsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WriteRelationshipsRequest& from) {
    WriteRelationshipsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteRelationshipsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.WriteRelationshipsRequest";
  }
  protected:
  explicit WriteRelationshipsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpdatesFieldNumber = 1,
    kOptionalPreconditionsFieldNumber = 2,
  };
  // repeated .authzed.api.v1.RelationshipUpdate updates = 1 [json_name = "updates", (.validate.rules) = {
  int updates_size() const;
  private:
  int _internal_updates_size() const;
  public:
  void clear_updates();
  ::authzed::api::v1::RelationshipUpdate* mutable_updates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::RelationshipUpdate >*
      mutable_updates();
  private:
  const ::authzed::api::v1::RelationshipUpdate& _internal_updates(int index) const;
  ::authzed::api::v1::RelationshipUpdate* _internal_add_updates();
  public:
  const ::authzed::api::v1::RelationshipUpdate& updates(int index) const;
  ::authzed::api::v1::RelationshipUpdate* add_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::RelationshipUpdate >&
      updates() const;

  // repeated .authzed.api.v1.Precondition optional_preconditions = 2 [json_name = "optionalPreconditions", (.validate.rules) = {
  int optional_preconditions_size() const;
  private:
  int _internal_optional_preconditions_size() const;
  public:
  void clear_optional_preconditions();
  ::authzed::api::v1::Precondition* mutable_optional_preconditions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::Precondition >*
      mutable_optional_preconditions();
  private:
  const ::authzed::api::v1::Precondition& _internal_optional_preconditions(int index) const;
  ::authzed::api::v1::Precondition* _internal_add_optional_preconditions();
  public:
  const ::authzed::api::v1::Precondition& optional_preconditions(int index) const;
  ::authzed::api::v1::Precondition* add_optional_preconditions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::Precondition >&
      optional_preconditions() const;

  // @@protoc_insertion_point(class_scope:authzed.api.v1.WriteRelationshipsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::RelationshipUpdate > updates_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::Precondition > optional_preconditions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fpermission_5fservice_2eproto;
};
// -------------------------------------------------------------------

class WriteRelationshipsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.WriteRelationshipsResponse) */ {
 public:
  inline WriteRelationshipsResponse() : WriteRelationshipsResponse(nullptr) {}
  ~WriteRelationshipsResponse() override;
  explicit PROTOBUF_CONSTEXPR WriteRelationshipsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteRelationshipsResponse(const WriteRelationshipsResponse& from);
  WriteRelationshipsResponse(WriteRelationshipsResponse&& from) noexcept
    : WriteRelationshipsResponse() {
    *this = ::std::move(from);
  }

  inline WriteRelationshipsResponse& operator=(const WriteRelationshipsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteRelationshipsResponse& operator=(WriteRelationshipsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteRelationshipsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteRelationshipsResponse* internal_default_instance() {
    return reinterpret_cast<const WriteRelationshipsResponse*>(
               &_WriteRelationshipsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(WriteRelationshipsResponse& a, WriteRelationshipsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteRelationshipsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteRelationshipsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteRelationshipsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteRelationshipsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteRelationshipsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WriteRelationshipsResponse& from) {
    WriteRelationshipsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteRelationshipsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.WriteRelationshipsResponse";
  }
  protected:
  explicit WriteRelationshipsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWrittenAtFieldNumber = 1,
  };
  // .authzed.api.v1.ZedToken written_at = 1 [json_name = "writtenAt"];
  bool has_written_at() const;
  private:
  bool _internal_has_written_at() const;
  public:
  void clear_written_at();
  const ::authzed::api::v1::ZedToken& written_at() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::ZedToken* release_written_at();
  ::authzed::api::v1::ZedToken* mutable_written_at();
  void set_allocated_written_at(::authzed::api::v1::ZedToken* written_at);
  private:
  const ::authzed::api::v1::ZedToken& _internal_written_at() const;
  ::authzed::api::v1::ZedToken* _internal_mutable_written_at();
  public:
  void unsafe_arena_set_allocated_written_at(
      ::authzed::api::v1::ZedToken* written_at);
  ::authzed::api::v1::ZedToken* unsafe_arena_release_written_at();

  // @@protoc_insertion_point(class_scope:authzed.api.v1.WriteRelationshipsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::authzed::api::v1::ZedToken* written_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fpermission_5fservice_2eproto;
};
// -------------------------------------------------------------------

class DeleteRelationshipsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.DeleteRelationshipsRequest) */ {
 public:
  inline DeleteRelationshipsRequest() : DeleteRelationshipsRequest(nullptr) {}
  ~DeleteRelationshipsRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteRelationshipsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRelationshipsRequest(const DeleteRelationshipsRequest& from);
  DeleteRelationshipsRequest(DeleteRelationshipsRequest&& from) noexcept
    : DeleteRelationshipsRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRelationshipsRequest& operator=(const DeleteRelationshipsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRelationshipsRequest& operator=(DeleteRelationshipsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRelationshipsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRelationshipsRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRelationshipsRequest*>(
               &_DeleteRelationshipsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DeleteRelationshipsRequest& a, DeleteRelationshipsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRelationshipsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRelationshipsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRelationshipsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRelationshipsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRelationshipsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteRelationshipsRequest& from) {
    DeleteRelationshipsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRelationshipsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.DeleteRelationshipsRequest";
  }
  protected:
  explicit DeleteRelationshipsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionalPreconditionsFieldNumber = 2,
    kRelationshipFilterFieldNumber = 1,
  };
  // repeated .authzed.api.v1.Precondition optional_preconditions = 2 [json_name = "optionalPreconditions", (.validate.rules) = {
  int optional_preconditions_size() const;
  private:
  int _internal_optional_preconditions_size() const;
  public:
  void clear_optional_preconditions();
  ::authzed::api::v1::Precondition* mutable_optional_preconditions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::Precondition >*
      mutable_optional_preconditions();
  private:
  const ::authzed::api::v1::Precondition& _internal_optional_preconditions(int index) const;
  ::authzed::api::v1::Precondition* _internal_add_optional_preconditions();
  public:
  const ::authzed::api::v1::Precondition& optional_preconditions(int index) const;
  ::authzed::api::v1::Precondition* add_optional_preconditions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::Precondition >&
      optional_preconditions() const;

  // .authzed.api.v1.RelationshipFilter relationship_filter = 1 [json_name = "relationshipFilter", (.validate.rules) = {
  bool has_relationship_filter() const;
  private:
  bool _internal_has_relationship_filter() const;
  public:
  void clear_relationship_filter();
  const ::authzed::api::v1::RelationshipFilter& relationship_filter() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::RelationshipFilter* release_relationship_filter();
  ::authzed::api::v1::RelationshipFilter* mutable_relationship_filter();
  void set_allocated_relationship_filter(::authzed::api::v1::RelationshipFilter* relationship_filter);
  private:
  const ::authzed::api::v1::RelationshipFilter& _internal_relationship_filter() const;
  ::authzed::api::v1::RelationshipFilter* _internal_mutable_relationship_filter();
  public:
  void unsafe_arena_set_allocated_relationship_filter(
      ::authzed::api::v1::RelationshipFilter* relationship_filter);
  ::authzed::api::v1::RelationshipFilter* unsafe_arena_release_relationship_filter();

  // @@protoc_insertion_point(class_scope:authzed.api.v1.DeleteRelationshipsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::Precondition > optional_preconditions_;
    ::authzed::api::v1::RelationshipFilter* relationship_filter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fpermission_5fservice_2eproto;
};
// -------------------------------------------------------------------

class DeleteRelationshipsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.DeleteRelationshipsResponse) */ {
 public:
  inline DeleteRelationshipsResponse() : DeleteRelationshipsResponse(nullptr) {}
  ~DeleteRelationshipsResponse() override;
  explicit PROTOBUF_CONSTEXPR DeleteRelationshipsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRelationshipsResponse(const DeleteRelationshipsResponse& from);
  DeleteRelationshipsResponse(DeleteRelationshipsResponse&& from) noexcept
    : DeleteRelationshipsResponse() {
    *this = ::std::move(from);
  }

  inline DeleteRelationshipsResponse& operator=(const DeleteRelationshipsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRelationshipsResponse& operator=(DeleteRelationshipsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRelationshipsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRelationshipsResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteRelationshipsResponse*>(
               &_DeleteRelationshipsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DeleteRelationshipsResponse& a, DeleteRelationshipsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRelationshipsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRelationshipsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRelationshipsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRelationshipsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRelationshipsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteRelationshipsResponse& from) {
    DeleteRelationshipsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRelationshipsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.DeleteRelationshipsResponse";
  }
  protected:
  explicit DeleteRelationshipsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeletedAtFieldNumber = 1,
  };
  // .authzed.api.v1.ZedToken deleted_at = 1 [json_name = "deletedAt"];
  bool has_deleted_at() const;
  private:
  bool _internal_has_deleted_at() const;
  public:
  void clear_deleted_at();
  const ::authzed::api::v1::ZedToken& deleted_at() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::ZedToken* release_deleted_at();
  ::authzed::api::v1::ZedToken* mutable_deleted_at();
  void set_allocated_deleted_at(::authzed::api::v1::ZedToken* deleted_at);
  private:
  const ::authzed::api::v1::ZedToken& _internal_deleted_at() const;
  ::authzed::api::v1::ZedToken* _internal_mutable_deleted_at();
  public:
  void unsafe_arena_set_allocated_deleted_at(
      ::authzed::api::v1::ZedToken* deleted_at);
  ::authzed::api::v1::ZedToken* unsafe_arena_release_deleted_at();

  // @@protoc_insertion_point(class_scope:authzed.api.v1.DeleteRelationshipsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::authzed::api::v1::ZedToken* deleted_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fpermission_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CheckPermissionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.CheckPermissionRequest) */ {
 public:
  inline CheckPermissionRequest() : CheckPermissionRequest(nullptr) {}
  ~CheckPermissionRequest() override;
  explicit PROTOBUF_CONSTEXPR CheckPermissionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckPermissionRequest(const CheckPermissionRequest& from);
  CheckPermissionRequest(CheckPermissionRequest&& from) noexcept
    : CheckPermissionRequest() {
    *this = ::std::move(from);
  }

  inline CheckPermissionRequest& operator=(const CheckPermissionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckPermissionRequest& operator=(CheckPermissionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckPermissionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckPermissionRequest* internal_default_instance() {
    return reinterpret_cast<const CheckPermissionRequest*>(
               &_CheckPermissionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CheckPermissionRequest& a, CheckPermissionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckPermissionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckPermissionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckPermissionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckPermissionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckPermissionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CheckPermissionRequest& from) {
    CheckPermissionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckPermissionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.CheckPermissionRequest";
  }
  protected:
  explicit CheckPermissionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionFieldNumber = 3,
    kConsistencyFieldNumber = 1,
    kResourceFieldNumber = 2,
    kSubjectFieldNumber = 4,
    kContextFieldNumber = 5,
  };
  // string permission = 3 [json_name = "permission", (.validate.rules) = {
  void clear_permission();
  const std::string& permission() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_permission(ArgT0&& arg0, ArgT... args);
  std::string* mutable_permission();
  PROTOBUF_NODISCARD std::string* release_permission();
  void set_allocated_permission(std::string* permission);
  private:
  const std::string& _internal_permission() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_permission(const std::string& value);
  std::string* _internal_mutable_permission();
  public:

  // .authzed.api.v1.Consistency consistency = 1 [json_name = "consistency"];
  bool has_consistency() const;
  private:
  bool _internal_has_consistency() const;
  public:
  void clear_consistency();
  const ::authzed::api::v1::Consistency& consistency() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::Consistency* release_consistency();
  ::authzed::api::v1::Consistency* mutable_consistency();
  void set_allocated_consistency(::authzed::api::v1::Consistency* consistency);
  private:
  const ::authzed::api::v1::Consistency& _internal_consistency() const;
  ::authzed::api::v1::Consistency* _internal_mutable_consistency();
  public:
  void unsafe_arena_set_allocated_consistency(
      ::authzed::api::v1::Consistency* consistency);
  ::authzed::api::v1::Consistency* unsafe_arena_release_consistency();

  // .authzed.api.v1.ObjectReference resource = 2 [json_name = "resource", (.validate.rules) = {
  bool has_resource() const;
  private:
  bool _internal_has_resource() const;
  public:
  void clear_resource();
  const ::authzed::api::v1::ObjectReference& resource() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::ObjectReference* release_resource();
  ::authzed::api::v1::ObjectReference* mutable_resource();
  void set_allocated_resource(::authzed::api::v1::ObjectReference* resource);
  private:
  const ::authzed::api::v1::ObjectReference& _internal_resource() const;
  ::authzed::api::v1::ObjectReference* _internal_mutable_resource();
  public:
  void unsafe_arena_set_allocated_resource(
      ::authzed::api::v1::ObjectReference* resource);
  ::authzed::api::v1::ObjectReference* unsafe_arena_release_resource();

  // .authzed.api.v1.SubjectReference subject = 4 [json_name = "subject", (.validate.rules) = {
  bool has_subject() const;
  private:
  bool _internal_has_subject() const;
  public:
  void clear_subject();
  const ::authzed::api::v1::SubjectReference& subject() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::SubjectReference* release_subject();
  ::authzed::api::v1::SubjectReference* mutable_subject();
  void set_allocated_subject(::authzed::api::v1::SubjectReference* subject);
  private:
  const ::authzed::api::v1::SubjectReference& _internal_subject() const;
  ::authzed::api::v1::SubjectReference* _internal_mutable_subject();
  public:
  void unsafe_arena_set_allocated_subject(
      ::authzed::api::v1::SubjectReference* subject);
  ::authzed::api::v1::SubjectReference* unsafe_arena_release_subject();

  // .google.protobuf.Struct context = 5 [json_name = "context", (.validate.rules) = {
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::PROTOBUF_NAMESPACE_ID::Struct& context() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_context();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_context();
  void set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_context() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::PROTOBUF_NAMESPACE_ID::Struct* context);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_context();

  // @@protoc_insertion_point(class_scope:authzed.api.v1.CheckPermissionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr permission_;
    ::authzed::api::v1::Consistency* consistency_;
    ::authzed::api::v1::ObjectReference* resource_;
    ::authzed::api::v1::SubjectReference* subject_;
    ::PROTOBUF_NAMESPACE_ID::Struct* context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fpermission_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CheckPermissionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.CheckPermissionResponse) */ {
 public:
  inline CheckPermissionResponse() : CheckPermissionResponse(nullptr) {}
  ~CheckPermissionResponse() override;
  explicit PROTOBUF_CONSTEXPR CheckPermissionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckPermissionResponse(const CheckPermissionResponse& from);
  CheckPermissionResponse(CheckPermissionResponse&& from) noexcept
    : CheckPermissionResponse() {
    *this = ::std::move(from);
  }

  inline CheckPermissionResponse& operator=(const CheckPermissionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckPermissionResponse& operator=(CheckPermissionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckPermissionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckPermissionResponse* internal_default_instance() {
    return reinterpret_cast<const CheckPermissionResponse*>(
               &_CheckPermissionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CheckPermissionResponse& a, CheckPermissionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckPermissionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckPermissionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckPermissionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckPermissionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckPermissionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CheckPermissionResponse& from) {
    CheckPermissionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckPermissionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.CheckPermissionResponse";
  }
  protected:
  explicit CheckPermissionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CheckPermissionResponse_Permissionship Permissionship;
  static constexpr Permissionship PERMISSIONSHIP_UNSPECIFIED =
    CheckPermissionResponse_Permissionship_PERMISSIONSHIP_UNSPECIFIED;
  static constexpr Permissionship PERMISSIONSHIP_NO_PERMISSION =
    CheckPermissionResponse_Permissionship_PERMISSIONSHIP_NO_PERMISSION;
  static constexpr Permissionship PERMISSIONSHIP_HAS_PERMISSION =
    CheckPermissionResponse_Permissionship_PERMISSIONSHIP_HAS_PERMISSION;
  static constexpr Permissionship PERMISSIONSHIP_CONDITIONAL_PERMISSION =
    CheckPermissionResponse_Permissionship_PERMISSIONSHIP_CONDITIONAL_PERMISSION;
  static inline bool Permissionship_IsValid(int value) {
    return CheckPermissionResponse_Permissionship_IsValid(value);
  }
  static constexpr Permissionship Permissionship_MIN =
    CheckPermissionResponse_Permissionship_Permissionship_MIN;
  static constexpr Permissionship Permissionship_MAX =
    CheckPermissionResponse_Permissionship_Permissionship_MAX;
  static constexpr int Permissionship_ARRAYSIZE =
    CheckPermissionResponse_Permissionship_Permissionship_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Permissionship_descriptor() {
    return CheckPermissionResponse_Permissionship_descriptor();
  }
  template<typename T>
  static inline const std::string& Permissionship_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Permissionship>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Permissionship_Name.");
    return CheckPermissionResponse_Permissionship_Name(enum_t_value);
  }
  static inline bool Permissionship_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Permissionship* value) {
    return CheckPermissionResponse_Permissionship_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCheckedAtFieldNumber = 1,
    kPartialCaveatInfoFieldNumber = 3,
    kPermissionshipFieldNumber = 2,
  };
  // .authzed.api.v1.ZedToken checked_at = 1 [json_name = "checkedAt", (.validate.rules) = {
  bool has_checked_at() const;
  private:
  bool _internal_has_checked_at() const;
  public:
  void clear_checked_at();
  const ::authzed::api::v1::ZedToken& checked_at() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::ZedToken* release_checked_at();
  ::authzed::api::v1::ZedToken* mutable_checked_at();
  void set_allocated_checked_at(::authzed::api::v1::ZedToken* checked_at);
  private:
  const ::authzed::api::v1::ZedToken& _internal_checked_at() const;
  ::authzed::api::v1::ZedToken* _internal_mutable_checked_at();
  public:
  void unsafe_arena_set_allocated_checked_at(
      ::authzed::api::v1::ZedToken* checked_at);
  ::authzed::api::v1::ZedToken* unsafe_arena_release_checked_at();

  // .authzed.api.v1.PartialCaveatInfo partial_caveat_info = 3 [json_name = "partialCaveatInfo", (.validate.rules) = {
  bool has_partial_caveat_info() const;
  private:
  bool _internal_has_partial_caveat_info() const;
  public:
  void clear_partial_caveat_info();
  const ::authzed::api::v1::PartialCaveatInfo& partial_caveat_info() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::PartialCaveatInfo* release_partial_caveat_info();
  ::authzed::api::v1::PartialCaveatInfo* mutable_partial_caveat_info();
  void set_allocated_partial_caveat_info(::authzed::api::v1::PartialCaveatInfo* partial_caveat_info);
  private:
  const ::authzed::api::v1::PartialCaveatInfo& _internal_partial_caveat_info() const;
  ::authzed::api::v1::PartialCaveatInfo* _internal_mutable_partial_caveat_info();
  public:
  void unsafe_arena_set_allocated_partial_caveat_info(
      ::authzed::api::v1::PartialCaveatInfo* partial_caveat_info);
  ::authzed::api::v1::PartialCaveatInfo* unsafe_arena_release_partial_caveat_info();

  // .authzed.api.v1.CheckPermissionResponse.Permissionship permissionship = 2 [json_name = "permissionship", (.validate.rules) = {
  void clear_permissionship();
  ::authzed::api::v1::CheckPermissionResponse_Permissionship permissionship() const;
  void set_permissionship(::authzed::api::v1::CheckPermissionResponse_Permissionship value);
  private:
  ::authzed::api::v1::CheckPermissionResponse_Permissionship _internal_permissionship() const;
  void _internal_set_permissionship(::authzed::api::v1::CheckPermissionResponse_Permissionship value);
  public:

  // @@protoc_insertion_point(class_scope:authzed.api.v1.CheckPermissionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::authzed::api::v1::ZedToken* checked_at_;
    ::authzed::api::v1::PartialCaveatInfo* partial_caveat_info_;
    int permissionship_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fpermission_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ExpandPermissionTreeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.ExpandPermissionTreeRequest) */ {
 public:
  inline ExpandPermissionTreeRequest() : ExpandPermissionTreeRequest(nullptr) {}
  ~ExpandPermissionTreeRequest() override;
  explicit PROTOBUF_CONSTEXPR ExpandPermissionTreeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExpandPermissionTreeRequest(const ExpandPermissionTreeRequest& from);
  ExpandPermissionTreeRequest(ExpandPermissionTreeRequest&& from) noexcept
    : ExpandPermissionTreeRequest() {
    *this = ::std::move(from);
  }

  inline ExpandPermissionTreeRequest& operator=(const ExpandPermissionTreeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpandPermissionTreeRequest& operator=(ExpandPermissionTreeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpandPermissionTreeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExpandPermissionTreeRequest* internal_default_instance() {
    return reinterpret_cast<const ExpandPermissionTreeRequest*>(
               &_ExpandPermissionTreeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ExpandPermissionTreeRequest& a, ExpandPermissionTreeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExpandPermissionTreeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpandPermissionTreeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpandPermissionTreeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExpandPermissionTreeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExpandPermissionTreeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExpandPermissionTreeRequest& from) {
    ExpandPermissionTreeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExpandPermissionTreeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.ExpandPermissionTreeRequest";
  }
  protected:
  explicit ExpandPermissionTreeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionFieldNumber = 3,
    kConsistencyFieldNumber = 1,
    kResourceFieldNumber = 2,
  };
  // string permission = 3 [json_name = "permission", (.validate.rules) = {
  void clear_permission();
  const std::string& permission() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_permission(ArgT0&& arg0, ArgT... args);
  std::string* mutable_permission();
  PROTOBUF_NODISCARD std::string* release_permission();
  void set_allocated_permission(std::string* permission);
  private:
  const std::string& _internal_permission() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_permission(const std::string& value);
  std::string* _internal_mutable_permission();
  public:

  // .authzed.api.v1.Consistency consistency = 1 [json_name = "consistency"];
  bool has_consistency() const;
  private:
  bool _internal_has_consistency() const;
  public:
  void clear_consistency();
  const ::authzed::api::v1::Consistency& consistency() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::Consistency* release_consistency();
  ::authzed::api::v1::Consistency* mutable_consistency();
  void set_allocated_consistency(::authzed::api::v1::Consistency* consistency);
  private:
  const ::authzed::api::v1::Consistency& _internal_consistency() const;
  ::authzed::api::v1::Consistency* _internal_mutable_consistency();
  public:
  void unsafe_arena_set_allocated_consistency(
      ::authzed::api::v1::Consistency* consistency);
  ::authzed::api::v1::Consistency* unsafe_arena_release_consistency();

  // .authzed.api.v1.ObjectReference resource = 2 [json_name = "resource", (.validate.rules) = {
  bool has_resource() const;
  private:
  bool _internal_has_resource() const;
  public:
  void clear_resource();
  const ::authzed::api::v1::ObjectReference& resource() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::ObjectReference* release_resource();
  ::authzed::api::v1::ObjectReference* mutable_resource();
  void set_allocated_resource(::authzed::api::v1::ObjectReference* resource);
  private:
  const ::authzed::api::v1::ObjectReference& _internal_resource() const;
  ::authzed::api::v1::ObjectReference* _internal_mutable_resource();
  public:
  void unsafe_arena_set_allocated_resource(
      ::authzed::api::v1::ObjectReference* resource);
  ::authzed::api::v1::ObjectReference* unsafe_arena_release_resource();

  // @@protoc_insertion_point(class_scope:authzed.api.v1.ExpandPermissionTreeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr permission_;
    ::authzed::api::v1::Consistency* consistency_;
    ::authzed::api::v1::ObjectReference* resource_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fpermission_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ExpandPermissionTreeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.ExpandPermissionTreeResponse) */ {
 public:
  inline ExpandPermissionTreeResponse() : ExpandPermissionTreeResponse(nullptr) {}
  ~ExpandPermissionTreeResponse() override;
  explicit PROTOBUF_CONSTEXPR ExpandPermissionTreeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExpandPermissionTreeResponse(const ExpandPermissionTreeResponse& from);
  ExpandPermissionTreeResponse(ExpandPermissionTreeResponse&& from) noexcept
    : ExpandPermissionTreeResponse() {
    *this = ::std::move(from);
  }

  inline ExpandPermissionTreeResponse& operator=(const ExpandPermissionTreeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpandPermissionTreeResponse& operator=(ExpandPermissionTreeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpandPermissionTreeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExpandPermissionTreeResponse* internal_default_instance() {
    return reinterpret_cast<const ExpandPermissionTreeResponse*>(
               &_ExpandPermissionTreeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ExpandPermissionTreeResponse& a, ExpandPermissionTreeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExpandPermissionTreeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpandPermissionTreeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpandPermissionTreeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExpandPermissionTreeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExpandPermissionTreeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExpandPermissionTreeResponse& from) {
    ExpandPermissionTreeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExpandPermissionTreeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.ExpandPermissionTreeResponse";
  }
  protected:
  explicit ExpandPermissionTreeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExpandedAtFieldNumber = 1,
    kTreeRootFieldNumber = 2,
  };
  // .authzed.api.v1.ZedToken expanded_at = 1 [json_name = "expandedAt"];
  bool has_expanded_at() const;
  private:
  bool _internal_has_expanded_at() const;
  public:
  void clear_expanded_at();
  const ::authzed::api::v1::ZedToken& expanded_at() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::ZedToken* release_expanded_at();
  ::authzed::api::v1::ZedToken* mutable_expanded_at();
  void set_allocated_expanded_at(::authzed::api::v1::ZedToken* expanded_at);
  private:
  const ::authzed::api::v1::ZedToken& _internal_expanded_at() const;
  ::authzed::api::v1::ZedToken* _internal_mutable_expanded_at();
  public:
  void unsafe_arena_set_allocated_expanded_at(
      ::authzed::api::v1::ZedToken* expanded_at);
  ::authzed::api::v1::ZedToken* unsafe_arena_release_expanded_at();

  // .authzed.api.v1.PermissionRelationshipTree tree_root = 2 [json_name = "treeRoot"];
  bool has_tree_root() const;
  private:
  bool _internal_has_tree_root() const;
  public:
  void clear_tree_root();
  const ::authzed::api::v1::PermissionRelationshipTree& tree_root() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::PermissionRelationshipTree* release_tree_root();
  ::authzed::api::v1::PermissionRelationshipTree* mutable_tree_root();
  void set_allocated_tree_root(::authzed::api::v1::PermissionRelationshipTree* tree_root);
  private:
  const ::authzed::api::v1::PermissionRelationshipTree& _internal_tree_root() const;
  ::authzed::api::v1::PermissionRelationshipTree* _internal_mutable_tree_root();
  public:
  void unsafe_arena_set_allocated_tree_root(
      ::authzed::api::v1::PermissionRelationshipTree* tree_root);
  ::authzed::api::v1::PermissionRelationshipTree* unsafe_arena_release_tree_root();

  // @@protoc_insertion_point(class_scope:authzed.api.v1.ExpandPermissionTreeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::authzed::api::v1::ZedToken* expanded_at_;
    ::authzed::api::v1::PermissionRelationshipTree* tree_root_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fpermission_5fservice_2eproto;
};
// -------------------------------------------------------------------

class LookupResourcesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.LookupResourcesRequest) */ {
 public:
  inline LookupResourcesRequest() : LookupResourcesRequest(nullptr) {}
  ~LookupResourcesRequest() override;
  explicit PROTOBUF_CONSTEXPR LookupResourcesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LookupResourcesRequest(const LookupResourcesRequest& from);
  LookupResourcesRequest(LookupResourcesRequest&& from) noexcept
    : LookupResourcesRequest() {
    *this = ::std::move(from);
  }

  inline LookupResourcesRequest& operator=(const LookupResourcesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LookupResourcesRequest& operator=(LookupResourcesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LookupResourcesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LookupResourcesRequest* internal_default_instance() {
    return reinterpret_cast<const LookupResourcesRequest*>(
               &_LookupResourcesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(LookupResourcesRequest& a, LookupResourcesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LookupResourcesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LookupResourcesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LookupResourcesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LookupResourcesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LookupResourcesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LookupResourcesRequest& from) {
    LookupResourcesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LookupResourcesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.LookupResourcesRequest";
  }
  protected:
  explicit LookupResourcesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceObjectTypeFieldNumber = 2,
    kPermissionFieldNumber = 3,
    kConsistencyFieldNumber = 1,
    kSubjectFieldNumber = 4,
    kContextFieldNumber = 5,
  };
  // string resource_object_type = 2 [json_name = "resourceObjectType", (.validate.rules) = {
  void clear_resource_object_type();
  const std::string& resource_object_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_object_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_object_type();
  PROTOBUF_NODISCARD std::string* release_resource_object_type();
  void set_allocated_resource_object_type(std::string* resource_object_type);
  private:
  const std::string& _internal_resource_object_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_object_type(const std::string& value);
  std::string* _internal_mutable_resource_object_type();
  public:

  // string permission = 3 [json_name = "permission", (.validate.rules) = {
  void clear_permission();
  const std::string& permission() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_permission(ArgT0&& arg0, ArgT... args);
  std::string* mutable_permission();
  PROTOBUF_NODISCARD std::string* release_permission();
  void set_allocated_permission(std::string* permission);
  private:
  const std::string& _internal_permission() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_permission(const std::string& value);
  std::string* _internal_mutable_permission();
  public:

  // .authzed.api.v1.Consistency consistency = 1 [json_name = "consistency"];
  bool has_consistency() const;
  private:
  bool _internal_has_consistency() const;
  public:
  void clear_consistency();
  const ::authzed::api::v1::Consistency& consistency() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::Consistency* release_consistency();
  ::authzed::api::v1::Consistency* mutable_consistency();
  void set_allocated_consistency(::authzed::api::v1::Consistency* consistency);
  private:
  const ::authzed::api::v1::Consistency& _internal_consistency() const;
  ::authzed::api::v1::Consistency* _internal_mutable_consistency();
  public:
  void unsafe_arena_set_allocated_consistency(
      ::authzed::api::v1::Consistency* consistency);
  ::authzed::api::v1::Consistency* unsafe_arena_release_consistency();

  // .authzed.api.v1.SubjectReference subject = 4 [json_name = "subject", (.validate.rules) = {
  bool has_subject() const;
  private:
  bool _internal_has_subject() const;
  public:
  void clear_subject();
  const ::authzed::api::v1::SubjectReference& subject() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::SubjectReference* release_subject();
  ::authzed::api::v1::SubjectReference* mutable_subject();
  void set_allocated_subject(::authzed::api::v1::SubjectReference* subject);
  private:
  const ::authzed::api::v1::SubjectReference& _internal_subject() const;
  ::authzed::api::v1::SubjectReference* _internal_mutable_subject();
  public:
  void unsafe_arena_set_allocated_subject(
      ::authzed::api::v1::SubjectReference* subject);
  ::authzed::api::v1::SubjectReference* unsafe_arena_release_subject();

  // .google.protobuf.Struct context = 5 [json_name = "context", (.validate.rules) = {
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::PROTOBUF_NAMESPACE_ID::Struct& context() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_context();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_context();
  void set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_context() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::PROTOBUF_NAMESPACE_ID::Struct* context);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_context();

  // @@protoc_insertion_point(class_scope:authzed.api.v1.LookupResourcesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_object_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr permission_;
    ::authzed::api::v1::Consistency* consistency_;
    ::authzed::api::v1::SubjectReference* subject_;
    ::PROTOBUF_NAMESPACE_ID::Struct* context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fpermission_5fservice_2eproto;
};
// -------------------------------------------------------------------

class LookupResourcesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.LookupResourcesResponse) */ {
 public:
  inline LookupResourcesResponse() : LookupResourcesResponse(nullptr) {}
  ~LookupResourcesResponse() override;
  explicit PROTOBUF_CONSTEXPR LookupResourcesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LookupResourcesResponse(const LookupResourcesResponse& from);
  LookupResourcesResponse(LookupResourcesResponse&& from) noexcept
    : LookupResourcesResponse() {
    *this = ::std::move(from);
  }

  inline LookupResourcesResponse& operator=(const LookupResourcesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LookupResourcesResponse& operator=(LookupResourcesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LookupResourcesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LookupResourcesResponse* internal_default_instance() {
    return reinterpret_cast<const LookupResourcesResponse*>(
               &_LookupResourcesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(LookupResourcesResponse& a, LookupResourcesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LookupResourcesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LookupResourcesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LookupResourcesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LookupResourcesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LookupResourcesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LookupResourcesResponse& from) {
    LookupResourcesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LookupResourcesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.LookupResourcesResponse";
  }
  protected:
  explicit LookupResourcesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceObjectIdFieldNumber = 2,
    kLookedUpAtFieldNumber = 1,
    kPartialCaveatInfoFieldNumber = 4,
    kPermissionshipFieldNumber = 3,
  };
  // string resource_object_id = 2 [json_name = "resourceObjectId"];
  void clear_resource_object_id();
  const std::string& resource_object_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_object_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_object_id();
  PROTOBUF_NODISCARD std::string* release_resource_object_id();
  void set_allocated_resource_object_id(std::string* resource_object_id);
  private:
  const std::string& _internal_resource_object_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_object_id(const std::string& value);
  std::string* _internal_mutable_resource_object_id();
  public:

  // .authzed.api.v1.ZedToken looked_up_at = 1 [json_name = "lookedUpAt"];
  bool has_looked_up_at() const;
  private:
  bool _internal_has_looked_up_at() const;
  public:
  void clear_looked_up_at();
  const ::authzed::api::v1::ZedToken& looked_up_at() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::ZedToken* release_looked_up_at();
  ::authzed::api::v1::ZedToken* mutable_looked_up_at();
  void set_allocated_looked_up_at(::authzed::api::v1::ZedToken* looked_up_at);
  private:
  const ::authzed::api::v1::ZedToken& _internal_looked_up_at() const;
  ::authzed::api::v1::ZedToken* _internal_mutable_looked_up_at();
  public:
  void unsafe_arena_set_allocated_looked_up_at(
      ::authzed::api::v1::ZedToken* looked_up_at);
  ::authzed::api::v1::ZedToken* unsafe_arena_release_looked_up_at();

  // .authzed.api.v1.PartialCaveatInfo partial_caveat_info = 4 [json_name = "partialCaveatInfo", (.validate.rules) = {
  bool has_partial_caveat_info() const;
  private:
  bool _internal_has_partial_caveat_info() const;
  public:
  void clear_partial_caveat_info();
  const ::authzed::api::v1::PartialCaveatInfo& partial_caveat_info() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::PartialCaveatInfo* release_partial_caveat_info();
  ::authzed::api::v1::PartialCaveatInfo* mutable_partial_caveat_info();
  void set_allocated_partial_caveat_info(::authzed::api::v1::PartialCaveatInfo* partial_caveat_info);
  private:
  const ::authzed::api::v1::PartialCaveatInfo& _internal_partial_caveat_info() const;
  ::authzed::api::v1::PartialCaveatInfo* _internal_mutable_partial_caveat_info();
  public:
  void unsafe_arena_set_allocated_partial_caveat_info(
      ::authzed::api::v1::PartialCaveatInfo* partial_caveat_info);
  ::authzed::api::v1::PartialCaveatInfo* unsafe_arena_release_partial_caveat_info();

  // .authzed.api.v1.LookupPermissionship permissionship = 3 [json_name = "permissionship", (.validate.rules) = {
  void clear_permissionship();
  ::authzed::api::v1::LookupPermissionship permissionship() const;
  void set_permissionship(::authzed::api::v1::LookupPermissionship value);
  private:
  ::authzed::api::v1::LookupPermissionship _internal_permissionship() const;
  void _internal_set_permissionship(::authzed::api::v1::LookupPermissionship value);
  public:

  // @@protoc_insertion_point(class_scope:authzed.api.v1.LookupResourcesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_object_id_;
    ::authzed::api::v1::ZedToken* looked_up_at_;
    ::authzed::api::v1::PartialCaveatInfo* partial_caveat_info_;
    int permissionship_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fpermission_5fservice_2eproto;
};
// -------------------------------------------------------------------

class LookupSubjectsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.LookupSubjectsRequest) */ {
 public:
  inline LookupSubjectsRequest() : LookupSubjectsRequest(nullptr) {}
  ~LookupSubjectsRequest() override;
  explicit PROTOBUF_CONSTEXPR LookupSubjectsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LookupSubjectsRequest(const LookupSubjectsRequest& from);
  LookupSubjectsRequest(LookupSubjectsRequest&& from) noexcept
    : LookupSubjectsRequest() {
    *this = ::std::move(from);
  }

  inline LookupSubjectsRequest& operator=(const LookupSubjectsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LookupSubjectsRequest& operator=(LookupSubjectsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LookupSubjectsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LookupSubjectsRequest* internal_default_instance() {
    return reinterpret_cast<const LookupSubjectsRequest*>(
               &_LookupSubjectsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(LookupSubjectsRequest& a, LookupSubjectsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LookupSubjectsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LookupSubjectsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LookupSubjectsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LookupSubjectsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LookupSubjectsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LookupSubjectsRequest& from) {
    LookupSubjectsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LookupSubjectsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.LookupSubjectsRequest";
  }
  protected:
  explicit LookupSubjectsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionFieldNumber = 3,
    kSubjectObjectTypeFieldNumber = 4,
    kOptionalSubjectRelationFieldNumber = 5,
    kConsistencyFieldNumber = 1,
    kResourceFieldNumber = 2,
    kContextFieldNumber = 6,
  };
  // string permission = 3 [json_name = "permission", (.validate.rules) = {
  void clear_permission();
  const std::string& permission() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_permission(ArgT0&& arg0, ArgT... args);
  std::string* mutable_permission();
  PROTOBUF_NODISCARD std::string* release_permission();
  void set_allocated_permission(std::string* permission);
  private:
  const std::string& _internal_permission() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_permission(const std::string& value);
  std::string* _internal_mutable_permission();
  public:

  // string subject_object_type = 4 [json_name = "subjectObjectType", (.validate.rules) = {
  void clear_subject_object_type();
  const std::string& subject_object_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subject_object_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subject_object_type();
  PROTOBUF_NODISCARD std::string* release_subject_object_type();
  void set_allocated_subject_object_type(std::string* subject_object_type);
  private:
  const std::string& _internal_subject_object_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject_object_type(const std::string& value);
  std::string* _internal_mutable_subject_object_type();
  public:

  // string optional_subject_relation = 5 [json_name = "optionalSubjectRelation", (.validate.rules) = {
  void clear_optional_subject_relation();
  const std::string& optional_subject_relation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_optional_subject_relation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_optional_subject_relation();
  PROTOBUF_NODISCARD std::string* release_optional_subject_relation();
  void set_allocated_optional_subject_relation(std::string* optional_subject_relation);
  private:
  const std::string& _internal_optional_subject_relation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_optional_subject_relation(const std::string& value);
  std::string* _internal_mutable_optional_subject_relation();
  public:

  // .authzed.api.v1.Consistency consistency = 1 [json_name = "consistency"];
  bool has_consistency() const;
  private:
  bool _internal_has_consistency() const;
  public:
  void clear_consistency();
  const ::authzed::api::v1::Consistency& consistency() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::Consistency* release_consistency();
  ::authzed::api::v1::Consistency* mutable_consistency();
  void set_allocated_consistency(::authzed::api::v1::Consistency* consistency);
  private:
  const ::authzed::api::v1::Consistency& _internal_consistency() const;
  ::authzed::api::v1::Consistency* _internal_mutable_consistency();
  public:
  void unsafe_arena_set_allocated_consistency(
      ::authzed::api::v1::Consistency* consistency);
  ::authzed::api::v1::Consistency* unsafe_arena_release_consistency();

  // .authzed.api.v1.ObjectReference resource = 2 [json_name = "resource", (.validate.rules) = {
  bool has_resource() const;
  private:
  bool _internal_has_resource() const;
  public:
  void clear_resource();
  const ::authzed::api::v1::ObjectReference& resource() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::ObjectReference* release_resource();
  ::authzed::api::v1::ObjectReference* mutable_resource();
  void set_allocated_resource(::authzed::api::v1::ObjectReference* resource);
  private:
  const ::authzed::api::v1::ObjectReference& _internal_resource() const;
  ::authzed::api::v1::ObjectReference* _internal_mutable_resource();
  public:
  void unsafe_arena_set_allocated_resource(
      ::authzed::api::v1::ObjectReference* resource);
  ::authzed::api::v1::ObjectReference* unsafe_arena_release_resource();

  // .google.protobuf.Struct context = 6 [json_name = "context", (.validate.rules) = {
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::PROTOBUF_NAMESPACE_ID::Struct& context() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_context();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_context();
  void set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_context() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::PROTOBUF_NAMESPACE_ID::Struct* context);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_context();

  // @@protoc_insertion_point(class_scope:authzed.api.v1.LookupSubjectsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr permission_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subject_object_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr optional_subject_relation_;
    ::authzed::api::v1::Consistency* consistency_;
    ::authzed::api::v1::ObjectReference* resource_;
    ::PROTOBUF_NAMESPACE_ID::Struct* context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fpermission_5fservice_2eproto;
};
// -------------------------------------------------------------------

class LookupSubjectsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.LookupSubjectsResponse) */ {
 public:
  inline LookupSubjectsResponse() : LookupSubjectsResponse(nullptr) {}
  ~LookupSubjectsResponse() override;
  explicit PROTOBUF_CONSTEXPR LookupSubjectsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LookupSubjectsResponse(const LookupSubjectsResponse& from);
  LookupSubjectsResponse(LookupSubjectsResponse&& from) noexcept
    : LookupSubjectsResponse() {
    *this = ::std::move(from);
  }

  inline LookupSubjectsResponse& operator=(const LookupSubjectsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LookupSubjectsResponse& operator=(LookupSubjectsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LookupSubjectsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LookupSubjectsResponse* internal_default_instance() {
    return reinterpret_cast<const LookupSubjectsResponse*>(
               &_LookupSubjectsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(LookupSubjectsResponse& a, LookupSubjectsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LookupSubjectsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LookupSubjectsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LookupSubjectsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LookupSubjectsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LookupSubjectsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LookupSubjectsResponse& from) {
    LookupSubjectsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LookupSubjectsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.LookupSubjectsResponse";
  }
  protected:
  explicit LookupSubjectsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExcludedSubjectIdsFieldNumber = 3,
    kExcludedSubjectsFieldNumber = 7,
    kSubjectObjectIdFieldNumber = 2,
    kLookedUpAtFieldNumber = 1,
    kPartialCaveatInfoFieldNumber = 5,
    kSubjectFieldNumber = 6,
    kPermissionshipFieldNumber = 4,
  };
  // repeated string excluded_subject_ids = 3 [json_name = "excludedSubjectIds", deprecated = true];
  PROTOBUF_DEPRECATED int excluded_subject_ids_size() const;
  private:
  int _internal_excluded_subject_ids_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_excluded_subject_ids();
  PROTOBUF_DEPRECATED const std::string& excluded_subject_ids(int index) const;
  PROTOBUF_DEPRECATED std::string* mutable_excluded_subject_ids(int index);
  PROTOBUF_DEPRECATED void set_excluded_subject_ids(int index, const std::string& value);
  PROTOBUF_DEPRECATED void set_excluded_subject_ids(int index, std::string&& value);
  PROTOBUF_DEPRECATED void set_excluded_subject_ids(int index, const char* value);
  PROTOBUF_DEPRECATED void set_excluded_subject_ids(int index, const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* add_excluded_subject_ids();
  PROTOBUF_DEPRECATED void add_excluded_subject_ids(const std::string& value);
  PROTOBUF_DEPRECATED void add_excluded_subject_ids(std::string&& value);
  PROTOBUF_DEPRECATED void add_excluded_subject_ids(const char* value);
  PROTOBUF_DEPRECATED void add_excluded_subject_ids(const char* value, size_t size);
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& excluded_subject_ids() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_excluded_subject_ids();
  private:
  const std::string& _internal_excluded_subject_ids(int index) const;
  std::string* _internal_add_excluded_subject_ids();
  public:

  // repeated .authzed.api.v1.ResolvedSubject excluded_subjects = 7 [json_name = "excludedSubjects"];
  int excluded_subjects_size() const;
  private:
  int _internal_excluded_subjects_size() const;
  public:
  void clear_excluded_subjects();
  ::authzed::api::v1::ResolvedSubject* mutable_excluded_subjects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::ResolvedSubject >*
      mutable_excluded_subjects();
  private:
  const ::authzed::api::v1::ResolvedSubject& _internal_excluded_subjects(int index) const;
  ::authzed::api::v1::ResolvedSubject* _internal_add_excluded_subjects();
  public:
  const ::authzed::api::v1::ResolvedSubject& excluded_subjects(int index) const;
  ::authzed::api::v1::ResolvedSubject* add_excluded_subjects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::ResolvedSubject >&
      excluded_subjects() const;

  // string subject_object_id = 2 [json_name = "subjectObjectId", deprecated = true];
  PROTOBUF_DEPRECATED void clear_subject_object_id();
  PROTOBUF_DEPRECATED const std::string& subject_object_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_subject_object_id(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_subject_object_id();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_subject_object_id();
  PROTOBUF_DEPRECATED void set_allocated_subject_object_id(std::string* subject_object_id);
  private:
  const std::string& _internal_subject_object_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject_object_id(const std::string& value);
  std::string* _internal_mutable_subject_object_id();
  public:

  // .authzed.api.v1.ZedToken looked_up_at = 1 [json_name = "lookedUpAt"];
  bool has_looked_up_at() const;
  private:
  bool _internal_has_looked_up_at() const;
  public:
  void clear_looked_up_at();
  const ::authzed::api::v1::ZedToken& looked_up_at() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::ZedToken* release_looked_up_at();
  ::authzed::api::v1::ZedToken* mutable_looked_up_at();
  void set_allocated_looked_up_at(::authzed::api::v1::ZedToken* looked_up_at);
  private:
  const ::authzed::api::v1::ZedToken& _internal_looked_up_at() const;
  ::authzed::api::v1::ZedToken* _internal_mutable_looked_up_at();
  public:
  void unsafe_arena_set_allocated_looked_up_at(
      ::authzed::api::v1::ZedToken* looked_up_at);
  ::authzed::api::v1::ZedToken* unsafe_arena_release_looked_up_at();

  // .authzed.api.v1.PartialCaveatInfo partial_caveat_info = 5 [json_name = "partialCaveatInfo", deprecated = true, (.validate.rules) = {
  PROTOBUF_DEPRECATED bool has_partial_caveat_info() const;
  private:
  bool _internal_has_partial_caveat_info() const;
  public:
  PROTOBUF_DEPRECATED void clear_partial_caveat_info();
  PROTOBUF_DEPRECATED const ::authzed::api::v1::PartialCaveatInfo& partial_caveat_info() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::authzed::api::v1::PartialCaveatInfo* release_partial_caveat_info();
  PROTOBUF_DEPRECATED ::authzed::api::v1::PartialCaveatInfo* mutable_partial_caveat_info();
  PROTOBUF_DEPRECATED void set_allocated_partial_caveat_info(::authzed::api::v1::PartialCaveatInfo* partial_caveat_info);
  private:
  const ::authzed::api::v1::PartialCaveatInfo& _internal_partial_caveat_info() const;
  ::authzed::api::v1::PartialCaveatInfo* _internal_mutable_partial_caveat_info();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_partial_caveat_info(
      ::authzed::api::v1::PartialCaveatInfo* partial_caveat_info);
  PROTOBUF_DEPRECATED ::authzed::api::v1::PartialCaveatInfo* unsafe_arena_release_partial_caveat_info();

  // .authzed.api.v1.ResolvedSubject subject = 6 [json_name = "subject"];
  bool has_subject() const;
  private:
  bool _internal_has_subject() const;
  public:
  void clear_subject();
  const ::authzed::api::v1::ResolvedSubject& subject() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::ResolvedSubject* release_subject();
  ::authzed::api::v1::ResolvedSubject* mutable_subject();
  void set_allocated_subject(::authzed::api::v1::ResolvedSubject* subject);
  private:
  const ::authzed::api::v1::ResolvedSubject& _internal_subject() const;
  ::authzed::api::v1::ResolvedSubject* _internal_mutable_subject();
  public:
  void unsafe_arena_set_allocated_subject(
      ::authzed::api::v1::ResolvedSubject* subject);
  ::authzed::api::v1::ResolvedSubject* unsafe_arena_release_subject();

  // .authzed.api.v1.LookupPermissionship permissionship = 4 [json_name = "permissionship", deprecated = true, (.validate.rules) = {
  PROTOBUF_DEPRECATED void clear_permissionship();
  PROTOBUF_DEPRECATED ::authzed::api::v1::LookupPermissionship permissionship() const;
  PROTOBUF_DEPRECATED void set_permissionship(::authzed::api::v1::LookupPermissionship value);
  private:
  ::authzed::api::v1::LookupPermissionship _internal_permissionship() const;
  void _internal_set_permissionship(::authzed::api::v1::LookupPermissionship value);
  public:

  // @@protoc_insertion_point(class_scope:authzed.api.v1.LookupSubjectsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> excluded_subject_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::ResolvedSubject > excluded_subjects_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subject_object_id_;
    ::authzed::api::v1::ZedToken* looked_up_at_;
    ::authzed::api::v1::PartialCaveatInfo* partial_caveat_info_;
    ::authzed::api::v1::ResolvedSubject* subject_;
    int permissionship_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fpermission_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ResolvedSubject final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:authzed.api.v1.ResolvedSubject) */ {
 public:
  inline ResolvedSubject() : ResolvedSubject(nullptr) {}
  ~ResolvedSubject() override;
  explicit PROTOBUF_CONSTEXPR ResolvedSubject(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedSubject(const ResolvedSubject& from);
  ResolvedSubject(ResolvedSubject&& from) noexcept
    : ResolvedSubject() {
    *this = ::std::move(from);
  }

  inline ResolvedSubject& operator=(const ResolvedSubject& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedSubject& operator=(ResolvedSubject&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedSubject& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedSubject* internal_default_instance() {
    return reinterpret_cast<const ResolvedSubject*>(
               &_ResolvedSubject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ResolvedSubject& a, ResolvedSubject& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedSubject* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedSubject* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedSubject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedSubject>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResolvedSubject& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResolvedSubject& from) {
    ResolvedSubject::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedSubject* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "authzed.api.v1.ResolvedSubject";
  }
  protected:
  explicit ResolvedSubject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubjectObjectIdFieldNumber = 1,
    kPartialCaveatInfoFieldNumber = 3,
    kPermissionshipFieldNumber = 2,
  };
  // string subject_object_id = 1 [json_name = "subjectObjectId"];
  void clear_subject_object_id();
  const std::string& subject_object_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subject_object_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subject_object_id();
  PROTOBUF_NODISCARD std::string* release_subject_object_id();
  void set_allocated_subject_object_id(std::string* subject_object_id);
  private:
  const std::string& _internal_subject_object_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject_object_id(const std::string& value);
  std::string* _internal_mutable_subject_object_id();
  public:

  // .authzed.api.v1.PartialCaveatInfo partial_caveat_info = 3 [json_name = "partialCaveatInfo", (.validate.rules) = {
  bool has_partial_caveat_info() const;
  private:
  bool _internal_has_partial_caveat_info() const;
  public:
  void clear_partial_caveat_info();
  const ::authzed::api::v1::PartialCaveatInfo& partial_caveat_info() const;
  PROTOBUF_NODISCARD ::authzed::api::v1::PartialCaveatInfo* release_partial_caveat_info();
  ::authzed::api::v1::PartialCaveatInfo* mutable_partial_caveat_info();
  void set_allocated_partial_caveat_info(::authzed::api::v1::PartialCaveatInfo* partial_caveat_info);
  private:
  const ::authzed::api::v1::PartialCaveatInfo& _internal_partial_caveat_info() const;
  ::authzed::api::v1::PartialCaveatInfo* _internal_mutable_partial_caveat_info();
  public:
  void unsafe_arena_set_allocated_partial_caveat_info(
      ::authzed::api::v1::PartialCaveatInfo* partial_caveat_info);
  ::authzed::api::v1::PartialCaveatInfo* unsafe_arena_release_partial_caveat_info();

  // .authzed.api.v1.LookupPermissionship permissionship = 2 [json_name = "permissionship", (.validate.rules) = {
  void clear_permissionship();
  ::authzed::api::v1::LookupPermissionship permissionship() const;
  void set_permissionship(::authzed::api::v1::LookupPermissionship value);
  private:
  ::authzed::api::v1::LookupPermissionship _internal_permissionship() const;
  void _internal_set_permissionship(::authzed::api::v1::LookupPermissionship value);
  public:

  // @@protoc_insertion_point(class_scope:authzed.api.v1.ResolvedSubject)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subject_object_id_;
    ::authzed::api::v1::PartialCaveatInfo* partial_caveat_info_;
    int permissionship_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_authzed_2fapi_2fv1_2fpermission_5fservice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Consistency

// bool minimize_latency = 1 [json_name = "minimizeLatency", (.validate.rules) = {
inline bool Consistency::_internal_has_minimize_latency() const {
  return requirement_case() == kMinimizeLatency;
}
inline bool Consistency::has_minimize_latency() const {
  return _internal_has_minimize_latency();
}
inline void Consistency::set_has_minimize_latency() {
  _impl_._oneof_case_[0] = kMinimizeLatency;
}
inline void Consistency::clear_minimize_latency() {
  if (_internal_has_minimize_latency()) {
    _impl_.requirement_.minimize_latency_ = false;
    clear_has_requirement();
  }
}
inline bool Consistency::_internal_minimize_latency() const {
  if (_internal_has_minimize_latency()) {
    return _impl_.requirement_.minimize_latency_;
  }
  return false;
}
inline void Consistency::_internal_set_minimize_latency(bool value) {
  if (!_internal_has_minimize_latency()) {
    clear_requirement();
    set_has_minimize_latency();
  }
  _impl_.requirement_.minimize_latency_ = value;
}
inline bool Consistency::minimize_latency() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.Consistency.minimize_latency)
  return _internal_minimize_latency();
}
inline void Consistency::set_minimize_latency(bool value) {
  _internal_set_minimize_latency(value);
  // @@protoc_insertion_point(field_set:authzed.api.v1.Consistency.minimize_latency)
}

// .authzed.api.v1.ZedToken at_least_as_fresh = 2 [json_name = "atLeastAsFresh"];
inline bool Consistency::_internal_has_at_least_as_fresh() const {
  return requirement_case() == kAtLeastAsFresh;
}
inline bool Consistency::has_at_least_as_fresh() const {
  return _internal_has_at_least_as_fresh();
}
inline void Consistency::set_has_at_least_as_fresh() {
  _impl_._oneof_case_[0] = kAtLeastAsFresh;
}
inline ::authzed::api::v1::ZedToken* Consistency::release_at_least_as_fresh() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.Consistency.at_least_as_fresh)
  if (_internal_has_at_least_as_fresh()) {
    clear_has_requirement();
    ::authzed::api::v1::ZedToken* temp = _impl_.requirement_.at_least_as_fresh_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.requirement_.at_least_as_fresh_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::authzed::api::v1::ZedToken& Consistency::_internal_at_least_as_fresh() const {
  return _internal_has_at_least_as_fresh()
      ? *_impl_.requirement_.at_least_as_fresh_
      : reinterpret_cast< ::authzed::api::v1::ZedToken&>(::authzed::api::v1::_ZedToken_default_instance_);
}
inline const ::authzed::api::v1::ZedToken& Consistency::at_least_as_fresh() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.Consistency.at_least_as_fresh)
  return _internal_at_least_as_fresh();
}
inline ::authzed::api::v1::ZedToken* Consistency::unsafe_arena_release_at_least_as_fresh() {
  // @@protoc_insertion_point(field_unsafe_arena_release:authzed.api.v1.Consistency.at_least_as_fresh)
  if (_internal_has_at_least_as_fresh()) {
    clear_has_requirement();
    ::authzed::api::v1::ZedToken* temp = _impl_.requirement_.at_least_as_fresh_;
    _impl_.requirement_.at_least_as_fresh_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Consistency::unsafe_arena_set_allocated_at_least_as_fresh(::authzed::api::v1::ZedToken* at_least_as_fresh) {
  clear_requirement();
  if (at_least_as_fresh) {
    set_has_at_least_as_fresh();
    _impl_.requirement_.at_least_as_fresh_ = at_least_as_fresh;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.Consistency.at_least_as_fresh)
}
inline ::authzed::api::v1::ZedToken* Consistency::_internal_mutable_at_least_as_fresh() {
  if (!_internal_has_at_least_as_fresh()) {
    clear_requirement();
    set_has_at_least_as_fresh();
    _impl_.requirement_.at_least_as_fresh_ = CreateMaybeMessage< ::authzed::api::v1::ZedToken >(GetArenaForAllocation());
  }
  return _impl_.requirement_.at_least_as_fresh_;
}
inline ::authzed::api::v1::ZedToken* Consistency::mutable_at_least_as_fresh() {
  ::authzed::api::v1::ZedToken* _msg = _internal_mutable_at_least_as_fresh();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.Consistency.at_least_as_fresh)
  return _msg;
}

// .authzed.api.v1.ZedToken at_exact_snapshot = 3 [json_name = "atExactSnapshot"];
inline bool Consistency::_internal_has_at_exact_snapshot() const {
  return requirement_case() == kAtExactSnapshot;
}
inline bool Consistency::has_at_exact_snapshot() const {
  return _internal_has_at_exact_snapshot();
}
inline void Consistency::set_has_at_exact_snapshot() {
  _impl_._oneof_case_[0] = kAtExactSnapshot;
}
inline ::authzed::api::v1::ZedToken* Consistency::release_at_exact_snapshot() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.Consistency.at_exact_snapshot)
  if (_internal_has_at_exact_snapshot()) {
    clear_has_requirement();
    ::authzed::api::v1::ZedToken* temp = _impl_.requirement_.at_exact_snapshot_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.requirement_.at_exact_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::authzed::api::v1::ZedToken& Consistency::_internal_at_exact_snapshot() const {
  return _internal_has_at_exact_snapshot()
      ? *_impl_.requirement_.at_exact_snapshot_
      : reinterpret_cast< ::authzed::api::v1::ZedToken&>(::authzed::api::v1::_ZedToken_default_instance_);
}
inline const ::authzed::api::v1::ZedToken& Consistency::at_exact_snapshot() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.Consistency.at_exact_snapshot)
  return _internal_at_exact_snapshot();
}
inline ::authzed::api::v1::ZedToken* Consistency::unsafe_arena_release_at_exact_snapshot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:authzed.api.v1.Consistency.at_exact_snapshot)
  if (_internal_has_at_exact_snapshot()) {
    clear_has_requirement();
    ::authzed::api::v1::ZedToken* temp = _impl_.requirement_.at_exact_snapshot_;
    _impl_.requirement_.at_exact_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Consistency::unsafe_arena_set_allocated_at_exact_snapshot(::authzed::api::v1::ZedToken* at_exact_snapshot) {
  clear_requirement();
  if (at_exact_snapshot) {
    set_has_at_exact_snapshot();
    _impl_.requirement_.at_exact_snapshot_ = at_exact_snapshot;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.Consistency.at_exact_snapshot)
}
inline ::authzed::api::v1::ZedToken* Consistency::_internal_mutable_at_exact_snapshot() {
  if (!_internal_has_at_exact_snapshot()) {
    clear_requirement();
    set_has_at_exact_snapshot();
    _impl_.requirement_.at_exact_snapshot_ = CreateMaybeMessage< ::authzed::api::v1::ZedToken >(GetArenaForAllocation());
  }
  return _impl_.requirement_.at_exact_snapshot_;
}
inline ::authzed::api::v1::ZedToken* Consistency::mutable_at_exact_snapshot() {
  ::authzed::api::v1::ZedToken* _msg = _internal_mutable_at_exact_snapshot();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.Consistency.at_exact_snapshot)
  return _msg;
}

// bool fully_consistent = 4 [json_name = "fullyConsistent", (.validate.rules) = {
inline bool Consistency::_internal_has_fully_consistent() const {
  return requirement_case() == kFullyConsistent;
}
inline bool Consistency::has_fully_consistent() const {
  return _internal_has_fully_consistent();
}
inline void Consistency::set_has_fully_consistent() {
  _impl_._oneof_case_[0] = kFullyConsistent;
}
inline void Consistency::clear_fully_consistent() {
  if (_internal_has_fully_consistent()) {
    _impl_.requirement_.fully_consistent_ = false;
    clear_has_requirement();
  }
}
inline bool Consistency::_internal_fully_consistent() const {
  if (_internal_has_fully_consistent()) {
    return _impl_.requirement_.fully_consistent_;
  }
  return false;
}
inline void Consistency::_internal_set_fully_consistent(bool value) {
  if (!_internal_has_fully_consistent()) {
    clear_requirement();
    set_has_fully_consistent();
  }
  _impl_.requirement_.fully_consistent_ = value;
}
inline bool Consistency::fully_consistent() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.Consistency.fully_consistent)
  return _internal_fully_consistent();
}
inline void Consistency::set_fully_consistent(bool value) {
  _internal_set_fully_consistent(value);
  // @@protoc_insertion_point(field_set:authzed.api.v1.Consistency.fully_consistent)
}

inline bool Consistency::has_requirement() const {
  return requirement_case() != REQUIREMENT_NOT_SET;
}
inline void Consistency::clear_has_requirement() {
  _impl_._oneof_case_[0] = REQUIREMENT_NOT_SET;
}
inline Consistency::RequirementCase Consistency::requirement_case() const {
  return Consistency::RequirementCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RelationshipFilter

// string resource_type = 1 [json_name = "resourceType", (.validate.rules) = {
inline void RelationshipFilter::clear_resource_type() {
  _impl_.resource_type_.ClearToEmpty();
}
inline const std::string& RelationshipFilter::resource_type() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.RelationshipFilter.resource_type)
  return _internal_resource_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RelationshipFilter::set_resource_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.resource_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.RelationshipFilter.resource_type)
}
inline std::string* RelationshipFilter::mutable_resource_type() {
  std::string* _s = _internal_mutable_resource_type();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.RelationshipFilter.resource_type)
  return _s;
}
inline const std::string& RelationshipFilter::_internal_resource_type() const {
  return _impl_.resource_type_.Get();
}
inline void RelationshipFilter::_internal_set_resource_type(const std::string& value) {
  
  _impl_.resource_type_.Set(value, GetArenaForAllocation());
}
inline std::string* RelationshipFilter::_internal_mutable_resource_type() {
  
  return _impl_.resource_type_.Mutable(GetArenaForAllocation());
}
inline std::string* RelationshipFilter::release_resource_type() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.RelationshipFilter.resource_type)
  return _impl_.resource_type_.Release();
}
inline void RelationshipFilter::set_allocated_resource_type(std::string* resource_type) {
  if (resource_type != nullptr) {
    
  } else {
    
  }
  _impl_.resource_type_.SetAllocated(resource_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resource_type_.IsDefault()) {
    _impl_.resource_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.RelationshipFilter.resource_type)
}

// string optional_resource_id = 2 [json_name = "optionalResourceId", (.validate.rules) = {
inline void RelationshipFilter::clear_optional_resource_id() {
  _impl_.optional_resource_id_.ClearToEmpty();
}
inline const std::string& RelationshipFilter::optional_resource_id() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.RelationshipFilter.optional_resource_id)
  return _internal_optional_resource_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RelationshipFilter::set_optional_resource_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.optional_resource_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.RelationshipFilter.optional_resource_id)
}
inline std::string* RelationshipFilter::mutable_optional_resource_id() {
  std::string* _s = _internal_mutable_optional_resource_id();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.RelationshipFilter.optional_resource_id)
  return _s;
}
inline const std::string& RelationshipFilter::_internal_optional_resource_id() const {
  return _impl_.optional_resource_id_.Get();
}
inline void RelationshipFilter::_internal_set_optional_resource_id(const std::string& value) {
  
  _impl_.optional_resource_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RelationshipFilter::_internal_mutable_optional_resource_id() {
  
  return _impl_.optional_resource_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RelationshipFilter::release_optional_resource_id() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.RelationshipFilter.optional_resource_id)
  return _impl_.optional_resource_id_.Release();
}
inline void RelationshipFilter::set_allocated_optional_resource_id(std::string* optional_resource_id) {
  if (optional_resource_id != nullptr) {
    
  } else {
    
  }
  _impl_.optional_resource_id_.SetAllocated(optional_resource_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.optional_resource_id_.IsDefault()) {
    _impl_.optional_resource_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.RelationshipFilter.optional_resource_id)
}

// string optional_relation = 3 [json_name = "optionalRelation", (.validate.rules) = {
inline void RelationshipFilter::clear_optional_relation() {
  _impl_.optional_relation_.ClearToEmpty();
}
inline const std::string& RelationshipFilter::optional_relation() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.RelationshipFilter.optional_relation)
  return _internal_optional_relation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RelationshipFilter::set_optional_relation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.optional_relation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.RelationshipFilter.optional_relation)
}
inline std::string* RelationshipFilter::mutable_optional_relation() {
  std::string* _s = _internal_mutable_optional_relation();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.RelationshipFilter.optional_relation)
  return _s;
}
inline const std::string& RelationshipFilter::_internal_optional_relation() const {
  return _impl_.optional_relation_.Get();
}
inline void RelationshipFilter::_internal_set_optional_relation(const std::string& value) {
  
  _impl_.optional_relation_.Set(value, GetArenaForAllocation());
}
inline std::string* RelationshipFilter::_internal_mutable_optional_relation() {
  
  return _impl_.optional_relation_.Mutable(GetArenaForAllocation());
}
inline std::string* RelationshipFilter::release_optional_relation() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.RelationshipFilter.optional_relation)
  return _impl_.optional_relation_.Release();
}
inline void RelationshipFilter::set_allocated_optional_relation(std::string* optional_relation) {
  if (optional_relation != nullptr) {
    
  } else {
    
  }
  _impl_.optional_relation_.SetAllocated(optional_relation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.optional_relation_.IsDefault()) {
    _impl_.optional_relation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.RelationshipFilter.optional_relation)
}

// .authzed.api.v1.SubjectFilter optional_subject_filter = 4 [json_name = "optionalSubjectFilter"];
inline bool RelationshipFilter::_internal_has_optional_subject_filter() const {
  return this != internal_default_instance() && _impl_.optional_subject_filter_ != nullptr;
}
inline bool RelationshipFilter::has_optional_subject_filter() const {
  return _internal_has_optional_subject_filter();
}
inline void RelationshipFilter::clear_optional_subject_filter() {
  if (GetArenaForAllocation() == nullptr && _impl_.optional_subject_filter_ != nullptr) {
    delete _impl_.optional_subject_filter_;
  }
  _impl_.optional_subject_filter_ = nullptr;
}
inline const ::authzed::api::v1::SubjectFilter& RelationshipFilter::_internal_optional_subject_filter() const {
  const ::authzed::api::v1::SubjectFilter* p = _impl_.optional_subject_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::SubjectFilter&>(
      ::authzed::api::v1::_SubjectFilter_default_instance_);
}
inline const ::authzed::api::v1::SubjectFilter& RelationshipFilter::optional_subject_filter() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.RelationshipFilter.optional_subject_filter)
  return _internal_optional_subject_filter();
}
inline void RelationshipFilter::unsafe_arena_set_allocated_optional_subject_filter(
    ::authzed::api::v1::SubjectFilter* optional_subject_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.optional_subject_filter_);
  }
  _impl_.optional_subject_filter_ = optional_subject_filter;
  if (optional_subject_filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.RelationshipFilter.optional_subject_filter)
}
inline ::authzed::api::v1::SubjectFilter* RelationshipFilter::release_optional_subject_filter() {
  
  ::authzed::api::v1::SubjectFilter* temp = _impl_.optional_subject_filter_;
  _impl_.optional_subject_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::SubjectFilter* RelationshipFilter::unsafe_arena_release_optional_subject_filter() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.RelationshipFilter.optional_subject_filter)
  
  ::authzed::api::v1::SubjectFilter* temp = _impl_.optional_subject_filter_;
  _impl_.optional_subject_filter_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::SubjectFilter* RelationshipFilter::_internal_mutable_optional_subject_filter() {
  
  if (_impl_.optional_subject_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::SubjectFilter>(GetArenaForAllocation());
    _impl_.optional_subject_filter_ = p;
  }
  return _impl_.optional_subject_filter_;
}
inline ::authzed::api::v1::SubjectFilter* RelationshipFilter::mutable_optional_subject_filter() {
  ::authzed::api::v1::SubjectFilter* _msg = _internal_mutable_optional_subject_filter();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.RelationshipFilter.optional_subject_filter)
  return _msg;
}
inline void RelationshipFilter::set_allocated_optional_subject_filter(::authzed::api::v1::SubjectFilter* optional_subject_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.optional_subject_filter_;
  }
  if (optional_subject_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(optional_subject_filter);
    if (message_arena != submessage_arena) {
      optional_subject_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, optional_subject_filter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.optional_subject_filter_ = optional_subject_filter;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.RelationshipFilter.optional_subject_filter)
}

// -------------------------------------------------------------------

// SubjectFilter_RelationFilter

// string relation = 1 [json_name = "relation", (.validate.rules) = {
inline void SubjectFilter_RelationFilter::clear_relation() {
  _impl_.relation_.ClearToEmpty();
}
inline const std::string& SubjectFilter_RelationFilter::relation() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.SubjectFilter.RelationFilter.relation)
  return _internal_relation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubjectFilter_RelationFilter::set_relation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.relation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.SubjectFilter.RelationFilter.relation)
}
inline std::string* SubjectFilter_RelationFilter::mutable_relation() {
  std::string* _s = _internal_mutable_relation();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.SubjectFilter.RelationFilter.relation)
  return _s;
}
inline const std::string& SubjectFilter_RelationFilter::_internal_relation() const {
  return _impl_.relation_.Get();
}
inline void SubjectFilter_RelationFilter::_internal_set_relation(const std::string& value) {
  
  _impl_.relation_.Set(value, GetArenaForAllocation());
}
inline std::string* SubjectFilter_RelationFilter::_internal_mutable_relation() {
  
  return _impl_.relation_.Mutable(GetArenaForAllocation());
}
inline std::string* SubjectFilter_RelationFilter::release_relation() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.SubjectFilter.RelationFilter.relation)
  return _impl_.relation_.Release();
}
inline void SubjectFilter_RelationFilter::set_allocated_relation(std::string* relation) {
  if (relation != nullptr) {
    
  } else {
    
  }
  _impl_.relation_.SetAllocated(relation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.relation_.IsDefault()) {
    _impl_.relation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.SubjectFilter.RelationFilter.relation)
}

// -------------------------------------------------------------------

// SubjectFilter

// string subject_type = 1 [json_name = "subjectType", (.validate.rules) = {
inline void SubjectFilter::clear_subject_type() {
  _impl_.subject_type_.ClearToEmpty();
}
inline const std::string& SubjectFilter::subject_type() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.SubjectFilter.subject_type)
  return _internal_subject_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubjectFilter::set_subject_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subject_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.SubjectFilter.subject_type)
}
inline std::string* SubjectFilter::mutable_subject_type() {
  std::string* _s = _internal_mutable_subject_type();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.SubjectFilter.subject_type)
  return _s;
}
inline const std::string& SubjectFilter::_internal_subject_type() const {
  return _impl_.subject_type_.Get();
}
inline void SubjectFilter::_internal_set_subject_type(const std::string& value) {
  
  _impl_.subject_type_.Set(value, GetArenaForAllocation());
}
inline std::string* SubjectFilter::_internal_mutable_subject_type() {
  
  return _impl_.subject_type_.Mutable(GetArenaForAllocation());
}
inline std::string* SubjectFilter::release_subject_type() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.SubjectFilter.subject_type)
  return _impl_.subject_type_.Release();
}
inline void SubjectFilter::set_allocated_subject_type(std::string* subject_type) {
  if (subject_type != nullptr) {
    
  } else {
    
  }
  _impl_.subject_type_.SetAllocated(subject_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subject_type_.IsDefault()) {
    _impl_.subject_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.SubjectFilter.subject_type)
}

// string optional_subject_id = 2 [json_name = "optionalSubjectId", (.validate.rules) = {
inline void SubjectFilter::clear_optional_subject_id() {
  _impl_.optional_subject_id_.ClearToEmpty();
}
inline const std::string& SubjectFilter::optional_subject_id() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.SubjectFilter.optional_subject_id)
  return _internal_optional_subject_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubjectFilter::set_optional_subject_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.optional_subject_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.SubjectFilter.optional_subject_id)
}
inline std::string* SubjectFilter::mutable_optional_subject_id() {
  std::string* _s = _internal_mutable_optional_subject_id();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.SubjectFilter.optional_subject_id)
  return _s;
}
inline const std::string& SubjectFilter::_internal_optional_subject_id() const {
  return _impl_.optional_subject_id_.Get();
}
inline void SubjectFilter::_internal_set_optional_subject_id(const std::string& value) {
  
  _impl_.optional_subject_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubjectFilter::_internal_mutable_optional_subject_id() {
  
  return _impl_.optional_subject_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SubjectFilter::release_optional_subject_id() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.SubjectFilter.optional_subject_id)
  return _impl_.optional_subject_id_.Release();
}
inline void SubjectFilter::set_allocated_optional_subject_id(std::string* optional_subject_id) {
  if (optional_subject_id != nullptr) {
    
  } else {
    
  }
  _impl_.optional_subject_id_.SetAllocated(optional_subject_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.optional_subject_id_.IsDefault()) {
    _impl_.optional_subject_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.SubjectFilter.optional_subject_id)
}

// .authzed.api.v1.SubjectFilter.RelationFilter optional_relation = 3 [json_name = "optionalRelation"];
inline bool SubjectFilter::_internal_has_optional_relation() const {
  return this != internal_default_instance() && _impl_.optional_relation_ != nullptr;
}
inline bool SubjectFilter::has_optional_relation() const {
  return _internal_has_optional_relation();
}
inline void SubjectFilter::clear_optional_relation() {
  if (GetArenaForAllocation() == nullptr && _impl_.optional_relation_ != nullptr) {
    delete _impl_.optional_relation_;
  }
  _impl_.optional_relation_ = nullptr;
}
inline const ::authzed::api::v1::SubjectFilter_RelationFilter& SubjectFilter::_internal_optional_relation() const {
  const ::authzed::api::v1::SubjectFilter_RelationFilter* p = _impl_.optional_relation_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::SubjectFilter_RelationFilter&>(
      ::authzed::api::v1::_SubjectFilter_RelationFilter_default_instance_);
}
inline const ::authzed::api::v1::SubjectFilter_RelationFilter& SubjectFilter::optional_relation() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.SubjectFilter.optional_relation)
  return _internal_optional_relation();
}
inline void SubjectFilter::unsafe_arena_set_allocated_optional_relation(
    ::authzed::api::v1::SubjectFilter_RelationFilter* optional_relation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.optional_relation_);
  }
  _impl_.optional_relation_ = optional_relation;
  if (optional_relation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.SubjectFilter.optional_relation)
}
inline ::authzed::api::v1::SubjectFilter_RelationFilter* SubjectFilter::release_optional_relation() {
  
  ::authzed::api::v1::SubjectFilter_RelationFilter* temp = _impl_.optional_relation_;
  _impl_.optional_relation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::SubjectFilter_RelationFilter* SubjectFilter::unsafe_arena_release_optional_relation() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.SubjectFilter.optional_relation)
  
  ::authzed::api::v1::SubjectFilter_RelationFilter* temp = _impl_.optional_relation_;
  _impl_.optional_relation_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::SubjectFilter_RelationFilter* SubjectFilter::_internal_mutable_optional_relation() {
  
  if (_impl_.optional_relation_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::SubjectFilter_RelationFilter>(GetArenaForAllocation());
    _impl_.optional_relation_ = p;
  }
  return _impl_.optional_relation_;
}
inline ::authzed::api::v1::SubjectFilter_RelationFilter* SubjectFilter::mutable_optional_relation() {
  ::authzed::api::v1::SubjectFilter_RelationFilter* _msg = _internal_mutable_optional_relation();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.SubjectFilter.optional_relation)
  return _msg;
}
inline void SubjectFilter::set_allocated_optional_relation(::authzed::api::v1::SubjectFilter_RelationFilter* optional_relation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.optional_relation_;
  }
  if (optional_relation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(optional_relation);
    if (message_arena != submessage_arena) {
      optional_relation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, optional_relation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.optional_relation_ = optional_relation;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.SubjectFilter.optional_relation)
}

// -------------------------------------------------------------------

// ReadRelationshipsRequest

// .authzed.api.v1.Consistency consistency = 1 [json_name = "consistency"];
inline bool ReadRelationshipsRequest::_internal_has_consistency() const {
  return this != internal_default_instance() && _impl_.consistency_ != nullptr;
}
inline bool ReadRelationshipsRequest::has_consistency() const {
  return _internal_has_consistency();
}
inline void ReadRelationshipsRequest::clear_consistency() {
  if (GetArenaForAllocation() == nullptr && _impl_.consistency_ != nullptr) {
    delete _impl_.consistency_;
  }
  _impl_.consistency_ = nullptr;
}
inline const ::authzed::api::v1::Consistency& ReadRelationshipsRequest::_internal_consistency() const {
  const ::authzed::api::v1::Consistency* p = _impl_.consistency_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::Consistency&>(
      ::authzed::api::v1::_Consistency_default_instance_);
}
inline const ::authzed::api::v1::Consistency& ReadRelationshipsRequest::consistency() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.ReadRelationshipsRequest.consistency)
  return _internal_consistency();
}
inline void ReadRelationshipsRequest::unsafe_arena_set_allocated_consistency(
    ::authzed::api::v1::Consistency* consistency) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.consistency_);
  }
  _impl_.consistency_ = consistency;
  if (consistency) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.ReadRelationshipsRequest.consistency)
}
inline ::authzed::api::v1::Consistency* ReadRelationshipsRequest::release_consistency() {
  
  ::authzed::api::v1::Consistency* temp = _impl_.consistency_;
  _impl_.consistency_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::Consistency* ReadRelationshipsRequest::unsafe_arena_release_consistency() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.ReadRelationshipsRequest.consistency)
  
  ::authzed::api::v1::Consistency* temp = _impl_.consistency_;
  _impl_.consistency_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::Consistency* ReadRelationshipsRequest::_internal_mutable_consistency() {
  
  if (_impl_.consistency_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::Consistency>(GetArenaForAllocation());
    _impl_.consistency_ = p;
  }
  return _impl_.consistency_;
}
inline ::authzed::api::v1::Consistency* ReadRelationshipsRequest::mutable_consistency() {
  ::authzed::api::v1::Consistency* _msg = _internal_mutable_consistency();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.ReadRelationshipsRequest.consistency)
  return _msg;
}
inline void ReadRelationshipsRequest::set_allocated_consistency(::authzed::api::v1::Consistency* consistency) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.consistency_;
  }
  if (consistency) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(consistency);
    if (message_arena != submessage_arena) {
      consistency = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, consistency, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.consistency_ = consistency;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.ReadRelationshipsRequest.consistency)
}

// .authzed.api.v1.RelationshipFilter relationship_filter = 2 [json_name = "relationshipFilter", (.validate.rules) = {
inline bool ReadRelationshipsRequest::_internal_has_relationship_filter() const {
  return this != internal_default_instance() && _impl_.relationship_filter_ != nullptr;
}
inline bool ReadRelationshipsRequest::has_relationship_filter() const {
  return _internal_has_relationship_filter();
}
inline void ReadRelationshipsRequest::clear_relationship_filter() {
  if (GetArenaForAllocation() == nullptr && _impl_.relationship_filter_ != nullptr) {
    delete _impl_.relationship_filter_;
  }
  _impl_.relationship_filter_ = nullptr;
}
inline const ::authzed::api::v1::RelationshipFilter& ReadRelationshipsRequest::_internal_relationship_filter() const {
  const ::authzed::api::v1::RelationshipFilter* p = _impl_.relationship_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::RelationshipFilter&>(
      ::authzed::api::v1::_RelationshipFilter_default_instance_);
}
inline const ::authzed::api::v1::RelationshipFilter& ReadRelationshipsRequest::relationship_filter() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.ReadRelationshipsRequest.relationship_filter)
  return _internal_relationship_filter();
}
inline void ReadRelationshipsRequest::unsafe_arena_set_allocated_relationship_filter(
    ::authzed::api::v1::RelationshipFilter* relationship_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.relationship_filter_);
  }
  _impl_.relationship_filter_ = relationship_filter;
  if (relationship_filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.ReadRelationshipsRequest.relationship_filter)
}
inline ::authzed::api::v1::RelationshipFilter* ReadRelationshipsRequest::release_relationship_filter() {
  
  ::authzed::api::v1::RelationshipFilter* temp = _impl_.relationship_filter_;
  _impl_.relationship_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::RelationshipFilter* ReadRelationshipsRequest::unsafe_arena_release_relationship_filter() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.ReadRelationshipsRequest.relationship_filter)
  
  ::authzed::api::v1::RelationshipFilter* temp = _impl_.relationship_filter_;
  _impl_.relationship_filter_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::RelationshipFilter* ReadRelationshipsRequest::_internal_mutable_relationship_filter() {
  
  if (_impl_.relationship_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::RelationshipFilter>(GetArenaForAllocation());
    _impl_.relationship_filter_ = p;
  }
  return _impl_.relationship_filter_;
}
inline ::authzed::api::v1::RelationshipFilter* ReadRelationshipsRequest::mutable_relationship_filter() {
  ::authzed::api::v1::RelationshipFilter* _msg = _internal_mutable_relationship_filter();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.ReadRelationshipsRequest.relationship_filter)
  return _msg;
}
inline void ReadRelationshipsRequest::set_allocated_relationship_filter(::authzed::api::v1::RelationshipFilter* relationship_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.relationship_filter_;
  }
  if (relationship_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(relationship_filter);
    if (message_arena != submessage_arena) {
      relationship_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, relationship_filter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.relationship_filter_ = relationship_filter;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.ReadRelationshipsRequest.relationship_filter)
}

// -------------------------------------------------------------------

// ReadRelationshipsResponse

// .authzed.api.v1.ZedToken read_at = 1 [json_name = "readAt", (.validate.rules) = {
inline bool ReadRelationshipsResponse::_internal_has_read_at() const {
  return this != internal_default_instance() && _impl_.read_at_ != nullptr;
}
inline bool ReadRelationshipsResponse::has_read_at() const {
  return _internal_has_read_at();
}
inline const ::authzed::api::v1::ZedToken& ReadRelationshipsResponse::_internal_read_at() const {
  const ::authzed::api::v1::ZedToken* p = _impl_.read_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::ZedToken&>(
      ::authzed::api::v1::_ZedToken_default_instance_);
}
inline const ::authzed::api::v1::ZedToken& ReadRelationshipsResponse::read_at() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.ReadRelationshipsResponse.read_at)
  return _internal_read_at();
}
inline void ReadRelationshipsResponse::unsafe_arena_set_allocated_read_at(
    ::authzed::api::v1::ZedToken* read_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.read_at_);
  }
  _impl_.read_at_ = read_at;
  if (read_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.ReadRelationshipsResponse.read_at)
}
inline ::authzed::api::v1::ZedToken* ReadRelationshipsResponse::release_read_at() {
  
  ::authzed::api::v1::ZedToken* temp = _impl_.read_at_;
  _impl_.read_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::ZedToken* ReadRelationshipsResponse::unsafe_arena_release_read_at() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.ReadRelationshipsResponse.read_at)
  
  ::authzed::api::v1::ZedToken* temp = _impl_.read_at_;
  _impl_.read_at_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::ZedToken* ReadRelationshipsResponse::_internal_mutable_read_at() {
  
  if (_impl_.read_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::ZedToken>(GetArenaForAllocation());
    _impl_.read_at_ = p;
  }
  return _impl_.read_at_;
}
inline ::authzed::api::v1::ZedToken* ReadRelationshipsResponse::mutable_read_at() {
  ::authzed::api::v1::ZedToken* _msg = _internal_mutable_read_at();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.ReadRelationshipsResponse.read_at)
  return _msg;
}
inline void ReadRelationshipsResponse::set_allocated_read_at(::authzed::api::v1::ZedToken* read_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.read_at_);
  }
  if (read_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(read_at));
    if (message_arena != submessage_arena) {
      read_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, read_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.read_at_ = read_at;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.ReadRelationshipsResponse.read_at)
}

// .authzed.api.v1.Relationship relationship = 2 [json_name = "relationship", (.validate.rules) = {
inline bool ReadRelationshipsResponse::_internal_has_relationship() const {
  return this != internal_default_instance() && _impl_.relationship_ != nullptr;
}
inline bool ReadRelationshipsResponse::has_relationship() const {
  return _internal_has_relationship();
}
inline const ::authzed::api::v1::Relationship& ReadRelationshipsResponse::_internal_relationship() const {
  const ::authzed::api::v1::Relationship* p = _impl_.relationship_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::Relationship&>(
      ::authzed::api::v1::_Relationship_default_instance_);
}
inline const ::authzed::api::v1::Relationship& ReadRelationshipsResponse::relationship() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.ReadRelationshipsResponse.relationship)
  return _internal_relationship();
}
inline void ReadRelationshipsResponse::unsafe_arena_set_allocated_relationship(
    ::authzed::api::v1::Relationship* relationship) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.relationship_);
  }
  _impl_.relationship_ = relationship;
  if (relationship) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.ReadRelationshipsResponse.relationship)
}
inline ::authzed::api::v1::Relationship* ReadRelationshipsResponse::release_relationship() {
  
  ::authzed::api::v1::Relationship* temp = _impl_.relationship_;
  _impl_.relationship_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::Relationship* ReadRelationshipsResponse::unsafe_arena_release_relationship() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.ReadRelationshipsResponse.relationship)
  
  ::authzed::api::v1::Relationship* temp = _impl_.relationship_;
  _impl_.relationship_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::Relationship* ReadRelationshipsResponse::_internal_mutable_relationship() {
  
  if (_impl_.relationship_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::Relationship>(GetArenaForAllocation());
    _impl_.relationship_ = p;
  }
  return _impl_.relationship_;
}
inline ::authzed::api::v1::Relationship* ReadRelationshipsResponse::mutable_relationship() {
  ::authzed::api::v1::Relationship* _msg = _internal_mutable_relationship();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.ReadRelationshipsResponse.relationship)
  return _msg;
}
inline void ReadRelationshipsResponse::set_allocated_relationship(::authzed::api::v1::Relationship* relationship) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.relationship_);
  }
  if (relationship) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(relationship));
    if (message_arena != submessage_arena) {
      relationship = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, relationship, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.relationship_ = relationship;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.ReadRelationshipsResponse.relationship)
}

// -------------------------------------------------------------------

// Precondition

// .authzed.api.v1.Precondition.Operation operation = 1 [json_name = "operation", (.validate.rules) = {
inline void Precondition::clear_operation() {
  _impl_.operation_ = 0;
}
inline ::authzed::api::v1::Precondition_Operation Precondition::_internal_operation() const {
  return static_cast< ::authzed::api::v1::Precondition_Operation >(_impl_.operation_);
}
inline ::authzed::api::v1::Precondition_Operation Precondition::operation() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.Precondition.operation)
  return _internal_operation();
}
inline void Precondition::_internal_set_operation(::authzed::api::v1::Precondition_Operation value) {
  
  _impl_.operation_ = value;
}
inline void Precondition::set_operation(::authzed::api::v1::Precondition_Operation value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:authzed.api.v1.Precondition.operation)
}

// .authzed.api.v1.RelationshipFilter filter = 2 [json_name = "filter", (.validate.rules) = {
inline bool Precondition::_internal_has_filter() const {
  return this != internal_default_instance() && _impl_.filter_ != nullptr;
}
inline bool Precondition::has_filter() const {
  return _internal_has_filter();
}
inline void Precondition::clear_filter() {
  if (GetArenaForAllocation() == nullptr && _impl_.filter_ != nullptr) {
    delete _impl_.filter_;
  }
  _impl_.filter_ = nullptr;
}
inline const ::authzed::api::v1::RelationshipFilter& Precondition::_internal_filter() const {
  const ::authzed::api::v1::RelationshipFilter* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::RelationshipFilter&>(
      ::authzed::api::v1::_RelationshipFilter_default_instance_);
}
inline const ::authzed::api::v1::RelationshipFilter& Precondition::filter() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.Precondition.filter)
  return _internal_filter();
}
inline void Precondition::unsafe_arena_set_allocated_filter(
    ::authzed::api::v1::RelationshipFilter* filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = filter;
  if (filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.Precondition.filter)
}
inline ::authzed::api::v1::RelationshipFilter* Precondition::release_filter() {
  
  ::authzed::api::v1::RelationshipFilter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::RelationshipFilter* Precondition::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.Precondition.filter)
  
  ::authzed::api::v1::RelationshipFilter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::RelationshipFilter* Precondition::_internal_mutable_filter() {
  
  if (_impl_.filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::RelationshipFilter>(GetArenaForAllocation());
    _impl_.filter_ = p;
  }
  return _impl_.filter_;
}
inline ::authzed::api::v1::RelationshipFilter* Precondition::mutable_filter() {
  ::authzed::api::v1::RelationshipFilter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.Precondition.filter)
  return _msg;
}
inline void Precondition::set_allocated_filter(::authzed::api::v1::RelationshipFilter* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(filter);
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.Precondition.filter)
}

// -------------------------------------------------------------------

// WriteRelationshipsRequest

// repeated .authzed.api.v1.RelationshipUpdate updates = 1 [json_name = "updates", (.validate.rules) = {
inline int WriteRelationshipsRequest::_internal_updates_size() const {
  return _impl_.updates_.size();
}
inline int WriteRelationshipsRequest::updates_size() const {
  return _internal_updates_size();
}
inline ::authzed::api::v1::RelationshipUpdate* WriteRelationshipsRequest::mutable_updates(int index) {
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.WriteRelationshipsRequest.updates)
  return _impl_.updates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::RelationshipUpdate >*
WriteRelationshipsRequest::mutable_updates() {
  // @@protoc_insertion_point(field_mutable_list:authzed.api.v1.WriteRelationshipsRequest.updates)
  return &_impl_.updates_;
}
inline const ::authzed::api::v1::RelationshipUpdate& WriteRelationshipsRequest::_internal_updates(int index) const {
  return _impl_.updates_.Get(index);
}
inline const ::authzed::api::v1::RelationshipUpdate& WriteRelationshipsRequest::updates(int index) const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.WriteRelationshipsRequest.updates)
  return _internal_updates(index);
}
inline ::authzed::api::v1::RelationshipUpdate* WriteRelationshipsRequest::_internal_add_updates() {
  return _impl_.updates_.Add();
}
inline ::authzed::api::v1::RelationshipUpdate* WriteRelationshipsRequest::add_updates() {
  ::authzed::api::v1::RelationshipUpdate* _add = _internal_add_updates();
  // @@protoc_insertion_point(field_add:authzed.api.v1.WriteRelationshipsRequest.updates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::RelationshipUpdate >&
WriteRelationshipsRequest::updates() const {
  // @@protoc_insertion_point(field_list:authzed.api.v1.WriteRelationshipsRequest.updates)
  return _impl_.updates_;
}

// repeated .authzed.api.v1.Precondition optional_preconditions = 2 [json_name = "optionalPreconditions", (.validate.rules) = {
inline int WriteRelationshipsRequest::_internal_optional_preconditions_size() const {
  return _impl_.optional_preconditions_.size();
}
inline int WriteRelationshipsRequest::optional_preconditions_size() const {
  return _internal_optional_preconditions_size();
}
inline void WriteRelationshipsRequest::clear_optional_preconditions() {
  _impl_.optional_preconditions_.Clear();
}
inline ::authzed::api::v1::Precondition* WriteRelationshipsRequest::mutable_optional_preconditions(int index) {
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.WriteRelationshipsRequest.optional_preconditions)
  return _impl_.optional_preconditions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::Precondition >*
WriteRelationshipsRequest::mutable_optional_preconditions() {
  // @@protoc_insertion_point(field_mutable_list:authzed.api.v1.WriteRelationshipsRequest.optional_preconditions)
  return &_impl_.optional_preconditions_;
}
inline const ::authzed::api::v1::Precondition& WriteRelationshipsRequest::_internal_optional_preconditions(int index) const {
  return _impl_.optional_preconditions_.Get(index);
}
inline const ::authzed::api::v1::Precondition& WriteRelationshipsRequest::optional_preconditions(int index) const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.WriteRelationshipsRequest.optional_preconditions)
  return _internal_optional_preconditions(index);
}
inline ::authzed::api::v1::Precondition* WriteRelationshipsRequest::_internal_add_optional_preconditions() {
  return _impl_.optional_preconditions_.Add();
}
inline ::authzed::api::v1::Precondition* WriteRelationshipsRequest::add_optional_preconditions() {
  ::authzed::api::v1::Precondition* _add = _internal_add_optional_preconditions();
  // @@protoc_insertion_point(field_add:authzed.api.v1.WriteRelationshipsRequest.optional_preconditions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::Precondition >&
WriteRelationshipsRequest::optional_preconditions() const {
  // @@protoc_insertion_point(field_list:authzed.api.v1.WriteRelationshipsRequest.optional_preconditions)
  return _impl_.optional_preconditions_;
}

// -------------------------------------------------------------------

// WriteRelationshipsResponse

// .authzed.api.v1.ZedToken written_at = 1 [json_name = "writtenAt"];
inline bool WriteRelationshipsResponse::_internal_has_written_at() const {
  return this != internal_default_instance() && _impl_.written_at_ != nullptr;
}
inline bool WriteRelationshipsResponse::has_written_at() const {
  return _internal_has_written_at();
}
inline const ::authzed::api::v1::ZedToken& WriteRelationshipsResponse::_internal_written_at() const {
  const ::authzed::api::v1::ZedToken* p = _impl_.written_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::ZedToken&>(
      ::authzed::api::v1::_ZedToken_default_instance_);
}
inline const ::authzed::api::v1::ZedToken& WriteRelationshipsResponse::written_at() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.WriteRelationshipsResponse.written_at)
  return _internal_written_at();
}
inline void WriteRelationshipsResponse::unsafe_arena_set_allocated_written_at(
    ::authzed::api::v1::ZedToken* written_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.written_at_);
  }
  _impl_.written_at_ = written_at;
  if (written_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.WriteRelationshipsResponse.written_at)
}
inline ::authzed::api::v1::ZedToken* WriteRelationshipsResponse::release_written_at() {
  
  ::authzed::api::v1::ZedToken* temp = _impl_.written_at_;
  _impl_.written_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::ZedToken* WriteRelationshipsResponse::unsafe_arena_release_written_at() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.WriteRelationshipsResponse.written_at)
  
  ::authzed::api::v1::ZedToken* temp = _impl_.written_at_;
  _impl_.written_at_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::ZedToken* WriteRelationshipsResponse::_internal_mutable_written_at() {
  
  if (_impl_.written_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::ZedToken>(GetArenaForAllocation());
    _impl_.written_at_ = p;
  }
  return _impl_.written_at_;
}
inline ::authzed::api::v1::ZedToken* WriteRelationshipsResponse::mutable_written_at() {
  ::authzed::api::v1::ZedToken* _msg = _internal_mutable_written_at();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.WriteRelationshipsResponse.written_at)
  return _msg;
}
inline void WriteRelationshipsResponse::set_allocated_written_at(::authzed::api::v1::ZedToken* written_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.written_at_);
  }
  if (written_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(written_at));
    if (message_arena != submessage_arena) {
      written_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, written_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.written_at_ = written_at;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.WriteRelationshipsResponse.written_at)
}

// -------------------------------------------------------------------

// DeleteRelationshipsRequest

// .authzed.api.v1.RelationshipFilter relationship_filter = 1 [json_name = "relationshipFilter", (.validate.rules) = {
inline bool DeleteRelationshipsRequest::_internal_has_relationship_filter() const {
  return this != internal_default_instance() && _impl_.relationship_filter_ != nullptr;
}
inline bool DeleteRelationshipsRequest::has_relationship_filter() const {
  return _internal_has_relationship_filter();
}
inline void DeleteRelationshipsRequest::clear_relationship_filter() {
  if (GetArenaForAllocation() == nullptr && _impl_.relationship_filter_ != nullptr) {
    delete _impl_.relationship_filter_;
  }
  _impl_.relationship_filter_ = nullptr;
}
inline const ::authzed::api::v1::RelationshipFilter& DeleteRelationshipsRequest::_internal_relationship_filter() const {
  const ::authzed::api::v1::RelationshipFilter* p = _impl_.relationship_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::RelationshipFilter&>(
      ::authzed::api::v1::_RelationshipFilter_default_instance_);
}
inline const ::authzed::api::v1::RelationshipFilter& DeleteRelationshipsRequest::relationship_filter() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.DeleteRelationshipsRequest.relationship_filter)
  return _internal_relationship_filter();
}
inline void DeleteRelationshipsRequest::unsafe_arena_set_allocated_relationship_filter(
    ::authzed::api::v1::RelationshipFilter* relationship_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.relationship_filter_);
  }
  _impl_.relationship_filter_ = relationship_filter;
  if (relationship_filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.DeleteRelationshipsRequest.relationship_filter)
}
inline ::authzed::api::v1::RelationshipFilter* DeleteRelationshipsRequest::release_relationship_filter() {
  
  ::authzed::api::v1::RelationshipFilter* temp = _impl_.relationship_filter_;
  _impl_.relationship_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::RelationshipFilter* DeleteRelationshipsRequest::unsafe_arena_release_relationship_filter() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.DeleteRelationshipsRequest.relationship_filter)
  
  ::authzed::api::v1::RelationshipFilter* temp = _impl_.relationship_filter_;
  _impl_.relationship_filter_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::RelationshipFilter* DeleteRelationshipsRequest::_internal_mutable_relationship_filter() {
  
  if (_impl_.relationship_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::RelationshipFilter>(GetArenaForAllocation());
    _impl_.relationship_filter_ = p;
  }
  return _impl_.relationship_filter_;
}
inline ::authzed::api::v1::RelationshipFilter* DeleteRelationshipsRequest::mutable_relationship_filter() {
  ::authzed::api::v1::RelationshipFilter* _msg = _internal_mutable_relationship_filter();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.DeleteRelationshipsRequest.relationship_filter)
  return _msg;
}
inline void DeleteRelationshipsRequest::set_allocated_relationship_filter(::authzed::api::v1::RelationshipFilter* relationship_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.relationship_filter_;
  }
  if (relationship_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(relationship_filter);
    if (message_arena != submessage_arena) {
      relationship_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, relationship_filter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.relationship_filter_ = relationship_filter;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.DeleteRelationshipsRequest.relationship_filter)
}

// repeated .authzed.api.v1.Precondition optional_preconditions = 2 [json_name = "optionalPreconditions", (.validate.rules) = {
inline int DeleteRelationshipsRequest::_internal_optional_preconditions_size() const {
  return _impl_.optional_preconditions_.size();
}
inline int DeleteRelationshipsRequest::optional_preconditions_size() const {
  return _internal_optional_preconditions_size();
}
inline void DeleteRelationshipsRequest::clear_optional_preconditions() {
  _impl_.optional_preconditions_.Clear();
}
inline ::authzed::api::v1::Precondition* DeleteRelationshipsRequest::mutable_optional_preconditions(int index) {
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.DeleteRelationshipsRequest.optional_preconditions)
  return _impl_.optional_preconditions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::Precondition >*
DeleteRelationshipsRequest::mutable_optional_preconditions() {
  // @@protoc_insertion_point(field_mutable_list:authzed.api.v1.DeleteRelationshipsRequest.optional_preconditions)
  return &_impl_.optional_preconditions_;
}
inline const ::authzed::api::v1::Precondition& DeleteRelationshipsRequest::_internal_optional_preconditions(int index) const {
  return _impl_.optional_preconditions_.Get(index);
}
inline const ::authzed::api::v1::Precondition& DeleteRelationshipsRequest::optional_preconditions(int index) const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.DeleteRelationshipsRequest.optional_preconditions)
  return _internal_optional_preconditions(index);
}
inline ::authzed::api::v1::Precondition* DeleteRelationshipsRequest::_internal_add_optional_preconditions() {
  return _impl_.optional_preconditions_.Add();
}
inline ::authzed::api::v1::Precondition* DeleteRelationshipsRequest::add_optional_preconditions() {
  ::authzed::api::v1::Precondition* _add = _internal_add_optional_preconditions();
  // @@protoc_insertion_point(field_add:authzed.api.v1.DeleteRelationshipsRequest.optional_preconditions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::Precondition >&
DeleteRelationshipsRequest::optional_preconditions() const {
  // @@protoc_insertion_point(field_list:authzed.api.v1.DeleteRelationshipsRequest.optional_preconditions)
  return _impl_.optional_preconditions_;
}

// -------------------------------------------------------------------

// DeleteRelationshipsResponse

// .authzed.api.v1.ZedToken deleted_at = 1 [json_name = "deletedAt"];
inline bool DeleteRelationshipsResponse::_internal_has_deleted_at() const {
  return this != internal_default_instance() && _impl_.deleted_at_ != nullptr;
}
inline bool DeleteRelationshipsResponse::has_deleted_at() const {
  return _internal_has_deleted_at();
}
inline const ::authzed::api::v1::ZedToken& DeleteRelationshipsResponse::_internal_deleted_at() const {
  const ::authzed::api::v1::ZedToken* p = _impl_.deleted_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::ZedToken&>(
      ::authzed::api::v1::_ZedToken_default_instance_);
}
inline const ::authzed::api::v1::ZedToken& DeleteRelationshipsResponse::deleted_at() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.DeleteRelationshipsResponse.deleted_at)
  return _internal_deleted_at();
}
inline void DeleteRelationshipsResponse::unsafe_arena_set_allocated_deleted_at(
    ::authzed::api::v1::ZedToken* deleted_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deleted_at_);
  }
  _impl_.deleted_at_ = deleted_at;
  if (deleted_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.DeleteRelationshipsResponse.deleted_at)
}
inline ::authzed::api::v1::ZedToken* DeleteRelationshipsResponse::release_deleted_at() {
  
  ::authzed::api::v1::ZedToken* temp = _impl_.deleted_at_;
  _impl_.deleted_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::ZedToken* DeleteRelationshipsResponse::unsafe_arena_release_deleted_at() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.DeleteRelationshipsResponse.deleted_at)
  
  ::authzed::api::v1::ZedToken* temp = _impl_.deleted_at_;
  _impl_.deleted_at_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::ZedToken* DeleteRelationshipsResponse::_internal_mutable_deleted_at() {
  
  if (_impl_.deleted_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::ZedToken>(GetArenaForAllocation());
    _impl_.deleted_at_ = p;
  }
  return _impl_.deleted_at_;
}
inline ::authzed::api::v1::ZedToken* DeleteRelationshipsResponse::mutable_deleted_at() {
  ::authzed::api::v1::ZedToken* _msg = _internal_mutable_deleted_at();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.DeleteRelationshipsResponse.deleted_at)
  return _msg;
}
inline void DeleteRelationshipsResponse::set_allocated_deleted_at(::authzed::api::v1::ZedToken* deleted_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deleted_at_);
  }
  if (deleted_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deleted_at));
    if (message_arena != submessage_arena) {
      deleted_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deleted_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.deleted_at_ = deleted_at;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.DeleteRelationshipsResponse.deleted_at)
}

// -------------------------------------------------------------------

// CheckPermissionRequest

// .authzed.api.v1.Consistency consistency = 1 [json_name = "consistency"];
inline bool CheckPermissionRequest::_internal_has_consistency() const {
  return this != internal_default_instance() && _impl_.consistency_ != nullptr;
}
inline bool CheckPermissionRequest::has_consistency() const {
  return _internal_has_consistency();
}
inline void CheckPermissionRequest::clear_consistency() {
  if (GetArenaForAllocation() == nullptr && _impl_.consistency_ != nullptr) {
    delete _impl_.consistency_;
  }
  _impl_.consistency_ = nullptr;
}
inline const ::authzed::api::v1::Consistency& CheckPermissionRequest::_internal_consistency() const {
  const ::authzed::api::v1::Consistency* p = _impl_.consistency_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::Consistency&>(
      ::authzed::api::v1::_Consistency_default_instance_);
}
inline const ::authzed::api::v1::Consistency& CheckPermissionRequest::consistency() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.CheckPermissionRequest.consistency)
  return _internal_consistency();
}
inline void CheckPermissionRequest::unsafe_arena_set_allocated_consistency(
    ::authzed::api::v1::Consistency* consistency) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.consistency_);
  }
  _impl_.consistency_ = consistency;
  if (consistency) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.CheckPermissionRequest.consistency)
}
inline ::authzed::api::v1::Consistency* CheckPermissionRequest::release_consistency() {
  
  ::authzed::api::v1::Consistency* temp = _impl_.consistency_;
  _impl_.consistency_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::Consistency* CheckPermissionRequest::unsafe_arena_release_consistency() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.CheckPermissionRequest.consistency)
  
  ::authzed::api::v1::Consistency* temp = _impl_.consistency_;
  _impl_.consistency_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::Consistency* CheckPermissionRequest::_internal_mutable_consistency() {
  
  if (_impl_.consistency_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::Consistency>(GetArenaForAllocation());
    _impl_.consistency_ = p;
  }
  return _impl_.consistency_;
}
inline ::authzed::api::v1::Consistency* CheckPermissionRequest::mutable_consistency() {
  ::authzed::api::v1::Consistency* _msg = _internal_mutable_consistency();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.CheckPermissionRequest.consistency)
  return _msg;
}
inline void CheckPermissionRequest::set_allocated_consistency(::authzed::api::v1::Consistency* consistency) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.consistency_;
  }
  if (consistency) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(consistency);
    if (message_arena != submessage_arena) {
      consistency = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, consistency, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.consistency_ = consistency;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.CheckPermissionRequest.consistency)
}

// .authzed.api.v1.ObjectReference resource = 2 [json_name = "resource", (.validate.rules) = {
inline bool CheckPermissionRequest::_internal_has_resource() const {
  return this != internal_default_instance() && _impl_.resource_ != nullptr;
}
inline bool CheckPermissionRequest::has_resource() const {
  return _internal_has_resource();
}
inline const ::authzed::api::v1::ObjectReference& CheckPermissionRequest::_internal_resource() const {
  const ::authzed::api::v1::ObjectReference* p = _impl_.resource_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::ObjectReference&>(
      ::authzed::api::v1::_ObjectReference_default_instance_);
}
inline const ::authzed::api::v1::ObjectReference& CheckPermissionRequest::resource() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.CheckPermissionRequest.resource)
  return _internal_resource();
}
inline void CheckPermissionRequest::unsafe_arena_set_allocated_resource(
    ::authzed::api::v1::ObjectReference* resource) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resource_);
  }
  _impl_.resource_ = resource;
  if (resource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.CheckPermissionRequest.resource)
}
inline ::authzed::api::v1::ObjectReference* CheckPermissionRequest::release_resource() {
  
  ::authzed::api::v1::ObjectReference* temp = _impl_.resource_;
  _impl_.resource_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::ObjectReference* CheckPermissionRequest::unsafe_arena_release_resource() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.CheckPermissionRequest.resource)
  
  ::authzed::api::v1::ObjectReference* temp = _impl_.resource_;
  _impl_.resource_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::ObjectReference* CheckPermissionRequest::_internal_mutable_resource() {
  
  if (_impl_.resource_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::ObjectReference>(GetArenaForAllocation());
    _impl_.resource_ = p;
  }
  return _impl_.resource_;
}
inline ::authzed::api::v1::ObjectReference* CheckPermissionRequest::mutable_resource() {
  ::authzed::api::v1::ObjectReference* _msg = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.CheckPermissionRequest.resource)
  return _msg;
}
inline void CheckPermissionRequest::set_allocated_resource(::authzed::api::v1::ObjectReference* resource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resource_);
  }
  if (resource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resource));
    if (message_arena != submessage_arena) {
      resource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resource, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.resource_ = resource;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.CheckPermissionRequest.resource)
}

// string permission = 3 [json_name = "permission", (.validate.rules) = {
inline void CheckPermissionRequest::clear_permission() {
  _impl_.permission_.ClearToEmpty();
}
inline const std::string& CheckPermissionRequest::permission() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.CheckPermissionRequest.permission)
  return _internal_permission();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckPermissionRequest::set_permission(ArgT0&& arg0, ArgT... args) {
 
 _impl_.permission_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.CheckPermissionRequest.permission)
}
inline std::string* CheckPermissionRequest::mutable_permission() {
  std::string* _s = _internal_mutable_permission();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.CheckPermissionRequest.permission)
  return _s;
}
inline const std::string& CheckPermissionRequest::_internal_permission() const {
  return _impl_.permission_.Get();
}
inline void CheckPermissionRequest::_internal_set_permission(const std::string& value) {
  
  _impl_.permission_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckPermissionRequest::_internal_mutable_permission() {
  
  return _impl_.permission_.Mutable(GetArenaForAllocation());
}
inline std::string* CheckPermissionRequest::release_permission() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.CheckPermissionRequest.permission)
  return _impl_.permission_.Release();
}
inline void CheckPermissionRequest::set_allocated_permission(std::string* permission) {
  if (permission != nullptr) {
    
  } else {
    
  }
  _impl_.permission_.SetAllocated(permission, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.permission_.IsDefault()) {
    _impl_.permission_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.CheckPermissionRequest.permission)
}

// .authzed.api.v1.SubjectReference subject = 4 [json_name = "subject", (.validate.rules) = {
inline bool CheckPermissionRequest::_internal_has_subject() const {
  return this != internal_default_instance() && _impl_.subject_ != nullptr;
}
inline bool CheckPermissionRequest::has_subject() const {
  return _internal_has_subject();
}
inline const ::authzed::api::v1::SubjectReference& CheckPermissionRequest::_internal_subject() const {
  const ::authzed::api::v1::SubjectReference* p = _impl_.subject_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::SubjectReference&>(
      ::authzed::api::v1::_SubjectReference_default_instance_);
}
inline const ::authzed::api::v1::SubjectReference& CheckPermissionRequest::subject() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.CheckPermissionRequest.subject)
  return _internal_subject();
}
inline void CheckPermissionRequest::unsafe_arena_set_allocated_subject(
    ::authzed::api::v1::SubjectReference* subject) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subject_);
  }
  _impl_.subject_ = subject;
  if (subject) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.CheckPermissionRequest.subject)
}
inline ::authzed::api::v1::SubjectReference* CheckPermissionRequest::release_subject() {
  
  ::authzed::api::v1::SubjectReference* temp = _impl_.subject_;
  _impl_.subject_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::SubjectReference* CheckPermissionRequest::unsafe_arena_release_subject() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.CheckPermissionRequest.subject)
  
  ::authzed::api::v1::SubjectReference* temp = _impl_.subject_;
  _impl_.subject_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::SubjectReference* CheckPermissionRequest::_internal_mutable_subject() {
  
  if (_impl_.subject_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::SubjectReference>(GetArenaForAllocation());
    _impl_.subject_ = p;
  }
  return _impl_.subject_;
}
inline ::authzed::api::v1::SubjectReference* CheckPermissionRequest::mutable_subject() {
  ::authzed::api::v1::SubjectReference* _msg = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.CheckPermissionRequest.subject)
  return _msg;
}
inline void CheckPermissionRequest::set_allocated_subject(::authzed::api::v1::SubjectReference* subject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subject_);
  }
  if (subject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subject));
    if (message_arena != submessage_arena) {
      subject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subject, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.subject_ = subject;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.CheckPermissionRequest.subject)
}

// .google.protobuf.Struct context = 5 [json_name = "context", (.validate.rules) = {
inline bool CheckPermissionRequest::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool CheckPermissionRequest::has_context() const {
  return _internal_has_context();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& CheckPermissionRequest::_internal_context() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& CheckPermissionRequest::context() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.CheckPermissionRequest.context)
  return _internal_context();
}
inline void CheckPermissionRequest::unsafe_arena_set_allocated_context(
    ::PROTOBUF_NAMESPACE_ID::Struct* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.CheckPermissionRequest.context)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CheckPermissionRequest::release_context() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CheckPermissionRequest::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.CheckPermissionRequest.context)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CheckPermissionRequest::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CheckPermissionRequest::mutable_context() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.CheckPermissionRequest.context)
  return _msg;
}
inline void CheckPermissionRequest::set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(context));
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.CheckPermissionRequest.context)
}

// -------------------------------------------------------------------

// CheckPermissionResponse

// .authzed.api.v1.ZedToken checked_at = 1 [json_name = "checkedAt", (.validate.rules) = {
inline bool CheckPermissionResponse::_internal_has_checked_at() const {
  return this != internal_default_instance() && _impl_.checked_at_ != nullptr;
}
inline bool CheckPermissionResponse::has_checked_at() const {
  return _internal_has_checked_at();
}
inline const ::authzed::api::v1::ZedToken& CheckPermissionResponse::_internal_checked_at() const {
  const ::authzed::api::v1::ZedToken* p = _impl_.checked_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::ZedToken&>(
      ::authzed::api::v1::_ZedToken_default_instance_);
}
inline const ::authzed::api::v1::ZedToken& CheckPermissionResponse::checked_at() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.CheckPermissionResponse.checked_at)
  return _internal_checked_at();
}
inline void CheckPermissionResponse::unsafe_arena_set_allocated_checked_at(
    ::authzed::api::v1::ZedToken* checked_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.checked_at_);
  }
  _impl_.checked_at_ = checked_at;
  if (checked_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.CheckPermissionResponse.checked_at)
}
inline ::authzed::api::v1::ZedToken* CheckPermissionResponse::release_checked_at() {
  
  ::authzed::api::v1::ZedToken* temp = _impl_.checked_at_;
  _impl_.checked_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::ZedToken* CheckPermissionResponse::unsafe_arena_release_checked_at() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.CheckPermissionResponse.checked_at)
  
  ::authzed::api::v1::ZedToken* temp = _impl_.checked_at_;
  _impl_.checked_at_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::ZedToken* CheckPermissionResponse::_internal_mutable_checked_at() {
  
  if (_impl_.checked_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::ZedToken>(GetArenaForAllocation());
    _impl_.checked_at_ = p;
  }
  return _impl_.checked_at_;
}
inline ::authzed::api::v1::ZedToken* CheckPermissionResponse::mutable_checked_at() {
  ::authzed::api::v1::ZedToken* _msg = _internal_mutable_checked_at();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.CheckPermissionResponse.checked_at)
  return _msg;
}
inline void CheckPermissionResponse::set_allocated_checked_at(::authzed::api::v1::ZedToken* checked_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.checked_at_);
  }
  if (checked_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(checked_at));
    if (message_arena != submessage_arena) {
      checked_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, checked_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.checked_at_ = checked_at;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.CheckPermissionResponse.checked_at)
}

// .authzed.api.v1.CheckPermissionResponse.Permissionship permissionship = 2 [json_name = "permissionship", (.validate.rules) = {
inline void CheckPermissionResponse::clear_permissionship() {
  _impl_.permissionship_ = 0;
}
inline ::authzed::api::v1::CheckPermissionResponse_Permissionship CheckPermissionResponse::_internal_permissionship() const {
  return static_cast< ::authzed::api::v1::CheckPermissionResponse_Permissionship >(_impl_.permissionship_);
}
inline ::authzed::api::v1::CheckPermissionResponse_Permissionship CheckPermissionResponse::permissionship() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.CheckPermissionResponse.permissionship)
  return _internal_permissionship();
}
inline void CheckPermissionResponse::_internal_set_permissionship(::authzed::api::v1::CheckPermissionResponse_Permissionship value) {
  
  _impl_.permissionship_ = value;
}
inline void CheckPermissionResponse::set_permissionship(::authzed::api::v1::CheckPermissionResponse_Permissionship value) {
  _internal_set_permissionship(value);
  // @@protoc_insertion_point(field_set:authzed.api.v1.CheckPermissionResponse.permissionship)
}

// .authzed.api.v1.PartialCaveatInfo partial_caveat_info = 3 [json_name = "partialCaveatInfo", (.validate.rules) = {
inline bool CheckPermissionResponse::_internal_has_partial_caveat_info() const {
  return this != internal_default_instance() && _impl_.partial_caveat_info_ != nullptr;
}
inline bool CheckPermissionResponse::has_partial_caveat_info() const {
  return _internal_has_partial_caveat_info();
}
inline const ::authzed::api::v1::PartialCaveatInfo& CheckPermissionResponse::_internal_partial_caveat_info() const {
  const ::authzed::api::v1::PartialCaveatInfo* p = _impl_.partial_caveat_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::PartialCaveatInfo&>(
      ::authzed::api::v1::_PartialCaveatInfo_default_instance_);
}
inline const ::authzed::api::v1::PartialCaveatInfo& CheckPermissionResponse::partial_caveat_info() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.CheckPermissionResponse.partial_caveat_info)
  return _internal_partial_caveat_info();
}
inline void CheckPermissionResponse::unsafe_arena_set_allocated_partial_caveat_info(
    ::authzed::api::v1::PartialCaveatInfo* partial_caveat_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.partial_caveat_info_);
  }
  _impl_.partial_caveat_info_ = partial_caveat_info;
  if (partial_caveat_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.CheckPermissionResponse.partial_caveat_info)
}
inline ::authzed::api::v1::PartialCaveatInfo* CheckPermissionResponse::release_partial_caveat_info() {
  
  ::authzed::api::v1::PartialCaveatInfo* temp = _impl_.partial_caveat_info_;
  _impl_.partial_caveat_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::PartialCaveatInfo* CheckPermissionResponse::unsafe_arena_release_partial_caveat_info() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.CheckPermissionResponse.partial_caveat_info)
  
  ::authzed::api::v1::PartialCaveatInfo* temp = _impl_.partial_caveat_info_;
  _impl_.partial_caveat_info_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::PartialCaveatInfo* CheckPermissionResponse::_internal_mutable_partial_caveat_info() {
  
  if (_impl_.partial_caveat_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::PartialCaveatInfo>(GetArenaForAllocation());
    _impl_.partial_caveat_info_ = p;
  }
  return _impl_.partial_caveat_info_;
}
inline ::authzed::api::v1::PartialCaveatInfo* CheckPermissionResponse::mutable_partial_caveat_info() {
  ::authzed::api::v1::PartialCaveatInfo* _msg = _internal_mutable_partial_caveat_info();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.CheckPermissionResponse.partial_caveat_info)
  return _msg;
}
inline void CheckPermissionResponse::set_allocated_partial_caveat_info(::authzed::api::v1::PartialCaveatInfo* partial_caveat_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.partial_caveat_info_);
  }
  if (partial_caveat_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(partial_caveat_info));
    if (message_arena != submessage_arena) {
      partial_caveat_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partial_caveat_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.partial_caveat_info_ = partial_caveat_info;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.CheckPermissionResponse.partial_caveat_info)
}

// -------------------------------------------------------------------

// ExpandPermissionTreeRequest

// .authzed.api.v1.Consistency consistency = 1 [json_name = "consistency"];
inline bool ExpandPermissionTreeRequest::_internal_has_consistency() const {
  return this != internal_default_instance() && _impl_.consistency_ != nullptr;
}
inline bool ExpandPermissionTreeRequest::has_consistency() const {
  return _internal_has_consistency();
}
inline void ExpandPermissionTreeRequest::clear_consistency() {
  if (GetArenaForAllocation() == nullptr && _impl_.consistency_ != nullptr) {
    delete _impl_.consistency_;
  }
  _impl_.consistency_ = nullptr;
}
inline const ::authzed::api::v1::Consistency& ExpandPermissionTreeRequest::_internal_consistency() const {
  const ::authzed::api::v1::Consistency* p = _impl_.consistency_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::Consistency&>(
      ::authzed::api::v1::_Consistency_default_instance_);
}
inline const ::authzed::api::v1::Consistency& ExpandPermissionTreeRequest::consistency() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.ExpandPermissionTreeRequest.consistency)
  return _internal_consistency();
}
inline void ExpandPermissionTreeRequest::unsafe_arena_set_allocated_consistency(
    ::authzed::api::v1::Consistency* consistency) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.consistency_);
  }
  _impl_.consistency_ = consistency;
  if (consistency) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.ExpandPermissionTreeRequest.consistency)
}
inline ::authzed::api::v1::Consistency* ExpandPermissionTreeRequest::release_consistency() {
  
  ::authzed::api::v1::Consistency* temp = _impl_.consistency_;
  _impl_.consistency_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::Consistency* ExpandPermissionTreeRequest::unsafe_arena_release_consistency() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.ExpandPermissionTreeRequest.consistency)
  
  ::authzed::api::v1::Consistency* temp = _impl_.consistency_;
  _impl_.consistency_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::Consistency* ExpandPermissionTreeRequest::_internal_mutable_consistency() {
  
  if (_impl_.consistency_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::Consistency>(GetArenaForAllocation());
    _impl_.consistency_ = p;
  }
  return _impl_.consistency_;
}
inline ::authzed::api::v1::Consistency* ExpandPermissionTreeRequest::mutable_consistency() {
  ::authzed::api::v1::Consistency* _msg = _internal_mutable_consistency();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.ExpandPermissionTreeRequest.consistency)
  return _msg;
}
inline void ExpandPermissionTreeRequest::set_allocated_consistency(::authzed::api::v1::Consistency* consistency) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.consistency_;
  }
  if (consistency) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(consistency);
    if (message_arena != submessage_arena) {
      consistency = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, consistency, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.consistency_ = consistency;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.ExpandPermissionTreeRequest.consistency)
}

// .authzed.api.v1.ObjectReference resource = 2 [json_name = "resource", (.validate.rules) = {
inline bool ExpandPermissionTreeRequest::_internal_has_resource() const {
  return this != internal_default_instance() && _impl_.resource_ != nullptr;
}
inline bool ExpandPermissionTreeRequest::has_resource() const {
  return _internal_has_resource();
}
inline const ::authzed::api::v1::ObjectReference& ExpandPermissionTreeRequest::_internal_resource() const {
  const ::authzed::api::v1::ObjectReference* p = _impl_.resource_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::ObjectReference&>(
      ::authzed::api::v1::_ObjectReference_default_instance_);
}
inline const ::authzed::api::v1::ObjectReference& ExpandPermissionTreeRequest::resource() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.ExpandPermissionTreeRequest.resource)
  return _internal_resource();
}
inline void ExpandPermissionTreeRequest::unsafe_arena_set_allocated_resource(
    ::authzed::api::v1::ObjectReference* resource) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resource_);
  }
  _impl_.resource_ = resource;
  if (resource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.ExpandPermissionTreeRequest.resource)
}
inline ::authzed::api::v1::ObjectReference* ExpandPermissionTreeRequest::release_resource() {
  
  ::authzed::api::v1::ObjectReference* temp = _impl_.resource_;
  _impl_.resource_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::ObjectReference* ExpandPermissionTreeRequest::unsafe_arena_release_resource() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.ExpandPermissionTreeRequest.resource)
  
  ::authzed::api::v1::ObjectReference* temp = _impl_.resource_;
  _impl_.resource_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::ObjectReference* ExpandPermissionTreeRequest::_internal_mutable_resource() {
  
  if (_impl_.resource_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::ObjectReference>(GetArenaForAllocation());
    _impl_.resource_ = p;
  }
  return _impl_.resource_;
}
inline ::authzed::api::v1::ObjectReference* ExpandPermissionTreeRequest::mutable_resource() {
  ::authzed::api::v1::ObjectReference* _msg = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.ExpandPermissionTreeRequest.resource)
  return _msg;
}
inline void ExpandPermissionTreeRequest::set_allocated_resource(::authzed::api::v1::ObjectReference* resource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resource_);
  }
  if (resource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resource));
    if (message_arena != submessage_arena) {
      resource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resource, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.resource_ = resource;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.ExpandPermissionTreeRequest.resource)
}

// string permission = 3 [json_name = "permission", (.validate.rules) = {
inline void ExpandPermissionTreeRequest::clear_permission() {
  _impl_.permission_.ClearToEmpty();
}
inline const std::string& ExpandPermissionTreeRequest::permission() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.ExpandPermissionTreeRequest.permission)
  return _internal_permission();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExpandPermissionTreeRequest::set_permission(ArgT0&& arg0, ArgT... args) {
 
 _impl_.permission_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.ExpandPermissionTreeRequest.permission)
}
inline std::string* ExpandPermissionTreeRequest::mutable_permission() {
  std::string* _s = _internal_mutable_permission();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.ExpandPermissionTreeRequest.permission)
  return _s;
}
inline const std::string& ExpandPermissionTreeRequest::_internal_permission() const {
  return _impl_.permission_.Get();
}
inline void ExpandPermissionTreeRequest::_internal_set_permission(const std::string& value) {
  
  _impl_.permission_.Set(value, GetArenaForAllocation());
}
inline std::string* ExpandPermissionTreeRequest::_internal_mutable_permission() {
  
  return _impl_.permission_.Mutable(GetArenaForAllocation());
}
inline std::string* ExpandPermissionTreeRequest::release_permission() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.ExpandPermissionTreeRequest.permission)
  return _impl_.permission_.Release();
}
inline void ExpandPermissionTreeRequest::set_allocated_permission(std::string* permission) {
  if (permission != nullptr) {
    
  } else {
    
  }
  _impl_.permission_.SetAllocated(permission, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.permission_.IsDefault()) {
    _impl_.permission_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.ExpandPermissionTreeRequest.permission)
}

// -------------------------------------------------------------------

// ExpandPermissionTreeResponse

// .authzed.api.v1.ZedToken expanded_at = 1 [json_name = "expandedAt"];
inline bool ExpandPermissionTreeResponse::_internal_has_expanded_at() const {
  return this != internal_default_instance() && _impl_.expanded_at_ != nullptr;
}
inline bool ExpandPermissionTreeResponse::has_expanded_at() const {
  return _internal_has_expanded_at();
}
inline const ::authzed::api::v1::ZedToken& ExpandPermissionTreeResponse::_internal_expanded_at() const {
  const ::authzed::api::v1::ZedToken* p = _impl_.expanded_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::ZedToken&>(
      ::authzed::api::v1::_ZedToken_default_instance_);
}
inline const ::authzed::api::v1::ZedToken& ExpandPermissionTreeResponse::expanded_at() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.ExpandPermissionTreeResponse.expanded_at)
  return _internal_expanded_at();
}
inline void ExpandPermissionTreeResponse::unsafe_arena_set_allocated_expanded_at(
    ::authzed::api::v1::ZedToken* expanded_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expanded_at_);
  }
  _impl_.expanded_at_ = expanded_at;
  if (expanded_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.ExpandPermissionTreeResponse.expanded_at)
}
inline ::authzed::api::v1::ZedToken* ExpandPermissionTreeResponse::release_expanded_at() {
  
  ::authzed::api::v1::ZedToken* temp = _impl_.expanded_at_;
  _impl_.expanded_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::ZedToken* ExpandPermissionTreeResponse::unsafe_arena_release_expanded_at() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.ExpandPermissionTreeResponse.expanded_at)
  
  ::authzed::api::v1::ZedToken* temp = _impl_.expanded_at_;
  _impl_.expanded_at_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::ZedToken* ExpandPermissionTreeResponse::_internal_mutable_expanded_at() {
  
  if (_impl_.expanded_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::ZedToken>(GetArenaForAllocation());
    _impl_.expanded_at_ = p;
  }
  return _impl_.expanded_at_;
}
inline ::authzed::api::v1::ZedToken* ExpandPermissionTreeResponse::mutable_expanded_at() {
  ::authzed::api::v1::ZedToken* _msg = _internal_mutable_expanded_at();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.ExpandPermissionTreeResponse.expanded_at)
  return _msg;
}
inline void ExpandPermissionTreeResponse::set_allocated_expanded_at(::authzed::api::v1::ZedToken* expanded_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expanded_at_);
  }
  if (expanded_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expanded_at));
    if (message_arena != submessage_arena) {
      expanded_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expanded_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.expanded_at_ = expanded_at;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.ExpandPermissionTreeResponse.expanded_at)
}

// .authzed.api.v1.PermissionRelationshipTree tree_root = 2 [json_name = "treeRoot"];
inline bool ExpandPermissionTreeResponse::_internal_has_tree_root() const {
  return this != internal_default_instance() && _impl_.tree_root_ != nullptr;
}
inline bool ExpandPermissionTreeResponse::has_tree_root() const {
  return _internal_has_tree_root();
}
inline const ::authzed::api::v1::PermissionRelationshipTree& ExpandPermissionTreeResponse::_internal_tree_root() const {
  const ::authzed::api::v1::PermissionRelationshipTree* p = _impl_.tree_root_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::PermissionRelationshipTree&>(
      ::authzed::api::v1::_PermissionRelationshipTree_default_instance_);
}
inline const ::authzed::api::v1::PermissionRelationshipTree& ExpandPermissionTreeResponse::tree_root() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.ExpandPermissionTreeResponse.tree_root)
  return _internal_tree_root();
}
inline void ExpandPermissionTreeResponse::unsafe_arena_set_allocated_tree_root(
    ::authzed::api::v1::PermissionRelationshipTree* tree_root) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tree_root_);
  }
  _impl_.tree_root_ = tree_root;
  if (tree_root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.ExpandPermissionTreeResponse.tree_root)
}
inline ::authzed::api::v1::PermissionRelationshipTree* ExpandPermissionTreeResponse::release_tree_root() {
  
  ::authzed::api::v1::PermissionRelationshipTree* temp = _impl_.tree_root_;
  _impl_.tree_root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::PermissionRelationshipTree* ExpandPermissionTreeResponse::unsafe_arena_release_tree_root() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.ExpandPermissionTreeResponse.tree_root)
  
  ::authzed::api::v1::PermissionRelationshipTree* temp = _impl_.tree_root_;
  _impl_.tree_root_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::PermissionRelationshipTree* ExpandPermissionTreeResponse::_internal_mutable_tree_root() {
  
  if (_impl_.tree_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::PermissionRelationshipTree>(GetArenaForAllocation());
    _impl_.tree_root_ = p;
  }
  return _impl_.tree_root_;
}
inline ::authzed::api::v1::PermissionRelationshipTree* ExpandPermissionTreeResponse::mutable_tree_root() {
  ::authzed::api::v1::PermissionRelationshipTree* _msg = _internal_mutable_tree_root();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.ExpandPermissionTreeResponse.tree_root)
  return _msg;
}
inline void ExpandPermissionTreeResponse::set_allocated_tree_root(::authzed::api::v1::PermissionRelationshipTree* tree_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tree_root_);
  }
  if (tree_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tree_root));
    if (message_arena != submessage_arena) {
      tree_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tree_root, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tree_root_ = tree_root;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.ExpandPermissionTreeResponse.tree_root)
}

// -------------------------------------------------------------------

// LookupResourcesRequest

// .authzed.api.v1.Consistency consistency = 1 [json_name = "consistency"];
inline bool LookupResourcesRequest::_internal_has_consistency() const {
  return this != internal_default_instance() && _impl_.consistency_ != nullptr;
}
inline bool LookupResourcesRequest::has_consistency() const {
  return _internal_has_consistency();
}
inline void LookupResourcesRequest::clear_consistency() {
  if (GetArenaForAllocation() == nullptr && _impl_.consistency_ != nullptr) {
    delete _impl_.consistency_;
  }
  _impl_.consistency_ = nullptr;
}
inline const ::authzed::api::v1::Consistency& LookupResourcesRequest::_internal_consistency() const {
  const ::authzed::api::v1::Consistency* p = _impl_.consistency_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::Consistency&>(
      ::authzed::api::v1::_Consistency_default_instance_);
}
inline const ::authzed::api::v1::Consistency& LookupResourcesRequest::consistency() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.LookupResourcesRequest.consistency)
  return _internal_consistency();
}
inline void LookupResourcesRequest::unsafe_arena_set_allocated_consistency(
    ::authzed::api::v1::Consistency* consistency) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.consistency_);
  }
  _impl_.consistency_ = consistency;
  if (consistency) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.LookupResourcesRequest.consistency)
}
inline ::authzed::api::v1::Consistency* LookupResourcesRequest::release_consistency() {
  
  ::authzed::api::v1::Consistency* temp = _impl_.consistency_;
  _impl_.consistency_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::Consistency* LookupResourcesRequest::unsafe_arena_release_consistency() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.LookupResourcesRequest.consistency)
  
  ::authzed::api::v1::Consistency* temp = _impl_.consistency_;
  _impl_.consistency_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::Consistency* LookupResourcesRequest::_internal_mutable_consistency() {
  
  if (_impl_.consistency_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::Consistency>(GetArenaForAllocation());
    _impl_.consistency_ = p;
  }
  return _impl_.consistency_;
}
inline ::authzed::api::v1::Consistency* LookupResourcesRequest::mutable_consistency() {
  ::authzed::api::v1::Consistency* _msg = _internal_mutable_consistency();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.LookupResourcesRequest.consistency)
  return _msg;
}
inline void LookupResourcesRequest::set_allocated_consistency(::authzed::api::v1::Consistency* consistency) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.consistency_;
  }
  if (consistency) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(consistency);
    if (message_arena != submessage_arena) {
      consistency = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, consistency, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.consistency_ = consistency;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.LookupResourcesRequest.consistency)
}

// string resource_object_type = 2 [json_name = "resourceObjectType", (.validate.rules) = {
inline void LookupResourcesRequest::clear_resource_object_type() {
  _impl_.resource_object_type_.ClearToEmpty();
}
inline const std::string& LookupResourcesRequest::resource_object_type() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.LookupResourcesRequest.resource_object_type)
  return _internal_resource_object_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LookupResourcesRequest::set_resource_object_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.resource_object_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.LookupResourcesRequest.resource_object_type)
}
inline std::string* LookupResourcesRequest::mutable_resource_object_type() {
  std::string* _s = _internal_mutable_resource_object_type();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.LookupResourcesRequest.resource_object_type)
  return _s;
}
inline const std::string& LookupResourcesRequest::_internal_resource_object_type() const {
  return _impl_.resource_object_type_.Get();
}
inline void LookupResourcesRequest::_internal_set_resource_object_type(const std::string& value) {
  
  _impl_.resource_object_type_.Set(value, GetArenaForAllocation());
}
inline std::string* LookupResourcesRequest::_internal_mutable_resource_object_type() {
  
  return _impl_.resource_object_type_.Mutable(GetArenaForAllocation());
}
inline std::string* LookupResourcesRequest::release_resource_object_type() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.LookupResourcesRequest.resource_object_type)
  return _impl_.resource_object_type_.Release();
}
inline void LookupResourcesRequest::set_allocated_resource_object_type(std::string* resource_object_type) {
  if (resource_object_type != nullptr) {
    
  } else {
    
  }
  _impl_.resource_object_type_.SetAllocated(resource_object_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resource_object_type_.IsDefault()) {
    _impl_.resource_object_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.LookupResourcesRequest.resource_object_type)
}

// string permission = 3 [json_name = "permission", (.validate.rules) = {
inline void LookupResourcesRequest::clear_permission() {
  _impl_.permission_.ClearToEmpty();
}
inline const std::string& LookupResourcesRequest::permission() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.LookupResourcesRequest.permission)
  return _internal_permission();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LookupResourcesRequest::set_permission(ArgT0&& arg0, ArgT... args) {
 
 _impl_.permission_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.LookupResourcesRequest.permission)
}
inline std::string* LookupResourcesRequest::mutable_permission() {
  std::string* _s = _internal_mutable_permission();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.LookupResourcesRequest.permission)
  return _s;
}
inline const std::string& LookupResourcesRequest::_internal_permission() const {
  return _impl_.permission_.Get();
}
inline void LookupResourcesRequest::_internal_set_permission(const std::string& value) {
  
  _impl_.permission_.Set(value, GetArenaForAllocation());
}
inline std::string* LookupResourcesRequest::_internal_mutable_permission() {
  
  return _impl_.permission_.Mutable(GetArenaForAllocation());
}
inline std::string* LookupResourcesRequest::release_permission() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.LookupResourcesRequest.permission)
  return _impl_.permission_.Release();
}
inline void LookupResourcesRequest::set_allocated_permission(std::string* permission) {
  if (permission != nullptr) {
    
  } else {
    
  }
  _impl_.permission_.SetAllocated(permission, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.permission_.IsDefault()) {
    _impl_.permission_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.LookupResourcesRequest.permission)
}

// .authzed.api.v1.SubjectReference subject = 4 [json_name = "subject", (.validate.rules) = {
inline bool LookupResourcesRequest::_internal_has_subject() const {
  return this != internal_default_instance() && _impl_.subject_ != nullptr;
}
inline bool LookupResourcesRequest::has_subject() const {
  return _internal_has_subject();
}
inline const ::authzed::api::v1::SubjectReference& LookupResourcesRequest::_internal_subject() const {
  const ::authzed::api::v1::SubjectReference* p = _impl_.subject_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::SubjectReference&>(
      ::authzed::api::v1::_SubjectReference_default_instance_);
}
inline const ::authzed::api::v1::SubjectReference& LookupResourcesRequest::subject() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.LookupResourcesRequest.subject)
  return _internal_subject();
}
inline void LookupResourcesRequest::unsafe_arena_set_allocated_subject(
    ::authzed::api::v1::SubjectReference* subject) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subject_);
  }
  _impl_.subject_ = subject;
  if (subject) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.LookupResourcesRequest.subject)
}
inline ::authzed::api::v1::SubjectReference* LookupResourcesRequest::release_subject() {
  
  ::authzed::api::v1::SubjectReference* temp = _impl_.subject_;
  _impl_.subject_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::SubjectReference* LookupResourcesRequest::unsafe_arena_release_subject() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.LookupResourcesRequest.subject)
  
  ::authzed::api::v1::SubjectReference* temp = _impl_.subject_;
  _impl_.subject_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::SubjectReference* LookupResourcesRequest::_internal_mutable_subject() {
  
  if (_impl_.subject_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::SubjectReference>(GetArenaForAllocation());
    _impl_.subject_ = p;
  }
  return _impl_.subject_;
}
inline ::authzed::api::v1::SubjectReference* LookupResourcesRequest::mutable_subject() {
  ::authzed::api::v1::SubjectReference* _msg = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.LookupResourcesRequest.subject)
  return _msg;
}
inline void LookupResourcesRequest::set_allocated_subject(::authzed::api::v1::SubjectReference* subject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subject_);
  }
  if (subject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subject));
    if (message_arena != submessage_arena) {
      subject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subject, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.subject_ = subject;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.LookupResourcesRequest.subject)
}

// .google.protobuf.Struct context = 5 [json_name = "context", (.validate.rules) = {
inline bool LookupResourcesRequest::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool LookupResourcesRequest::has_context() const {
  return _internal_has_context();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& LookupResourcesRequest::_internal_context() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& LookupResourcesRequest::context() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.LookupResourcesRequest.context)
  return _internal_context();
}
inline void LookupResourcesRequest::unsafe_arena_set_allocated_context(
    ::PROTOBUF_NAMESPACE_ID::Struct* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.LookupResourcesRequest.context)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LookupResourcesRequest::release_context() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LookupResourcesRequest::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.LookupResourcesRequest.context)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LookupResourcesRequest::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LookupResourcesRequest::mutable_context() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.LookupResourcesRequest.context)
  return _msg;
}
inline void LookupResourcesRequest::set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(context));
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.LookupResourcesRequest.context)
}

// -------------------------------------------------------------------

// LookupResourcesResponse

// .authzed.api.v1.ZedToken looked_up_at = 1 [json_name = "lookedUpAt"];
inline bool LookupResourcesResponse::_internal_has_looked_up_at() const {
  return this != internal_default_instance() && _impl_.looked_up_at_ != nullptr;
}
inline bool LookupResourcesResponse::has_looked_up_at() const {
  return _internal_has_looked_up_at();
}
inline const ::authzed::api::v1::ZedToken& LookupResourcesResponse::_internal_looked_up_at() const {
  const ::authzed::api::v1::ZedToken* p = _impl_.looked_up_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::ZedToken&>(
      ::authzed::api::v1::_ZedToken_default_instance_);
}
inline const ::authzed::api::v1::ZedToken& LookupResourcesResponse::looked_up_at() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.LookupResourcesResponse.looked_up_at)
  return _internal_looked_up_at();
}
inline void LookupResourcesResponse::unsafe_arena_set_allocated_looked_up_at(
    ::authzed::api::v1::ZedToken* looked_up_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.looked_up_at_);
  }
  _impl_.looked_up_at_ = looked_up_at;
  if (looked_up_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.LookupResourcesResponse.looked_up_at)
}
inline ::authzed::api::v1::ZedToken* LookupResourcesResponse::release_looked_up_at() {
  
  ::authzed::api::v1::ZedToken* temp = _impl_.looked_up_at_;
  _impl_.looked_up_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::ZedToken* LookupResourcesResponse::unsafe_arena_release_looked_up_at() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.LookupResourcesResponse.looked_up_at)
  
  ::authzed::api::v1::ZedToken* temp = _impl_.looked_up_at_;
  _impl_.looked_up_at_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::ZedToken* LookupResourcesResponse::_internal_mutable_looked_up_at() {
  
  if (_impl_.looked_up_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::ZedToken>(GetArenaForAllocation());
    _impl_.looked_up_at_ = p;
  }
  return _impl_.looked_up_at_;
}
inline ::authzed::api::v1::ZedToken* LookupResourcesResponse::mutable_looked_up_at() {
  ::authzed::api::v1::ZedToken* _msg = _internal_mutable_looked_up_at();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.LookupResourcesResponse.looked_up_at)
  return _msg;
}
inline void LookupResourcesResponse::set_allocated_looked_up_at(::authzed::api::v1::ZedToken* looked_up_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.looked_up_at_);
  }
  if (looked_up_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(looked_up_at));
    if (message_arena != submessage_arena) {
      looked_up_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, looked_up_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.looked_up_at_ = looked_up_at;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.LookupResourcesResponse.looked_up_at)
}

// string resource_object_id = 2 [json_name = "resourceObjectId"];
inline void LookupResourcesResponse::clear_resource_object_id() {
  _impl_.resource_object_id_.ClearToEmpty();
}
inline const std::string& LookupResourcesResponse::resource_object_id() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.LookupResourcesResponse.resource_object_id)
  return _internal_resource_object_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LookupResourcesResponse::set_resource_object_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.resource_object_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.LookupResourcesResponse.resource_object_id)
}
inline std::string* LookupResourcesResponse::mutable_resource_object_id() {
  std::string* _s = _internal_mutable_resource_object_id();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.LookupResourcesResponse.resource_object_id)
  return _s;
}
inline const std::string& LookupResourcesResponse::_internal_resource_object_id() const {
  return _impl_.resource_object_id_.Get();
}
inline void LookupResourcesResponse::_internal_set_resource_object_id(const std::string& value) {
  
  _impl_.resource_object_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LookupResourcesResponse::_internal_mutable_resource_object_id() {
  
  return _impl_.resource_object_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LookupResourcesResponse::release_resource_object_id() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.LookupResourcesResponse.resource_object_id)
  return _impl_.resource_object_id_.Release();
}
inline void LookupResourcesResponse::set_allocated_resource_object_id(std::string* resource_object_id) {
  if (resource_object_id != nullptr) {
    
  } else {
    
  }
  _impl_.resource_object_id_.SetAllocated(resource_object_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resource_object_id_.IsDefault()) {
    _impl_.resource_object_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.LookupResourcesResponse.resource_object_id)
}

// .authzed.api.v1.LookupPermissionship permissionship = 3 [json_name = "permissionship", (.validate.rules) = {
inline void LookupResourcesResponse::clear_permissionship() {
  _impl_.permissionship_ = 0;
}
inline ::authzed::api::v1::LookupPermissionship LookupResourcesResponse::_internal_permissionship() const {
  return static_cast< ::authzed::api::v1::LookupPermissionship >(_impl_.permissionship_);
}
inline ::authzed::api::v1::LookupPermissionship LookupResourcesResponse::permissionship() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.LookupResourcesResponse.permissionship)
  return _internal_permissionship();
}
inline void LookupResourcesResponse::_internal_set_permissionship(::authzed::api::v1::LookupPermissionship value) {
  
  _impl_.permissionship_ = value;
}
inline void LookupResourcesResponse::set_permissionship(::authzed::api::v1::LookupPermissionship value) {
  _internal_set_permissionship(value);
  // @@protoc_insertion_point(field_set:authzed.api.v1.LookupResourcesResponse.permissionship)
}

// .authzed.api.v1.PartialCaveatInfo partial_caveat_info = 4 [json_name = "partialCaveatInfo", (.validate.rules) = {
inline bool LookupResourcesResponse::_internal_has_partial_caveat_info() const {
  return this != internal_default_instance() && _impl_.partial_caveat_info_ != nullptr;
}
inline bool LookupResourcesResponse::has_partial_caveat_info() const {
  return _internal_has_partial_caveat_info();
}
inline const ::authzed::api::v1::PartialCaveatInfo& LookupResourcesResponse::_internal_partial_caveat_info() const {
  const ::authzed::api::v1::PartialCaveatInfo* p = _impl_.partial_caveat_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::PartialCaveatInfo&>(
      ::authzed::api::v1::_PartialCaveatInfo_default_instance_);
}
inline const ::authzed::api::v1::PartialCaveatInfo& LookupResourcesResponse::partial_caveat_info() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.LookupResourcesResponse.partial_caveat_info)
  return _internal_partial_caveat_info();
}
inline void LookupResourcesResponse::unsafe_arena_set_allocated_partial_caveat_info(
    ::authzed::api::v1::PartialCaveatInfo* partial_caveat_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.partial_caveat_info_);
  }
  _impl_.partial_caveat_info_ = partial_caveat_info;
  if (partial_caveat_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.LookupResourcesResponse.partial_caveat_info)
}
inline ::authzed::api::v1::PartialCaveatInfo* LookupResourcesResponse::release_partial_caveat_info() {
  
  ::authzed::api::v1::PartialCaveatInfo* temp = _impl_.partial_caveat_info_;
  _impl_.partial_caveat_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::PartialCaveatInfo* LookupResourcesResponse::unsafe_arena_release_partial_caveat_info() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.LookupResourcesResponse.partial_caveat_info)
  
  ::authzed::api::v1::PartialCaveatInfo* temp = _impl_.partial_caveat_info_;
  _impl_.partial_caveat_info_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::PartialCaveatInfo* LookupResourcesResponse::_internal_mutable_partial_caveat_info() {
  
  if (_impl_.partial_caveat_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::PartialCaveatInfo>(GetArenaForAllocation());
    _impl_.partial_caveat_info_ = p;
  }
  return _impl_.partial_caveat_info_;
}
inline ::authzed::api::v1::PartialCaveatInfo* LookupResourcesResponse::mutable_partial_caveat_info() {
  ::authzed::api::v1::PartialCaveatInfo* _msg = _internal_mutable_partial_caveat_info();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.LookupResourcesResponse.partial_caveat_info)
  return _msg;
}
inline void LookupResourcesResponse::set_allocated_partial_caveat_info(::authzed::api::v1::PartialCaveatInfo* partial_caveat_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.partial_caveat_info_);
  }
  if (partial_caveat_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(partial_caveat_info));
    if (message_arena != submessage_arena) {
      partial_caveat_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partial_caveat_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.partial_caveat_info_ = partial_caveat_info;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.LookupResourcesResponse.partial_caveat_info)
}

// -------------------------------------------------------------------

// LookupSubjectsRequest

// .authzed.api.v1.Consistency consistency = 1 [json_name = "consistency"];
inline bool LookupSubjectsRequest::_internal_has_consistency() const {
  return this != internal_default_instance() && _impl_.consistency_ != nullptr;
}
inline bool LookupSubjectsRequest::has_consistency() const {
  return _internal_has_consistency();
}
inline void LookupSubjectsRequest::clear_consistency() {
  if (GetArenaForAllocation() == nullptr && _impl_.consistency_ != nullptr) {
    delete _impl_.consistency_;
  }
  _impl_.consistency_ = nullptr;
}
inline const ::authzed::api::v1::Consistency& LookupSubjectsRequest::_internal_consistency() const {
  const ::authzed::api::v1::Consistency* p = _impl_.consistency_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::Consistency&>(
      ::authzed::api::v1::_Consistency_default_instance_);
}
inline const ::authzed::api::v1::Consistency& LookupSubjectsRequest::consistency() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.LookupSubjectsRequest.consistency)
  return _internal_consistency();
}
inline void LookupSubjectsRequest::unsafe_arena_set_allocated_consistency(
    ::authzed::api::v1::Consistency* consistency) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.consistency_);
  }
  _impl_.consistency_ = consistency;
  if (consistency) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.LookupSubjectsRequest.consistency)
}
inline ::authzed::api::v1::Consistency* LookupSubjectsRequest::release_consistency() {
  
  ::authzed::api::v1::Consistency* temp = _impl_.consistency_;
  _impl_.consistency_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::Consistency* LookupSubjectsRequest::unsafe_arena_release_consistency() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.LookupSubjectsRequest.consistency)
  
  ::authzed::api::v1::Consistency* temp = _impl_.consistency_;
  _impl_.consistency_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::Consistency* LookupSubjectsRequest::_internal_mutable_consistency() {
  
  if (_impl_.consistency_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::Consistency>(GetArenaForAllocation());
    _impl_.consistency_ = p;
  }
  return _impl_.consistency_;
}
inline ::authzed::api::v1::Consistency* LookupSubjectsRequest::mutable_consistency() {
  ::authzed::api::v1::Consistency* _msg = _internal_mutable_consistency();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.LookupSubjectsRequest.consistency)
  return _msg;
}
inline void LookupSubjectsRequest::set_allocated_consistency(::authzed::api::v1::Consistency* consistency) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.consistency_;
  }
  if (consistency) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(consistency);
    if (message_arena != submessage_arena) {
      consistency = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, consistency, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.consistency_ = consistency;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.LookupSubjectsRequest.consistency)
}

// .authzed.api.v1.ObjectReference resource = 2 [json_name = "resource", (.validate.rules) = {
inline bool LookupSubjectsRequest::_internal_has_resource() const {
  return this != internal_default_instance() && _impl_.resource_ != nullptr;
}
inline bool LookupSubjectsRequest::has_resource() const {
  return _internal_has_resource();
}
inline const ::authzed::api::v1::ObjectReference& LookupSubjectsRequest::_internal_resource() const {
  const ::authzed::api::v1::ObjectReference* p = _impl_.resource_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::ObjectReference&>(
      ::authzed::api::v1::_ObjectReference_default_instance_);
}
inline const ::authzed::api::v1::ObjectReference& LookupSubjectsRequest::resource() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.LookupSubjectsRequest.resource)
  return _internal_resource();
}
inline void LookupSubjectsRequest::unsafe_arena_set_allocated_resource(
    ::authzed::api::v1::ObjectReference* resource) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resource_);
  }
  _impl_.resource_ = resource;
  if (resource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.LookupSubjectsRequest.resource)
}
inline ::authzed::api::v1::ObjectReference* LookupSubjectsRequest::release_resource() {
  
  ::authzed::api::v1::ObjectReference* temp = _impl_.resource_;
  _impl_.resource_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::ObjectReference* LookupSubjectsRequest::unsafe_arena_release_resource() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.LookupSubjectsRequest.resource)
  
  ::authzed::api::v1::ObjectReference* temp = _impl_.resource_;
  _impl_.resource_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::ObjectReference* LookupSubjectsRequest::_internal_mutable_resource() {
  
  if (_impl_.resource_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::ObjectReference>(GetArenaForAllocation());
    _impl_.resource_ = p;
  }
  return _impl_.resource_;
}
inline ::authzed::api::v1::ObjectReference* LookupSubjectsRequest::mutable_resource() {
  ::authzed::api::v1::ObjectReference* _msg = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.LookupSubjectsRequest.resource)
  return _msg;
}
inline void LookupSubjectsRequest::set_allocated_resource(::authzed::api::v1::ObjectReference* resource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resource_);
  }
  if (resource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resource));
    if (message_arena != submessage_arena) {
      resource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resource, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.resource_ = resource;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.LookupSubjectsRequest.resource)
}

// string permission = 3 [json_name = "permission", (.validate.rules) = {
inline void LookupSubjectsRequest::clear_permission() {
  _impl_.permission_.ClearToEmpty();
}
inline const std::string& LookupSubjectsRequest::permission() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.LookupSubjectsRequest.permission)
  return _internal_permission();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LookupSubjectsRequest::set_permission(ArgT0&& arg0, ArgT... args) {
 
 _impl_.permission_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.LookupSubjectsRequest.permission)
}
inline std::string* LookupSubjectsRequest::mutable_permission() {
  std::string* _s = _internal_mutable_permission();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.LookupSubjectsRequest.permission)
  return _s;
}
inline const std::string& LookupSubjectsRequest::_internal_permission() const {
  return _impl_.permission_.Get();
}
inline void LookupSubjectsRequest::_internal_set_permission(const std::string& value) {
  
  _impl_.permission_.Set(value, GetArenaForAllocation());
}
inline std::string* LookupSubjectsRequest::_internal_mutable_permission() {
  
  return _impl_.permission_.Mutable(GetArenaForAllocation());
}
inline std::string* LookupSubjectsRequest::release_permission() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.LookupSubjectsRequest.permission)
  return _impl_.permission_.Release();
}
inline void LookupSubjectsRequest::set_allocated_permission(std::string* permission) {
  if (permission != nullptr) {
    
  } else {
    
  }
  _impl_.permission_.SetAllocated(permission, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.permission_.IsDefault()) {
    _impl_.permission_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.LookupSubjectsRequest.permission)
}

// string subject_object_type = 4 [json_name = "subjectObjectType", (.validate.rules) = {
inline void LookupSubjectsRequest::clear_subject_object_type() {
  _impl_.subject_object_type_.ClearToEmpty();
}
inline const std::string& LookupSubjectsRequest::subject_object_type() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.LookupSubjectsRequest.subject_object_type)
  return _internal_subject_object_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LookupSubjectsRequest::set_subject_object_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subject_object_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.LookupSubjectsRequest.subject_object_type)
}
inline std::string* LookupSubjectsRequest::mutable_subject_object_type() {
  std::string* _s = _internal_mutable_subject_object_type();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.LookupSubjectsRequest.subject_object_type)
  return _s;
}
inline const std::string& LookupSubjectsRequest::_internal_subject_object_type() const {
  return _impl_.subject_object_type_.Get();
}
inline void LookupSubjectsRequest::_internal_set_subject_object_type(const std::string& value) {
  
  _impl_.subject_object_type_.Set(value, GetArenaForAllocation());
}
inline std::string* LookupSubjectsRequest::_internal_mutable_subject_object_type() {
  
  return _impl_.subject_object_type_.Mutable(GetArenaForAllocation());
}
inline std::string* LookupSubjectsRequest::release_subject_object_type() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.LookupSubjectsRequest.subject_object_type)
  return _impl_.subject_object_type_.Release();
}
inline void LookupSubjectsRequest::set_allocated_subject_object_type(std::string* subject_object_type) {
  if (subject_object_type != nullptr) {
    
  } else {
    
  }
  _impl_.subject_object_type_.SetAllocated(subject_object_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subject_object_type_.IsDefault()) {
    _impl_.subject_object_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.LookupSubjectsRequest.subject_object_type)
}

// string optional_subject_relation = 5 [json_name = "optionalSubjectRelation", (.validate.rules) = {
inline void LookupSubjectsRequest::clear_optional_subject_relation() {
  _impl_.optional_subject_relation_.ClearToEmpty();
}
inline const std::string& LookupSubjectsRequest::optional_subject_relation() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.LookupSubjectsRequest.optional_subject_relation)
  return _internal_optional_subject_relation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LookupSubjectsRequest::set_optional_subject_relation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.optional_subject_relation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.LookupSubjectsRequest.optional_subject_relation)
}
inline std::string* LookupSubjectsRequest::mutable_optional_subject_relation() {
  std::string* _s = _internal_mutable_optional_subject_relation();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.LookupSubjectsRequest.optional_subject_relation)
  return _s;
}
inline const std::string& LookupSubjectsRequest::_internal_optional_subject_relation() const {
  return _impl_.optional_subject_relation_.Get();
}
inline void LookupSubjectsRequest::_internal_set_optional_subject_relation(const std::string& value) {
  
  _impl_.optional_subject_relation_.Set(value, GetArenaForAllocation());
}
inline std::string* LookupSubjectsRequest::_internal_mutable_optional_subject_relation() {
  
  return _impl_.optional_subject_relation_.Mutable(GetArenaForAllocation());
}
inline std::string* LookupSubjectsRequest::release_optional_subject_relation() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.LookupSubjectsRequest.optional_subject_relation)
  return _impl_.optional_subject_relation_.Release();
}
inline void LookupSubjectsRequest::set_allocated_optional_subject_relation(std::string* optional_subject_relation) {
  if (optional_subject_relation != nullptr) {
    
  } else {
    
  }
  _impl_.optional_subject_relation_.SetAllocated(optional_subject_relation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.optional_subject_relation_.IsDefault()) {
    _impl_.optional_subject_relation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.LookupSubjectsRequest.optional_subject_relation)
}

// .google.protobuf.Struct context = 6 [json_name = "context", (.validate.rules) = {
inline bool LookupSubjectsRequest::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool LookupSubjectsRequest::has_context() const {
  return _internal_has_context();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& LookupSubjectsRequest::_internal_context() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& LookupSubjectsRequest::context() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.LookupSubjectsRequest.context)
  return _internal_context();
}
inline void LookupSubjectsRequest::unsafe_arena_set_allocated_context(
    ::PROTOBUF_NAMESPACE_ID::Struct* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.LookupSubjectsRequest.context)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LookupSubjectsRequest::release_context() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LookupSubjectsRequest::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.LookupSubjectsRequest.context)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LookupSubjectsRequest::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LookupSubjectsRequest::mutable_context() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.LookupSubjectsRequest.context)
  return _msg;
}
inline void LookupSubjectsRequest::set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(context));
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.LookupSubjectsRequest.context)
}

// -------------------------------------------------------------------

// LookupSubjectsResponse

// .authzed.api.v1.ZedToken looked_up_at = 1 [json_name = "lookedUpAt"];
inline bool LookupSubjectsResponse::_internal_has_looked_up_at() const {
  return this != internal_default_instance() && _impl_.looked_up_at_ != nullptr;
}
inline bool LookupSubjectsResponse::has_looked_up_at() const {
  return _internal_has_looked_up_at();
}
inline const ::authzed::api::v1::ZedToken& LookupSubjectsResponse::_internal_looked_up_at() const {
  const ::authzed::api::v1::ZedToken* p = _impl_.looked_up_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::ZedToken&>(
      ::authzed::api::v1::_ZedToken_default_instance_);
}
inline const ::authzed::api::v1::ZedToken& LookupSubjectsResponse::looked_up_at() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.LookupSubjectsResponse.looked_up_at)
  return _internal_looked_up_at();
}
inline void LookupSubjectsResponse::unsafe_arena_set_allocated_looked_up_at(
    ::authzed::api::v1::ZedToken* looked_up_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.looked_up_at_);
  }
  _impl_.looked_up_at_ = looked_up_at;
  if (looked_up_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.LookupSubjectsResponse.looked_up_at)
}
inline ::authzed::api::v1::ZedToken* LookupSubjectsResponse::release_looked_up_at() {
  
  ::authzed::api::v1::ZedToken* temp = _impl_.looked_up_at_;
  _impl_.looked_up_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::ZedToken* LookupSubjectsResponse::unsafe_arena_release_looked_up_at() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.LookupSubjectsResponse.looked_up_at)
  
  ::authzed::api::v1::ZedToken* temp = _impl_.looked_up_at_;
  _impl_.looked_up_at_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::ZedToken* LookupSubjectsResponse::_internal_mutable_looked_up_at() {
  
  if (_impl_.looked_up_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::ZedToken>(GetArenaForAllocation());
    _impl_.looked_up_at_ = p;
  }
  return _impl_.looked_up_at_;
}
inline ::authzed::api::v1::ZedToken* LookupSubjectsResponse::mutable_looked_up_at() {
  ::authzed::api::v1::ZedToken* _msg = _internal_mutable_looked_up_at();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.LookupSubjectsResponse.looked_up_at)
  return _msg;
}
inline void LookupSubjectsResponse::set_allocated_looked_up_at(::authzed::api::v1::ZedToken* looked_up_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.looked_up_at_);
  }
  if (looked_up_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(looked_up_at));
    if (message_arena != submessage_arena) {
      looked_up_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, looked_up_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.looked_up_at_ = looked_up_at;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.LookupSubjectsResponse.looked_up_at)
}

// string subject_object_id = 2 [json_name = "subjectObjectId", deprecated = true];
inline void LookupSubjectsResponse::clear_subject_object_id() {
  _impl_.subject_object_id_.ClearToEmpty();
}
inline const std::string& LookupSubjectsResponse::subject_object_id() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.LookupSubjectsResponse.subject_object_id)
  return _internal_subject_object_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LookupSubjectsResponse::set_subject_object_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subject_object_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.LookupSubjectsResponse.subject_object_id)
}
inline std::string* LookupSubjectsResponse::mutable_subject_object_id() {
  std::string* _s = _internal_mutable_subject_object_id();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.LookupSubjectsResponse.subject_object_id)
  return _s;
}
inline const std::string& LookupSubjectsResponse::_internal_subject_object_id() const {
  return _impl_.subject_object_id_.Get();
}
inline void LookupSubjectsResponse::_internal_set_subject_object_id(const std::string& value) {
  
  _impl_.subject_object_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LookupSubjectsResponse::_internal_mutable_subject_object_id() {
  
  return _impl_.subject_object_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LookupSubjectsResponse::release_subject_object_id() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.LookupSubjectsResponse.subject_object_id)
  return _impl_.subject_object_id_.Release();
}
inline void LookupSubjectsResponse::set_allocated_subject_object_id(std::string* subject_object_id) {
  if (subject_object_id != nullptr) {
    
  } else {
    
  }
  _impl_.subject_object_id_.SetAllocated(subject_object_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subject_object_id_.IsDefault()) {
    _impl_.subject_object_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.LookupSubjectsResponse.subject_object_id)
}

// repeated string excluded_subject_ids = 3 [json_name = "excludedSubjectIds", deprecated = true];
inline int LookupSubjectsResponse::_internal_excluded_subject_ids_size() const {
  return _impl_.excluded_subject_ids_.size();
}
inline int LookupSubjectsResponse::excluded_subject_ids_size() const {
  return _internal_excluded_subject_ids_size();
}
inline void LookupSubjectsResponse::clear_excluded_subject_ids() {
  _impl_.excluded_subject_ids_.Clear();
}
inline std::string* LookupSubjectsResponse::add_excluded_subject_ids() {
  std::string* _s = _internal_add_excluded_subject_ids();
  // @@protoc_insertion_point(field_add_mutable:authzed.api.v1.LookupSubjectsResponse.excluded_subject_ids)
  return _s;
}
inline const std::string& LookupSubjectsResponse::_internal_excluded_subject_ids(int index) const {
  return _impl_.excluded_subject_ids_.Get(index);
}
inline const std::string& LookupSubjectsResponse::excluded_subject_ids(int index) const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.LookupSubjectsResponse.excluded_subject_ids)
  return _internal_excluded_subject_ids(index);
}
inline std::string* LookupSubjectsResponse::mutable_excluded_subject_ids(int index) {
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.LookupSubjectsResponse.excluded_subject_ids)
  return _impl_.excluded_subject_ids_.Mutable(index);
}
inline void LookupSubjectsResponse::set_excluded_subject_ids(int index, const std::string& value) {
  _impl_.excluded_subject_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:authzed.api.v1.LookupSubjectsResponse.excluded_subject_ids)
}
inline void LookupSubjectsResponse::set_excluded_subject_ids(int index, std::string&& value) {
  _impl_.excluded_subject_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:authzed.api.v1.LookupSubjectsResponse.excluded_subject_ids)
}
inline void LookupSubjectsResponse::set_excluded_subject_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.excluded_subject_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:authzed.api.v1.LookupSubjectsResponse.excluded_subject_ids)
}
inline void LookupSubjectsResponse::set_excluded_subject_ids(int index, const char* value, size_t size) {
  _impl_.excluded_subject_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:authzed.api.v1.LookupSubjectsResponse.excluded_subject_ids)
}
inline std::string* LookupSubjectsResponse::_internal_add_excluded_subject_ids() {
  return _impl_.excluded_subject_ids_.Add();
}
inline void LookupSubjectsResponse::add_excluded_subject_ids(const std::string& value) {
  _impl_.excluded_subject_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:authzed.api.v1.LookupSubjectsResponse.excluded_subject_ids)
}
inline void LookupSubjectsResponse::add_excluded_subject_ids(std::string&& value) {
  _impl_.excluded_subject_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:authzed.api.v1.LookupSubjectsResponse.excluded_subject_ids)
}
inline void LookupSubjectsResponse::add_excluded_subject_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.excluded_subject_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:authzed.api.v1.LookupSubjectsResponse.excluded_subject_ids)
}
inline void LookupSubjectsResponse::add_excluded_subject_ids(const char* value, size_t size) {
  _impl_.excluded_subject_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:authzed.api.v1.LookupSubjectsResponse.excluded_subject_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LookupSubjectsResponse::excluded_subject_ids() const {
  // @@protoc_insertion_point(field_list:authzed.api.v1.LookupSubjectsResponse.excluded_subject_ids)
  return _impl_.excluded_subject_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LookupSubjectsResponse::mutable_excluded_subject_ids() {
  // @@protoc_insertion_point(field_mutable_list:authzed.api.v1.LookupSubjectsResponse.excluded_subject_ids)
  return &_impl_.excluded_subject_ids_;
}

// .authzed.api.v1.LookupPermissionship permissionship = 4 [json_name = "permissionship", deprecated = true, (.validate.rules) = {
inline void LookupSubjectsResponse::clear_permissionship() {
  _impl_.permissionship_ = 0;
}
inline ::authzed::api::v1::LookupPermissionship LookupSubjectsResponse::_internal_permissionship() const {
  return static_cast< ::authzed::api::v1::LookupPermissionship >(_impl_.permissionship_);
}
inline ::authzed::api::v1::LookupPermissionship LookupSubjectsResponse::permissionship() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.LookupSubjectsResponse.permissionship)
  return _internal_permissionship();
}
inline void LookupSubjectsResponse::_internal_set_permissionship(::authzed::api::v1::LookupPermissionship value) {
  
  _impl_.permissionship_ = value;
}
inline void LookupSubjectsResponse::set_permissionship(::authzed::api::v1::LookupPermissionship value) {
  _internal_set_permissionship(value);
  // @@protoc_insertion_point(field_set:authzed.api.v1.LookupSubjectsResponse.permissionship)
}

// .authzed.api.v1.PartialCaveatInfo partial_caveat_info = 5 [json_name = "partialCaveatInfo", deprecated = true, (.validate.rules) = {
inline bool LookupSubjectsResponse::_internal_has_partial_caveat_info() const {
  return this != internal_default_instance() && _impl_.partial_caveat_info_ != nullptr;
}
inline bool LookupSubjectsResponse::has_partial_caveat_info() const {
  return _internal_has_partial_caveat_info();
}
inline const ::authzed::api::v1::PartialCaveatInfo& LookupSubjectsResponse::_internal_partial_caveat_info() const {
  const ::authzed::api::v1::PartialCaveatInfo* p = _impl_.partial_caveat_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::PartialCaveatInfo&>(
      ::authzed::api::v1::_PartialCaveatInfo_default_instance_);
}
inline const ::authzed::api::v1::PartialCaveatInfo& LookupSubjectsResponse::partial_caveat_info() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.LookupSubjectsResponse.partial_caveat_info)
  return _internal_partial_caveat_info();
}
inline void LookupSubjectsResponse::unsafe_arena_set_allocated_partial_caveat_info(
    ::authzed::api::v1::PartialCaveatInfo* partial_caveat_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.partial_caveat_info_);
  }
  _impl_.partial_caveat_info_ = partial_caveat_info;
  if (partial_caveat_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.LookupSubjectsResponse.partial_caveat_info)
}
inline ::authzed::api::v1::PartialCaveatInfo* LookupSubjectsResponse::release_partial_caveat_info() {
  
  ::authzed::api::v1::PartialCaveatInfo* temp = _impl_.partial_caveat_info_;
  _impl_.partial_caveat_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::PartialCaveatInfo* LookupSubjectsResponse::unsafe_arena_release_partial_caveat_info() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.LookupSubjectsResponse.partial_caveat_info)
  
  ::authzed::api::v1::PartialCaveatInfo* temp = _impl_.partial_caveat_info_;
  _impl_.partial_caveat_info_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::PartialCaveatInfo* LookupSubjectsResponse::_internal_mutable_partial_caveat_info() {
  
  if (_impl_.partial_caveat_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::PartialCaveatInfo>(GetArenaForAllocation());
    _impl_.partial_caveat_info_ = p;
  }
  return _impl_.partial_caveat_info_;
}
inline ::authzed::api::v1::PartialCaveatInfo* LookupSubjectsResponse::mutable_partial_caveat_info() {
  ::authzed::api::v1::PartialCaveatInfo* _msg = _internal_mutable_partial_caveat_info();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.LookupSubjectsResponse.partial_caveat_info)
  return _msg;
}
inline void LookupSubjectsResponse::set_allocated_partial_caveat_info(::authzed::api::v1::PartialCaveatInfo* partial_caveat_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.partial_caveat_info_);
  }
  if (partial_caveat_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(partial_caveat_info));
    if (message_arena != submessage_arena) {
      partial_caveat_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partial_caveat_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.partial_caveat_info_ = partial_caveat_info;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.LookupSubjectsResponse.partial_caveat_info)
}

// .authzed.api.v1.ResolvedSubject subject = 6 [json_name = "subject"];
inline bool LookupSubjectsResponse::_internal_has_subject() const {
  return this != internal_default_instance() && _impl_.subject_ != nullptr;
}
inline bool LookupSubjectsResponse::has_subject() const {
  return _internal_has_subject();
}
inline void LookupSubjectsResponse::clear_subject() {
  if (GetArenaForAllocation() == nullptr && _impl_.subject_ != nullptr) {
    delete _impl_.subject_;
  }
  _impl_.subject_ = nullptr;
}
inline const ::authzed::api::v1::ResolvedSubject& LookupSubjectsResponse::_internal_subject() const {
  const ::authzed::api::v1::ResolvedSubject* p = _impl_.subject_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::ResolvedSubject&>(
      ::authzed::api::v1::_ResolvedSubject_default_instance_);
}
inline const ::authzed::api::v1::ResolvedSubject& LookupSubjectsResponse::subject() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.LookupSubjectsResponse.subject)
  return _internal_subject();
}
inline void LookupSubjectsResponse::unsafe_arena_set_allocated_subject(
    ::authzed::api::v1::ResolvedSubject* subject) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subject_);
  }
  _impl_.subject_ = subject;
  if (subject) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.LookupSubjectsResponse.subject)
}
inline ::authzed::api::v1::ResolvedSubject* LookupSubjectsResponse::release_subject() {
  
  ::authzed::api::v1::ResolvedSubject* temp = _impl_.subject_;
  _impl_.subject_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::ResolvedSubject* LookupSubjectsResponse::unsafe_arena_release_subject() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.LookupSubjectsResponse.subject)
  
  ::authzed::api::v1::ResolvedSubject* temp = _impl_.subject_;
  _impl_.subject_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::ResolvedSubject* LookupSubjectsResponse::_internal_mutable_subject() {
  
  if (_impl_.subject_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::ResolvedSubject>(GetArenaForAllocation());
    _impl_.subject_ = p;
  }
  return _impl_.subject_;
}
inline ::authzed::api::v1::ResolvedSubject* LookupSubjectsResponse::mutable_subject() {
  ::authzed::api::v1::ResolvedSubject* _msg = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.LookupSubjectsResponse.subject)
  return _msg;
}
inline void LookupSubjectsResponse::set_allocated_subject(::authzed::api::v1::ResolvedSubject* subject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.subject_;
  }
  if (subject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(subject);
    if (message_arena != submessage_arena) {
      subject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subject, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.subject_ = subject;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.LookupSubjectsResponse.subject)
}

// repeated .authzed.api.v1.ResolvedSubject excluded_subjects = 7 [json_name = "excludedSubjects"];
inline int LookupSubjectsResponse::_internal_excluded_subjects_size() const {
  return _impl_.excluded_subjects_.size();
}
inline int LookupSubjectsResponse::excluded_subjects_size() const {
  return _internal_excluded_subjects_size();
}
inline void LookupSubjectsResponse::clear_excluded_subjects() {
  _impl_.excluded_subjects_.Clear();
}
inline ::authzed::api::v1::ResolvedSubject* LookupSubjectsResponse::mutable_excluded_subjects(int index) {
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.LookupSubjectsResponse.excluded_subjects)
  return _impl_.excluded_subjects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::ResolvedSubject >*
LookupSubjectsResponse::mutable_excluded_subjects() {
  // @@protoc_insertion_point(field_mutable_list:authzed.api.v1.LookupSubjectsResponse.excluded_subjects)
  return &_impl_.excluded_subjects_;
}
inline const ::authzed::api::v1::ResolvedSubject& LookupSubjectsResponse::_internal_excluded_subjects(int index) const {
  return _impl_.excluded_subjects_.Get(index);
}
inline const ::authzed::api::v1::ResolvedSubject& LookupSubjectsResponse::excluded_subjects(int index) const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.LookupSubjectsResponse.excluded_subjects)
  return _internal_excluded_subjects(index);
}
inline ::authzed::api::v1::ResolvedSubject* LookupSubjectsResponse::_internal_add_excluded_subjects() {
  return _impl_.excluded_subjects_.Add();
}
inline ::authzed::api::v1::ResolvedSubject* LookupSubjectsResponse::add_excluded_subjects() {
  ::authzed::api::v1::ResolvedSubject* _add = _internal_add_excluded_subjects();
  // @@protoc_insertion_point(field_add:authzed.api.v1.LookupSubjectsResponse.excluded_subjects)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::authzed::api::v1::ResolvedSubject >&
LookupSubjectsResponse::excluded_subjects() const {
  // @@protoc_insertion_point(field_list:authzed.api.v1.LookupSubjectsResponse.excluded_subjects)
  return _impl_.excluded_subjects_;
}

// -------------------------------------------------------------------

// ResolvedSubject

// string subject_object_id = 1 [json_name = "subjectObjectId"];
inline void ResolvedSubject::clear_subject_object_id() {
  _impl_.subject_object_id_.ClearToEmpty();
}
inline const std::string& ResolvedSubject::subject_object_id() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.ResolvedSubject.subject_object_id)
  return _internal_subject_object_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResolvedSubject::set_subject_object_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subject_object_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:authzed.api.v1.ResolvedSubject.subject_object_id)
}
inline std::string* ResolvedSubject::mutable_subject_object_id() {
  std::string* _s = _internal_mutable_subject_object_id();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.ResolvedSubject.subject_object_id)
  return _s;
}
inline const std::string& ResolvedSubject::_internal_subject_object_id() const {
  return _impl_.subject_object_id_.Get();
}
inline void ResolvedSubject::_internal_set_subject_object_id(const std::string& value) {
  
  _impl_.subject_object_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ResolvedSubject::_internal_mutable_subject_object_id() {
  
  return _impl_.subject_object_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ResolvedSubject::release_subject_object_id() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.ResolvedSubject.subject_object_id)
  return _impl_.subject_object_id_.Release();
}
inline void ResolvedSubject::set_allocated_subject_object_id(std::string* subject_object_id) {
  if (subject_object_id != nullptr) {
    
  } else {
    
  }
  _impl_.subject_object_id_.SetAllocated(subject_object_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subject_object_id_.IsDefault()) {
    _impl_.subject_object_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.ResolvedSubject.subject_object_id)
}

// .authzed.api.v1.LookupPermissionship permissionship = 2 [json_name = "permissionship", (.validate.rules) = {
inline void ResolvedSubject::clear_permissionship() {
  _impl_.permissionship_ = 0;
}
inline ::authzed::api::v1::LookupPermissionship ResolvedSubject::_internal_permissionship() const {
  return static_cast< ::authzed::api::v1::LookupPermissionship >(_impl_.permissionship_);
}
inline ::authzed::api::v1::LookupPermissionship ResolvedSubject::permissionship() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.ResolvedSubject.permissionship)
  return _internal_permissionship();
}
inline void ResolvedSubject::_internal_set_permissionship(::authzed::api::v1::LookupPermissionship value) {
  
  _impl_.permissionship_ = value;
}
inline void ResolvedSubject::set_permissionship(::authzed::api::v1::LookupPermissionship value) {
  _internal_set_permissionship(value);
  // @@protoc_insertion_point(field_set:authzed.api.v1.ResolvedSubject.permissionship)
}

// .authzed.api.v1.PartialCaveatInfo partial_caveat_info = 3 [json_name = "partialCaveatInfo", (.validate.rules) = {
inline bool ResolvedSubject::_internal_has_partial_caveat_info() const {
  return this != internal_default_instance() && _impl_.partial_caveat_info_ != nullptr;
}
inline bool ResolvedSubject::has_partial_caveat_info() const {
  return _internal_has_partial_caveat_info();
}
inline const ::authzed::api::v1::PartialCaveatInfo& ResolvedSubject::_internal_partial_caveat_info() const {
  const ::authzed::api::v1::PartialCaveatInfo* p = _impl_.partial_caveat_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::authzed::api::v1::PartialCaveatInfo&>(
      ::authzed::api::v1::_PartialCaveatInfo_default_instance_);
}
inline const ::authzed::api::v1::PartialCaveatInfo& ResolvedSubject::partial_caveat_info() const {
  // @@protoc_insertion_point(field_get:authzed.api.v1.ResolvedSubject.partial_caveat_info)
  return _internal_partial_caveat_info();
}
inline void ResolvedSubject::unsafe_arena_set_allocated_partial_caveat_info(
    ::authzed::api::v1::PartialCaveatInfo* partial_caveat_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.partial_caveat_info_);
  }
  _impl_.partial_caveat_info_ = partial_caveat_info;
  if (partial_caveat_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:authzed.api.v1.ResolvedSubject.partial_caveat_info)
}
inline ::authzed::api::v1::PartialCaveatInfo* ResolvedSubject::release_partial_caveat_info() {
  
  ::authzed::api::v1::PartialCaveatInfo* temp = _impl_.partial_caveat_info_;
  _impl_.partial_caveat_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::authzed::api::v1::PartialCaveatInfo* ResolvedSubject::unsafe_arena_release_partial_caveat_info() {
  // @@protoc_insertion_point(field_release:authzed.api.v1.ResolvedSubject.partial_caveat_info)
  
  ::authzed::api::v1::PartialCaveatInfo* temp = _impl_.partial_caveat_info_;
  _impl_.partial_caveat_info_ = nullptr;
  return temp;
}
inline ::authzed::api::v1::PartialCaveatInfo* ResolvedSubject::_internal_mutable_partial_caveat_info() {
  
  if (_impl_.partial_caveat_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::authzed::api::v1::PartialCaveatInfo>(GetArenaForAllocation());
    _impl_.partial_caveat_info_ = p;
  }
  return _impl_.partial_caveat_info_;
}
inline ::authzed::api::v1::PartialCaveatInfo* ResolvedSubject::mutable_partial_caveat_info() {
  ::authzed::api::v1::PartialCaveatInfo* _msg = _internal_mutable_partial_caveat_info();
  // @@protoc_insertion_point(field_mutable:authzed.api.v1.ResolvedSubject.partial_caveat_info)
  return _msg;
}
inline void ResolvedSubject::set_allocated_partial_caveat_info(::authzed::api::v1::PartialCaveatInfo* partial_caveat_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.partial_caveat_info_);
  }
  if (partial_caveat_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(partial_caveat_info));
    if (message_arena != submessage_arena) {
      partial_caveat_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partial_caveat_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.partial_caveat_info_ = partial_caveat_info;
  // @@protoc_insertion_point(field_set_allocated:authzed.api.v1.ResolvedSubject.partial_caveat_info)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace api
}  // namespace authzed

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::authzed::api::v1::Precondition_Operation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::authzed::api::v1::Precondition_Operation>() {
  return ::authzed::api::v1::Precondition_Operation_descriptor();
}
template <> struct is_proto_enum< ::authzed::api::v1::CheckPermissionResponse_Permissionship> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::authzed::api::v1::CheckPermissionResponse_Permissionship>() {
  return ::authzed::api::v1::CheckPermissionResponse_Permissionship_descriptor();
}
template <> struct is_proto_enum< ::authzed::api::v1::LookupPermissionship> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::authzed::api::v1::LookupPermissionship>() {
  return ::authzed::api::v1::LookupPermissionship_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_authzed_2fapi_2fv1_2fpermission_5fservice_2eproto
